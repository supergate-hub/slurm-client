// Package v0039 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v0039

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"gopkg.in/yaml.v2"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	TokenScopes      = "token.Scopes"
	UserScopes       = "user.Scopes"
)

// Defines values for V0039CronEntryFlags.
const (
	V0039CronEntryFlagsWILDDAYOFMONTH V0039CronEntryFlags = "WILD_DAY_OF_MONTH"
	V0039CronEntryFlagsWILDDAYOFWEEK  V0039CronEntryFlags = "WILD_DAY_OF_WEEK"
	V0039CronEntryFlagsWILDHOUR       V0039CronEntryFlags = "WILD_HOUR"
	V0039CronEntryFlagsWILDMINUTE     V0039CronEntryFlags = "WILD_MINUTE"
	V0039CronEntryFlagsWILDMONTH      V0039CronEntryFlags = "WILD_MONTH"
)

// Defines values for V0039JobDescMsgCpuBindingFlags.
const (
	V0039JobDescMsgCpuBindingFlagsCPUAUTOBINDTOCORES      V0039JobDescMsgCpuBindingFlags = "CPU_AUTO_BIND_TO_CORES"
	V0039JobDescMsgCpuBindingFlagsCPUAUTOBINDTOSOCKETS    V0039JobDescMsgCpuBindingFlags = "CPU_AUTO_BIND_TO_SOCKETS"
	V0039JobDescMsgCpuBindingFlagsCPUAUTOBINDTOTHREADS    V0039JobDescMsgCpuBindingFlags = "CPU_AUTO_BIND_TO_THREADS"
	V0039JobDescMsgCpuBindingFlagsCPUBINDLDMAP            V0039JobDescMsgCpuBindingFlags = "CPU_BIND_LDMAP"
	V0039JobDescMsgCpuBindingFlagsCPUBINDLDMASK           V0039JobDescMsgCpuBindingFlags = "CPU_BIND_LDMASK"
	V0039JobDescMsgCpuBindingFlagsCPUBINDLDRANK           V0039JobDescMsgCpuBindingFlags = "CPU_BIND_LDRANK"
	V0039JobDescMsgCpuBindingFlagsCPUBINDMAP              V0039JobDescMsgCpuBindingFlags = "CPU_BIND_MAP"
	V0039JobDescMsgCpuBindingFlagsCPUBINDMASK             V0039JobDescMsgCpuBindingFlags = "CPU_BIND_MASK"
	V0039JobDescMsgCpuBindingFlagsCPUBINDNONE             V0039JobDescMsgCpuBindingFlags = "CPU_BIND_NONE"
	V0039JobDescMsgCpuBindingFlagsCPUBINDOFF              V0039JobDescMsgCpuBindingFlags = "CPU_BIND_OFF"
	V0039JobDescMsgCpuBindingFlagsCPUBINDONETHREADPERCORE V0039JobDescMsgCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	V0039JobDescMsgCpuBindingFlagsCPUBINDRANK             V0039JobDescMsgCpuBindingFlags = "CPU_BIND_RANK"
	V0039JobDescMsgCpuBindingFlagsCPUBINDTOCORES          V0039JobDescMsgCpuBindingFlags = "CPU_BIND_TO_CORES"
	V0039JobDescMsgCpuBindingFlagsCPUBINDTOLDOMS          V0039JobDescMsgCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	V0039JobDescMsgCpuBindingFlagsCPUBINDTOSOCKETS        V0039JobDescMsgCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	V0039JobDescMsgCpuBindingFlagsCPUBINDTOTHREADS        V0039JobDescMsgCpuBindingFlags = "CPU_BIND_TO_THREADS"
	V0039JobDescMsgCpuBindingFlagsSLURMDOFFSPEC           V0039JobDescMsgCpuBindingFlags = "SLURMD_OFF_SPEC"
	V0039JobDescMsgCpuBindingFlagsVERBOSE                 V0039JobDescMsgCpuBindingFlags = "VERBOSE"
)

// Defines values for V0039JobDescMsgFlags.
const (
	V0039JobDescMsgFlagsACCRUECOUNTCLEARED       V0039JobDescMsgFlags = "ACCRUE_COUNT_CLEARED"
	V0039JobDescMsgFlagsBACKFILLATTEMPTED        V0039JobDescMsgFlags = "BACKFILL_ATTEMPTED"
	V0039JobDescMsgFlagsCRONJOB                  V0039JobDescMsgFlags = "CRON_JOB"
	V0039JobDescMsgFlagsDEPENDENT                V0039JobDescMsgFlags = "DEPENDENT"
	V0039JobDescMsgFlagsEXACTCPUCOUNTREQUESTED   V0039JobDescMsgFlags = "EXACT_CPU_COUNT_REQUESTED"
	V0039JobDescMsgFlagsEXACTMEMORYREQUESTED     V0039JobDescMsgFlags = "EXACT_MEMORY_REQUESTED"
	V0039JobDescMsgFlagsEXACTTASKCOUNTREQUESTED  V0039JobDescMsgFlags = "EXACT_TASK_COUNT_REQUESTED"
	V0039JobDescMsgFlagsGREDBINDINGDISABLED      V0039JobDescMsgFlags = "GRED_BINDING_DISABLED"
	V0039JobDescMsgFlagsGRESBINDINGENFORCED      V0039JobDescMsgFlags = "GRES_BINDING_ENFORCED"
	V0039JobDescMsgFlagsHASSTATEDIRECTORY        V0039JobDescMsgFlags = "HAS_STATE_DIRECTORY"
	V0039JobDescMsgFlagsHETEROGENEOUSJOB         V0039JobDescMsgFlags = "HETEROGENEOUS_JOB"
	V0039JobDescMsgFlagsJOBACCRUETIMERESET       V0039JobDescMsgFlags = "JOB_ACCRUE_TIME_RESET"
	V0039JobDescMsgFlagsJOBKILLHURRY             V0039JobDescMsgFlags = "JOB_KILL_HURRY"
	V0039JobDescMsgFlagsJOBWASRUNNING            V0039JobDescMsgFlags = "JOB_WAS_RUNNING"
	V0039JobDescMsgFlagsKILLINVALIDDEPENDENCY    V0039JobDescMsgFlags = "KILL_INVALID_DEPENDENCY"
	V0039JobDescMsgFlagsMAGNETIC                 V0039JobDescMsgFlags = "MAGNETIC"
	V0039JobDescMsgFlagsNOKILLINVALIDDEPENDENCY  V0039JobDescMsgFlags = "NO_KILL_INVALID_DEPENDENCY"
	V0039JobDescMsgFlagsPARTITIONASSIGNED        V0039JobDescMsgFlags = "PARTITION_ASSIGNED"
	V0039JobDescMsgFlagsPREFERMINIMUMNODECOUNT   V0039JobDescMsgFlags = "PREFER_MINIMUM_NODE_COUNT"
	V0039JobDescMsgFlagsSAVEBATCHSCRIPT          V0039JobDescMsgFlags = "SAVE_BATCH_SCRIPT"
	V0039JobDescMsgFlagsSCHEDULINGATTEMPTED      V0039JobDescMsgFlags = "SCHEDULING_ATTEMPTED"
	V0039JobDescMsgFlagsSENDJOBENVIRONMENT       V0039JobDescMsgFlags = "SEND_JOB_ENVIRONMENT"
	V0039JobDescMsgFlagsSIBLINGCLUSTERUPDATEONLY V0039JobDescMsgFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	V0039JobDescMsgFlagsSKIPTRESSTRINGACCOUNTING V0039JobDescMsgFlags = "SKIP_TRES_STRING_ACCOUNTING"
	V0039JobDescMsgFlagsSPREADJOB                V0039JobDescMsgFlags = "SPREAD_JOB"
	V0039JobDescMsgFlagsTESTINGBACKFILL          V0039JobDescMsgFlags = "TESTING_BACKFILL"
	V0039JobDescMsgFlagsTESTINGWHOLENODEBACKFILL V0039JobDescMsgFlags = "TESTING_WHOLE_NODE_BACKFILL"
	V0039JobDescMsgFlagsTESTNOWONLY              V0039JobDescMsgFlags = "TEST_NOW_ONLY"
	V0039JobDescMsgFlagsTOPPRIORITYJOB           V0039JobDescMsgFlags = "TOP_PRIORITY_JOB"
	V0039JobDescMsgFlagsUSINGDEFAULTACCOUNT      V0039JobDescMsgFlags = "USING_DEFAULT_ACCOUNT"
	V0039JobDescMsgFlagsUSINGDEFAULTPARTITION    V0039JobDescMsgFlags = "USING_DEFAULT_PARTITION"
	V0039JobDescMsgFlagsUSINGDEFAULTQOS          V0039JobDescMsgFlags = "USING_DEFAULT_QOS"
	V0039JobDescMsgFlagsUSINGDEFAULTWCKEY        V0039JobDescMsgFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for V0039JobDescMsgKillWarningFlags.
const (
	V0039JobDescMsgKillWarningFlagsARRAYTASK         V0039JobDescMsgKillWarningFlags = "ARRAY_TASK"
	V0039JobDescMsgKillWarningFlagsBATCHJOB          V0039JobDescMsgKillWarningFlags = "BATCH_JOB"
	V0039JobDescMsgKillWarningFlagsFEDERATIONREQUEUE V0039JobDescMsgKillWarningFlags = "FEDERATION_REQUEUE"
	V0039JobDescMsgKillWarningFlagsFULLJOB           V0039JobDescMsgKillWarningFlags = "FULL_JOB"
	V0039JobDescMsgKillWarningFlagsFULLSTEPSONLY     V0039JobDescMsgKillWarningFlags = "FULL_STEPS_ONLY"
	V0039JobDescMsgKillWarningFlagsHURRY             V0039JobDescMsgKillWarningFlags = "HURRY"
	V0039JobDescMsgKillWarningFlagsNOSIBLINGJOBS     V0039JobDescMsgKillWarningFlags = "NO_SIBLING_JOBS"
	V0039JobDescMsgKillWarningFlagsOUTOFMEMORY       V0039JobDescMsgKillWarningFlags = "OUT_OF_MEMORY"
	V0039JobDescMsgKillWarningFlagsRESERVATIONJOB    V0039JobDescMsgKillWarningFlags = "RESERVATION_JOB"
	V0039JobDescMsgKillWarningFlagsWARNINGSENT       V0039JobDescMsgKillWarningFlags = "WARNING_SENT"
)

// Defines values for V0039JobDescMsgMailType.
const (
	V0039JobDescMsgMailTypeARRAYTASKS        V0039JobDescMsgMailType = "ARRAY_TASKS"
	V0039JobDescMsgMailTypeBEGIN             V0039JobDescMsgMailType = "BEGIN"
	V0039JobDescMsgMailTypeEND               V0039JobDescMsgMailType = "END"
	V0039JobDescMsgMailTypeFAIL              V0039JobDescMsgMailType = "FAIL"
	V0039JobDescMsgMailTypeINVALIDDEPENDENCY V0039JobDescMsgMailType = "INVALID_DEPENDENCY"
	V0039JobDescMsgMailTypeREQUEUE           V0039JobDescMsgMailType = "REQUEUE"
	V0039JobDescMsgMailTypeSTAGEOUT          V0039JobDescMsgMailType = "STAGE_OUT"
	V0039JobDescMsgMailTypeTIME100           V0039JobDescMsgMailType = "TIME=100%"
	V0039JobDescMsgMailTypeTIME50            V0039JobDescMsgMailType = "TIME=50%"
	V0039JobDescMsgMailTypeTIME80            V0039JobDescMsgMailType = "TIME=80%"
	V0039JobDescMsgMailTypeTIME90            V0039JobDescMsgMailType = "TIME=90%"
)

// Defines values for V0039JobDescMsgMemoryBindingType.
const (
	V0039JobDescMsgMemoryBindingTypeLOCAL   V0039JobDescMsgMemoryBindingType = "LOCAL"
	V0039JobDescMsgMemoryBindingTypeMAP     V0039JobDescMsgMemoryBindingType = "MAP"
	V0039JobDescMsgMemoryBindingTypeMASK    V0039JobDescMsgMemoryBindingType = "MASK"
	V0039JobDescMsgMemoryBindingTypeNONE    V0039JobDescMsgMemoryBindingType = "NONE"
	V0039JobDescMsgMemoryBindingTypePREFER  V0039JobDescMsgMemoryBindingType = "PREFER"
	V0039JobDescMsgMemoryBindingTypeRANK    V0039JobDescMsgMemoryBindingType = "RANK"
	V0039JobDescMsgMemoryBindingTypeSORT    V0039JobDescMsgMemoryBindingType = "SORT"
	V0039JobDescMsgMemoryBindingTypeVERBOSE V0039JobDescMsgMemoryBindingType = "VERBOSE"
)

// Defines values for V0039JobDescMsgOpenMode.
const (
	V0039JobDescMsgOpenModeAPPEND   V0039JobDescMsgOpenMode = "APPEND"
	V0039JobDescMsgOpenModeTRUNCATE V0039JobDescMsgOpenMode = "TRUNCATE"
)

// Defines values for V0039JobDescMsgPowerFlags.
const (
	V0039JobDescMsgPowerFlagsEQUALPOWER V0039JobDescMsgPowerFlags = "EQUAL_POWER"
)

// Defines values for V0039JobDescMsgProfile.
const (
	V0039JobDescMsgProfileENERGY  V0039JobDescMsgProfile = "ENERGY"
	V0039JobDescMsgProfileLUSTRE  V0039JobDescMsgProfile = "LUSTRE"
	V0039JobDescMsgProfileNETWORK V0039JobDescMsgProfile = "NETWORK"
	V0039JobDescMsgProfileNONE    V0039JobDescMsgProfile = "NONE"
	V0039JobDescMsgProfileNOTSET  V0039JobDescMsgProfile = "NOT_SET"
	V0039JobDescMsgProfileTASK    V0039JobDescMsgProfile = "TASK"
)

// Defines values for V0039JobDescMsgShared.
const (
	V0039JobDescMsgSharedMcs           V0039JobDescMsgShared = "mcs"
	V0039JobDescMsgSharedNone          V0039JobDescMsgShared = "none"
	V0039JobDescMsgSharedOversubscribe V0039JobDescMsgShared = "oversubscribe"
	V0039JobDescMsgSharedUser          V0039JobDescMsgShared = "user"
)

// Defines values for V0039JobDescMsgX11.
const (
	V0039JobDescMsgX11BATCHNODE       V0039JobDescMsgX11 = "BATCH_NODE"
	V0039JobDescMsgX11FIRSTNODE       V0039JobDescMsgX11 = "FIRST_NODE"
	V0039JobDescMsgX11FORWARDALLNODES V0039JobDescMsgX11 = "FORWARD_ALL_NODES"
	V0039JobDescMsgX11LASTNODE        V0039JobDescMsgX11 = "LAST_NODE"
)

// Defines values for V0039JobInfoFlags.
const (
	V0039JobInfoFlagsACCRUECOUNTCLEARED       V0039JobInfoFlags = "ACCRUE_COUNT_CLEARED"
	V0039JobInfoFlagsBACKFILLATTEMPTED        V0039JobInfoFlags = "BACKFILL_ATTEMPTED"
	V0039JobInfoFlagsCRONJOB                  V0039JobInfoFlags = "CRON_JOB"
	V0039JobInfoFlagsDEPENDENT                V0039JobInfoFlags = "DEPENDENT"
	V0039JobInfoFlagsEXACTCPUCOUNTREQUESTED   V0039JobInfoFlags = "EXACT_CPU_COUNT_REQUESTED"
	V0039JobInfoFlagsEXACTMEMORYREQUESTED     V0039JobInfoFlags = "EXACT_MEMORY_REQUESTED"
	V0039JobInfoFlagsEXACTTASKCOUNTREQUESTED  V0039JobInfoFlags = "EXACT_TASK_COUNT_REQUESTED"
	V0039JobInfoFlagsGREDBINDINGDISABLED      V0039JobInfoFlags = "GRED_BINDING_DISABLED"
	V0039JobInfoFlagsGRESBINDINGENFORCED      V0039JobInfoFlags = "GRES_BINDING_ENFORCED"
	V0039JobInfoFlagsHASSTATEDIRECTORY        V0039JobInfoFlags = "HAS_STATE_DIRECTORY"
	V0039JobInfoFlagsHETEROGENEOUSJOB         V0039JobInfoFlags = "HETEROGENEOUS_JOB"
	V0039JobInfoFlagsJOBACCRUETIMERESET       V0039JobInfoFlags = "JOB_ACCRUE_TIME_RESET"
	V0039JobInfoFlagsJOBKILLHURRY             V0039JobInfoFlags = "JOB_KILL_HURRY"
	V0039JobInfoFlagsJOBWASRUNNING            V0039JobInfoFlags = "JOB_WAS_RUNNING"
	V0039JobInfoFlagsKILLINVALIDDEPENDENCY    V0039JobInfoFlags = "KILL_INVALID_DEPENDENCY"
	V0039JobInfoFlagsMAGNETIC                 V0039JobInfoFlags = "MAGNETIC"
	V0039JobInfoFlagsNOKILLINVALIDDEPENDENCY  V0039JobInfoFlags = "NO_KILL_INVALID_DEPENDENCY"
	V0039JobInfoFlagsPARTITIONASSIGNED        V0039JobInfoFlags = "PARTITION_ASSIGNED"
	V0039JobInfoFlagsPREFERMINIMUMNODECOUNT   V0039JobInfoFlags = "PREFER_MINIMUM_NODE_COUNT"
	V0039JobInfoFlagsSAVEBATCHSCRIPT          V0039JobInfoFlags = "SAVE_BATCH_SCRIPT"
	V0039JobInfoFlagsSCHEDULINGATTEMPTED      V0039JobInfoFlags = "SCHEDULING_ATTEMPTED"
	V0039JobInfoFlagsSENDJOBENVIRONMENT       V0039JobInfoFlags = "SEND_JOB_ENVIRONMENT"
	V0039JobInfoFlagsSIBLINGCLUSTERUPDATEONLY V0039JobInfoFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	V0039JobInfoFlagsSKIPTRESSTRINGACCOUNTING V0039JobInfoFlags = "SKIP_TRES_STRING_ACCOUNTING"
	V0039JobInfoFlagsSPREADJOB                V0039JobInfoFlags = "SPREAD_JOB"
	V0039JobInfoFlagsTESTINGBACKFILL          V0039JobInfoFlags = "TESTING_BACKFILL"
	V0039JobInfoFlagsTESTINGWHOLENODEBACKFILL V0039JobInfoFlags = "TESTING_WHOLE_NODE_BACKFILL"
	V0039JobInfoFlagsTESTNOWONLY              V0039JobInfoFlags = "TEST_NOW_ONLY"
	V0039JobInfoFlagsTOPPRIORITYJOB           V0039JobInfoFlags = "TOP_PRIORITY_JOB"
	V0039JobInfoFlagsUSINGDEFAULTACCOUNT      V0039JobInfoFlags = "USING_DEFAULT_ACCOUNT"
	V0039JobInfoFlagsUSINGDEFAULTPARTITION    V0039JobInfoFlags = "USING_DEFAULT_PARTITION"
	V0039JobInfoFlagsUSINGDEFAULTQOS          V0039JobInfoFlags = "USING_DEFAULT_QOS"
	V0039JobInfoFlagsUSINGDEFAULTWCKEY        V0039JobInfoFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for V0039JobInfoMailType.
const (
	V0039JobInfoMailTypeARRAYTASKS        V0039JobInfoMailType = "ARRAY_TASKS"
	V0039JobInfoMailTypeBEGIN             V0039JobInfoMailType = "BEGIN"
	V0039JobInfoMailTypeEND               V0039JobInfoMailType = "END"
	V0039JobInfoMailTypeFAIL              V0039JobInfoMailType = "FAIL"
	V0039JobInfoMailTypeINVALIDDEPENDENCY V0039JobInfoMailType = "INVALID_DEPENDENCY"
	V0039JobInfoMailTypeREQUEUE           V0039JobInfoMailType = "REQUEUE"
	V0039JobInfoMailTypeSTAGEOUT          V0039JobInfoMailType = "STAGE_OUT"
	V0039JobInfoMailTypeTIME100           V0039JobInfoMailType = "TIME=100%"
	V0039JobInfoMailTypeTIME50            V0039JobInfoMailType = "TIME=50%"
	V0039JobInfoMailTypeTIME80            V0039JobInfoMailType = "TIME=80%"
	V0039JobInfoMailTypeTIME90            V0039JobInfoMailType = "TIME=90%"
)

// Defines values for V0039JobInfoPowerFlags.
const (
	V0039JobInfoPowerFlagsEQUALPOWER V0039JobInfoPowerFlags = "EQUAL_POWER"
)

// Defines values for V0039JobInfoProfile.
const (
	V0039JobInfoProfileENERGY  V0039JobInfoProfile = "ENERGY"
	V0039JobInfoProfileLUSTRE  V0039JobInfoProfile = "LUSTRE"
	V0039JobInfoProfileNETWORK V0039JobInfoProfile = "NETWORK"
	V0039JobInfoProfileNONE    V0039JobInfoProfile = "NONE"
	V0039JobInfoProfileNOTSET  V0039JobInfoProfile = "NOT_SET"
	V0039JobInfoProfileTASK    V0039JobInfoProfile = "TASK"
)

// Defines values for V0039JobInfoShared.
const (
	V0039JobInfoSharedMcs           V0039JobInfoShared = "mcs"
	V0039JobInfoSharedNone          V0039JobInfoShared = "none"
	V0039JobInfoSharedOversubscribe V0039JobInfoShared = "oversubscribe"
	V0039JobInfoSharedUser          V0039JobInfoShared = "user"
)

// Defines values for V0039JobInfoShowFlags.
const (
	V0039JobInfoShowFlagsALL        V0039JobInfoShowFlags = "ALL"
	V0039JobInfoShowFlagsDETAIL     V0039JobInfoShowFlags = "DETAIL"
	V0039JobInfoShowFlagsFEDERATION V0039JobInfoShowFlags = "FEDERATION"
	V0039JobInfoShowFlagsFUTURE     V0039JobInfoShowFlags = "FUTURE"
	V0039JobInfoShowFlagsLOCAL      V0039JobInfoShowFlags = "LOCAL"
	V0039JobInfoShowFlagsMIXED      V0039JobInfoShowFlags = "MIXED"
	V0039JobInfoShowFlagsSIBLING    V0039JobInfoShowFlags = "SIBLING"
)

// Defines values for V0039NodeNextStateAfterReboot.
const (
	V0039NodeNextStateAfterRebootALLOCATED       V0039NodeNextStateAfterReboot = "ALLOCATED"
	V0039NodeNextStateAfterRebootCLOUD           V0039NodeNextStateAfterReboot = "CLOUD"
	V0039NodeNextStateAfterRebootCOMPLETING      V0039NodeNextStateAfterReboot = "COMPLETING"
	V0039NodeNextStateAfterRebootDOWN            V0039NodeNextStateAfterReboot = "DOWN"
	V0039NodeNextStateAfterRebootDRAIN           V0039NodeNextStateAfterReboot = "DRAIN"
	V0039NodeNextStateAfterRebootDYNAMICFUTURE   V0039NodeNextStateAfterReboot = "DYNAMIC_FUTURE"
	V0039NodeNextStateAfterRebootDYNAMICNORM     V0039NodeNextStateAfterReboot = "DYNAMIC_NORM"
	V0039NodeNextStateAfterRebootERROR           V0039NodeNextStateAfterReboot = "ERROR"
	V0039NodeNextStateAfterRebootFAIL            V0039NodeNextStateAfterReboot = "FAIL"
	V0039NodeNextStateAfterRebootFUTURE          V0039NodeNextStateAfterReboot = "FUTURE"
	V0039NodeNextStateAfterRebootIDLE            V0039NodeNextStateAfterReboot = "IDLE"
	V0039NodeNextStateAfterRebootINVALID         V0039NodeNextStateAfterReboot = "INVALID"
	V0039NodeNextStateAfterRebootINVALIDREG      V0039NodeNextStateAfterReboot = "INVALID_REG"
	V0039NodeNextStateAfterRebootMAINTENANCE     V0039NodeNextStateAfterReboot = "MAINTENANCE"
	V0039NodeNextStateAfterRebootMIXED           V0039NodeNextStateAfterReboot = "MIXED"
	V0039NodeNextStateAfterRebootNOTRESPONDING   V0039NodeNextStateAfterReboot = "NOT_RESPONDING"
	V0039NodeNextStateAfterRebootPERFCTRS        V0039NodeNextStateAfterReboot = "PERFCTRS"
	V0039NodeNextStateAfterRebootPLANNED         V0039NodeNextStateAfterReboot = "PLANNED"
	V0039NodeNextStateAfterRebootPOWERDOWN       V0039NodeNextStateAfterReboot = "POWER_DOWN"
	V0039NodeNextStateAfterRebootPOWERDRAIN      V0039NodeNextStateAfterReboot = "POWER_DRAIN"
	V0039NodeNextStateAfterRebootPOWEREDDOWN     V0039NodeNextStateAfterReboot = "POWERED_DOWN"
	V0039NodeNextStateAfterRebootPOWERINGDOWN    V0039NodeNextStateAfterReboot = "POWERING_DOWN"
	V0039NodeNextStateAfterRebootPOWERINGUP      V0039NodeNextStateAfterReboot = "POWERING_UP"
	V0039NodeNextStateAfterRebootPOWERUP         V0039NodeNextStateAfterReboot = "POWER_UP"
	V0039NodeNextStateAfterRebootREBOOTCANCELED  V0039NodeNextStateAfterReboot = "REBOOT_CANCELED"
	V0039NodeNextStateAfterRebootREBOOTISSUED    V0039NodeNextStateAfterReboot = "REBOOT_ISSUED"
	V0039NodeNextStateAfterRebootREBOOTREQUESTED V0039NodeNextStateAfterReboot = "REBOOT_REQUESTED"
	V0039NodeNextStateAfterRebootRESERVED        V0039NodeNextStateAfterReboot = "RESERVED"
	V0039NodeNextStateAfterRebootRESUME          V0039NodeNextStateAfterReboot = "RESUME"
	V0039NodeNextStateAfterRebootUNDRAIN         V0039NodeNextStateAfterReboot = "UNDRAIN"
	V0039NodeNextStateAfterRebootUNKNOWN         V0039NodeNextStateAfterReboot = "UNKNOWN"
)

// Defines values for V0039NodeState.
const (
	V0039NodeStateALLOCATED       V0039NodeState = "ALLOCATED"
	V0039NodeStateCLOUD           V0039NodeState = "CLOUD"
	V0039NodeStateCOMPLETING      V0039NodeState = "COMPLETING"
	V0039NodeStateDOWN            V0039NodeState = "DOWN"
	V0039NodeStateDRAIN           V0039NodeState = "DRAIN"
	V0039NodeStateDYNAMICFUTURE   V0039NodeState = "DYNAMIC_FUTURE"
	V0039NodeStateDYNAMICNORM     V0039NodeState = "DYNAMIC_NORM"
	V0039NodeStateERROR           V0039NodeState = "ERROR"
	V0039NodeStateFAIL            V0039NodeState = "FAIL"
	V0039NodeStateFUTURE          V0039NodeState = "FUTURE"
	V0039NodeStateIDLE            V0039NodeState = "IDLE"
	V0039NodeStateINVALID         V0039NodeState = "INVALID"
	V0039NodeStateINVALIDREG      V0039NodeState = "INVALID_REG"
	V0039NodeStateMAINTENANCE     V0039NodeState = "MAINTENANCE"
	V0039NodeStateMIXED           V0039NodeState = "MIXED"
	V0039NodeStateNOTRESPONDING   V0039NodeState = "NOT_RESPONDING"
	V0039NodeStatePERFCTRS        V0039NodeState = "PERFCTRS"
	V0039NodeStatePLANNED         V0039NodeState = "PLANNED"
	V0039NodeStatePOWERDOWN       V0039NodeState = "POWER_DOWN"
	V0039NodeStatePOWERDRAIN      V0039NodeState = "POWER_DRAIN"
	V0039NodeStatePOWEREDDOWN     V0039NodeState = "POWERED_DOWN"
	V0039NodeStatePOWERINGDOWN    V0039NodeState = "POWERING_DOWN"
	V0039NodeStatePOWERINGUP      V0039NodeState = "POWERING_UP"
	V0039NodeStatePOWERUP         V0039NodeState = "POWER_UP"
	V0039NodeStateREBOOTCANCELED  V0039NodeState = "REBOOT_CANCELED"
	V0039NodeStateREBOOTISSUED    V0039NodeState = "REBOOT_ISSUED"
	V0039NodeStateREBOOTREQUESTED V0039NodeState = "REBOOT_REQUESTED"
	V0039NodeStateRESERVED        V0039NodeState = "RESERVED"
	V0039NodeStateRESUME          V0039NodeState = "RESUME"
	V0039NodeStateUNDRAIN         V0039NodeState = "UNDRAIN"
	V0039NodeStateUNKNOWN         V0039NodeState = "UNKNOWN"
)

// Defines values for V0039ReservationInfoFlags.
const (
	V0039ReservationInfoFlagsALLNODES           V0039ReservationInfoFlags = "ALL_NODES"
	V0039ReservationInfoFlagsANYNODES           V0039ReservationInfoFlags = "ANY_NODES"
	V0039ReservationInfoFlagsDAILY              V0039ReservationInfoFlags = "DAILY"
	V0039ReservationInfoFlagsDURATIONMINUS      V0039ReservationInfoFlags = "DURATION_MINUS"
	V0039ReservationInfoFlagsDURATIONPLUS       V0039ReservationInfoFlags = "DURATION_PLUS"
	V0039ReservationInfoFlagsFLEX               V0039ReservationInfoFlags = "FLEX"
	V0039ReservationInfoFlagsHOURLY             V0039ReservationInfoFlags = "HOURLY"
	V0039ReservationInfoFlagsIGNOREJOBS         V0039ReservationInfoFlags = "IGNORE_JOBS"
	V0039ReservationInfoFlagsMAGNETIC           V0039ReservationInfoFlags = "MAGNETIC"
	V0039ReservationInfoFlagsMAINT              V0039ReservationInfoFlags = "MAINT"
	V0039ReservationInfoFlagsNODAILY            V0039ReservationInfoFlags = "NO_DAILY"
	V0039ReservationInfoFlagsNOFLEX             V0039ReservationInfoFlags = "NO_FLEX"
	V0039ReservationInfoFlagsNOHOLDJOBSAFTEREND V0039ReservationInfoFlags = "NO_HOLD_JOBS_AFTER_END"
	V0039ReservationInfoFlagsNOHOURLY           V0039ReservationInfoFlags = "NO_HOURLY"
	V0039ReservationInfoFlagsNOIGNOREJOBS       V0039ReservationInfoFlags = "NO_IGNORE_JOBS"
	V0039ReservationInfoFlagsNOMAINT            V0039ReservationInfoFlags = "NO_MAINT"
	V0039ReservationInfoFlagsNOPARTNODES        V0039ReservationInfoFlags = "NO_PART_NODES"
	V0039ReservationInfoFlagsNOPURGECOMP        V0039ReservationInfoFlags = "NO_PURGE_COMP"
	V0039ReservationInfoFlagsNOSTATIC           V0039ReservationInfoFlags = "NO_STATIC"
	V0039ReservationInfoFlagsNOWEEKDAY          V0039ReservationInfoFlags = "NO_WEEKDAY"
	V0039ReservationInfoFlagsNOWEEKEND          V0039ReservationInfoFlags = "NO_WEEKEND"
	V0039ReservationInfoFlagsNOWEEKLY           V0039ReservationInfoFlags = "NO_WEEKLY"
	V0039ReservationInfoFlagsOVERLAP            V0039ReservationInfoFlags = "OVERLAP"
	V0039ReservationInfoFlagsPARTNODES          V0039ReservationInfoFlags = "PART_NODES"
	V0039ReservationInfoFlagsPURGECOMP          V0039ReservationInfoFlags = "PURGE_COMP"
	V0039ReservationInfoFlagsREOCCURRING        V0039ReservationInfoFlags = "REOCCURRING"
	V0039ReservationInfoFlagsREPLACE            V0039ReservationInfoFlags = "REPLACE"
	V0039ReservationInfoFlagsSKIP               V0039ReservationInfoFlags = "SKIP"
	V0039ReservationInfoFlagsSPECNODES          V0039ReservationInfoFlags = "SPEC_NODES"
	V0039ReservationInfoFlagsSTATIC             V0039ReservationInfoFlags = "STATIC"
	V0039ReservationInfoFlagsTIMEFLOAT          V0039ReservationInfoFlags = "TIME_FLOAT"
	V0039ReservationInfoFlagsWEEKDAY            V0039ReservationInfoFlags = "WEEKDAY"
	V0039ReservationInfoFlagsWEEKEND            V0039ReservationInfoFlags = "WEEKEND"
	V0039ReservationInfoFlagsWEEKLY             V0039ReservationInfoFlags = "WEEKLY"
)

// Defines values for V0039UpdateNodeMsgState.
const (
	V0039UpdateNodeMsgStateALLOCATED       V0039UpdateNodeMsgState = "ALLOCATED"
	V0039UpdateNodeMsgStateCLOUD           V0039UpdateNodeMsgState = "CLOUD"
	V0039UpdateNodeMsgStateCOMPLETING      V0039UpdateNodeMsgState = "COMPLETING"
	V0039UpdateNodeMsgStateDOWN            V0039UpdateNodeMsgState = "DOWN"
	V0039UpdateNodeMsgStateDRAIN           V0039UpdateNodeMsgState = "DRAIN"
	V0039UpdateNodeMsgStateDYNAMICFUTURE   V0039UpdateNodeMsgState = "DYNAMIC_FUTURE"
	V0039UpdateNodeMsgStateDYNAMICNORM     V0039UpdateNodeMsgState = "DYNAMIC_NORM"
	V0039UpdateNodeMsgStateERROR           V0039UpdateNodeMsgState = "ERROR"
	V0039UpdateNodeMsgStateFAIL            V0039UpdateNodeMsgState = "FAIL"
	V0039UpdateNodeMsgStateFUTURE          V0039UpdateNodeMsgState = "FUTURE"
	V0039UpdateNodeMsgStateIDLE            V0039UpdateNodeMsgState = "IDLE"
	V0039UpdateNodeMsgStateINVALID         V0039UpdateNodeMsgState = "INVALID"
	V0039UpdateNodeMsgStateINVALIDREG      V0039UpdateNodeMsgState = "INVALID_REG"
	V0039UpdateNodeMsgStateMAINTENANCE     V0039UpdateNodeMsgState = "MAINTENANCE"
	V0039UpdateNodeMsgStateMIXED           V0039UpdateNodeMsgState = "MIXED"
	V0039UpdateNodeMsgStateNOTRESPONDING   V0039UpdateNodeMsgState = "NOT_RESPONDING"
	V0039UpdateNodeMsgStatePERFCTRS        V0039UpdateNodeMsgState = "PERFCTRS"
	V0039UpdateNodeMsgStatePLANNED         V0039UpdateNodeMsgState = "PLANNED"
	V0039UpdateNodeMsgStatePOWERDOWN       V0039UpdateNodeMsgState = "POWER_DOWN"
	V0039UpdateNodeMsgStatePOWERDRAIN      V0039UpdateNodeMsgState = "POWER_DRAIN"
	V0039UpdateNodeMsgStatePOWEREDDOWN     V0039UpdateNodeMsgState = "POWERED_DOWN"
	V0039UpdateNodeMsgStatePOWERINGDOWN    V0039UpdateNodeMsgState = "POWERING_DOWN"
	V0039UpdateNodeMsgStatePOWERINGUP      V0039UpdateNodeMsgState = "POWERING_UP"
	V0039UpdateNodeMsgStatePOWERUP         V0039UpdateNodeMsgState = "POWER_UP"
	V0039UpdateNodeMsgStateREBOOTCANCELED  V0039UpdateNodeMsgState = "REBOOT_CANCELED"
	V0039UpdateNodeMsgStateREBOOTISSUED    V0039UpdateNodeMsgState = "REBOOT_ISSUED"
	V0039UpdateNodeMsgStateREBOOTREQUESTED V0039UpdateNodeMsgState = "REBOOT_REQUESTED"
	V0039UpdateNodeMsgStateRESERVED        V0039UpdateNodeMsgState = "RESERVED"
	V0039UpdateNodeMsgStateRESUME          V0039UpdateNodeMsgState = "RESUME"
	V0039UpdateNodeMsgStateUNDRAIN         V0039UpdateNodeMsgState = "UNDRAIN"
	V0039UpdateNodeMsgStateUNKNOWN         V0039UpdateNodeMsgState = "UNKNOWN"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags.
const (
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUAUTOBINDTOCORES      SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_AUTO_BIND_TO_CORES"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUAUTOBINDTOSOCKETS    SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_AUTO_BIND_TO_SOCKETS"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUAUTOBINDTOTHREADS    SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_AUTO_BIND_TO_THREADS"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDLDMAP            SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDLDMASK           SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDLDRANK           SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDMAP              SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDMASK             SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDNONE             SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDOFF              SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_OFF"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDRANK             SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDTOCORES          SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsSLURMDOFFSPEC           SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "SLURMD_OFF_SPEC"
	SlurmV0039SubmitJobJSONBodyJobCpuBindingFlagsVERBOSE                 SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobCrontabFlags.
const (
	SlurmV0039SubmitJobJSONBodyJobCrontabFlagsWILDDAYOFMONTH SlurmV0039SubmitJobJSONBodyJobCrontabFlags = "WILD_DAY_OF_MONTH"
	SlurmV0039SubmitJobJSONBodyJobCrontabFlagsWILDDAYOFWEEK  SlurmV0039SubmitJobJSONBodyJobCrontabFlags = "WILD_DAY_OF_WEEK"
	SlurmV0039SubmitJobJSONBodyJobCrontabFlagsWILDHOUR       SlurmV0039SubmitJobJSONBodyJobCrontabFlags = "WILD_HOUR"
	SlurmV0039SubmitJobJSONBodyJobCrontabFlagsWILDMINUTE     SlurmV0039SubmitJobJSONBodyJobCrontabFlags = "WILD_MINUTE"
	SlurmV0039SubmitJobJSONBodyJobCrontabFlagsWILDMONTH      SlurmV0039SubmitJobJSONBodyJobCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobExclusive.
const (
	SlurmV0039SubmitJobJSONBodyJobExclusiveFalse SlurmV0039SubmitJobJSONBodyJobExclusive = "false"
	SlurmV0039SubmitJobJSONBodyJobExclusiveMcs   SlurmV0039SubmitJobJSONBodyJobExclusive = "mcs"
	SlurmV0039SubmitJobJSONBodyJobExclusiveTrue  SlurmV0039SubmitJobJSONBodyJobExclusive = "true"
	SlurmV0039SubmitJobJSONBodyJobExclusiveUser  SlurmV0039SubmitJobJSONBodyJobExclusive = "user"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobFlags.
const (
	SlurmV0039SubmitJobJSONBodyJobFlagsACCRUECOUNTCLEARED       SlurmV0039SubmitJobJSONBodyJobFlags = "ACCRUE_COUNT_CLEARED"
	SlurmV0039SubmitJobJSONBodyJobFlagsBACKFILLATTEMPTED        SlurmV0039SubmitJobJSONBodyJobFlags = "BACKFILL_ATTEMPTED"
	SlurmV0039SubmitJobJSONBodyJobFlagsCRONJOB                  SlurmV0039SubmitJobJSONBodyJobFlags = "CRON_JOB"
	SlurmV0039SubmitJobJSONBodyJobFlagsDEPENDENT                SlurmV0039SubmitJobJSONBodyJobFlags = "DEPENDENT"
	SlurmV0039SubmitJobJSONBodyJobFlagsEXACTCPUCOUNTREQUESTED   SlurmV0039SubmitJobJSONBodyJobFlags = "EXACT_CPU_COUNT_REQUESTED"
	SlurmV0039SubmitJobJSONBodyJobFlagsEXACTMEMORYREQUESTED     SlurmV0039SubmitJobJSONBodyJobFlags = "EXACT_MEMORY_REQUESTED"
	SlurmV0039SubmitJobJSONBodyJobFlagsEXACTTASKCOUNTREQUESTED  SlurmV0039SubmitJobJSONBodyJobFlags = "EXACT_TASK_COUNT_REQUESTED"
	SlurmV0039SubmitJobJSONBodyJobFlagsGREDBINDINGDISABLED      SlurmV0039SubmitJobJSONBodyJobFlags = "GRED_BINDING_DISABLED"
	SlurmV0039SubmitJobJSONBodyJobFlagsGRESBINDINGENFORCED      SlurmV0039SubmitJobJSONBodyJobFlags = "GRES_BINDING_ENFORCED"
	SlurmV0039SubmitJobJSONBodyJobFlagsHASSTATEDIRECTORY        SlurmV0039SubmitJobJSONBodyJobFlags = "HAS_STATE_DIRECTORY"
	SlurmV0039SubmitJobJSONBodyJobFlagsHETEROGENEOUSJOB         SlurmV0039SubmitJobJSONBodyJobFlags = "HETEROGENEOUS_JOB"
	SlurmV0039SubmitJobJSONBodyJobFlagsJOBACCRUETIMERESET       SlurmV0039SubmitJobJSONBodyJobFlags = "JOB_ACCRUE_TIME_RESET"
	SlurmV0039SubmitJobJSONBodyJobFlagsJOBKILLHURRY             SlurmV0039SubmitJobJSONBodyJobFlags = "JOB_KILL_HURRY"
	SlurmV0039SubmitJobJSONBodyJobFlagsJOBWASRUNNING            SlurmV0039SubmitJobJSONBodyJobFlags = "JOB_WAS_RUNNING"
	SlurmV0039SubmitJobJSONBodyJobFlagsKILLINVALIDDEPENDENCY    SlurmV0039SubmitJobJSONBodyJobFlags = "KILL_INVALID_DEPENDENCY"
	SlurmV0039SubmitJobJSONBodyJobFlagsMAGNETIC                 SlurmV0039SubmitJobJSONBodyJobFlags = "MAGNETIC"
	SlurmV0039SubmitJobJSONBodyJobFlagsNOKILLINVALIDDEPENDENCY  SlurmV0039SubmitJobJSONBodyJobFlags = "NO_KILL_INVALID_DEPENDENCY"
	SlurmV0039SubmitJobJSONBodyJobFlagsPARTITIONASSIGNED        SlurmV0039SubmitJobJSONBodyJobFlags = "PARTITION_ASSIGNED"
	SlurmV0039SubmitJobJSONBodyJobFlagsPREFERMINIMUMNODECOUNT   SlurmV0039SubmitJobJSONBodyJobFlags = "PREFER_MINIMUM_NODE_COUNT"
	SlurmV0039SubmitJobJSONBodyJobFlagsSAVEBATCHSCRIPT          SlurmV0039SubmitJobJSONBodyJobFlags = "SAVE_BATCH_SCRIPT"
	SlurmV0039SubmitJobJSONBodyJobFlagsSCHEDULINGATTEMPTED      SlurmV0039SubmitJobJSONBodyJobFlags = "SCHEDULING_ATTEMPTED"
	SlurmV0039SubmitJobJSONBodyJobFlagsSENDJOBENVIRONMENT       SlurmV0039SubmitJobJSONBodyJobFlags = "SEND_JOB_ENVIRONMENT"
	SlurmV0039SubmitJobJSONBodyJobFlagsSIBLINGCLUSTERUPDATEONLY SlurmV0039SubmitJobJSONBodyJobFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SlurmV0039SubmitJobJSONBodyJobFlagsSKIPTRESSTRINGACCOUNTING SlurmV0039SubmitJobJSONBodyJobFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SlurmV0039SubmitJobJSONBodyJobFlagsSPREADJOB                SlurmV0039SubmitJobJSONBodyJobFlags = "SPREAD_JOB"
	SlurmV0039SubmitJobJSONBodyJobFlagsTESTINGBACKFILL          SlurmV0039SubmitJobJSONBodyJobFlags = "TESTING_BACKFILL"
	SlurmV0039SubmitJobJSONBodyJobFlagsTESTINGWHOLENODEBACKFILL SlurmV0039SubmitJobJSONBodyJobFlags = "TESTING_WHOLE_NODE_BACKFILL"
	SlurmV0039SubmitJobJSONBodyJobFlagsTESTNOWONLY              SlurmV0039SubmitJobJSONBodyJobFlags = "TEST_NOW_ONLY"
	SlurmV0039SubmitJobJSONBodyJobFlagsTOPPRIORITYJOB           SlurmV0039SubmitJobJSONBodyJobFlags = "TOP_PRIORITY_JOB"
	SlurmV0039SubmitJobJSONBodyJobFlagsUSINGDEFAULTACCOUNT      SlurmV0039SubmitJobJSONBodyJobFlags = "USING_DEFAULT_ACCOUNT"
	SlurmV0039SubmitJobJSONBodyJobFlagsUSINGDEFAULTPARTITION    SlurmV0039SubmitJobJSONBodyJobFlags = "USING_DEFAULT_PARTITION"
	SlurmV0039SubmitJobJSONBodyJobFlagsUSINGDEFAULTQOS          SlurmV0039SubmitJobJSONBodyJobFlags = "USING_DEFAULT_QOS"
	SlurmV0039SubmitJobJSONBodyJobFlagsUSINGDEFAULTWCKEY        SlurmV0039SubmitJobJSONBodyJobFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobKillWarningFlags.
const (
	SlurmV0039SubmitJobJSONBodyJobKillWarningFlagsARRAYTASK         SlurmV0039SubmitJobJSONBodyJobKillWarningFlags = "ARRAY_TASK"
	SlurmV0039SubmitJobJSONBodyJobKillWarningFlagsBATCHJOB          SlurmV0039SubmitJobJSONBodyJobKillWarningFlags = "BATCH_JOB"
	SlurmV0039SubmitJobJSONBodyJobKillWarningFlagsFEDERATIONREQUEUE SlurmV0039SubmitJobJSONBodyJobKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0039SubmitJobJSONBodyJobKillWarningFlagsFULLJOB           SlurmV0039SubmitJobJSONBodyJobKillWarningFlags = "FULL_JOB"
	SlurmV0039SubmitJobJSONBodyJobKillWarningFlagsFULLSTEPSONLY     SlurmV0039SubmitJobJSONBodyJobKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0039SubmitJobJSONBodyJobKillWarningFlagsHURRY             SlurmV0039SubmitJobJSONBodyJobKillWarningFlags = "HURRY"
	SlurmV0039SubmitJobJSONBodyJobKillWarningFlagsNOSIBLINGJOBS     SlurmV0039SubmitJobJSONBodyJobKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0039SubmitJobJSONBodyJobKillWarningFlagsOUTOFMEMORY       SlurmV0039SubmitJobJSONBodyJobKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0039SubmitJobJSONBodyJobKillWarningFlagsRESERVATIONJOB    SlurmV0039SubmitJobJSONBodyJobKillWarningFlags = "RESERVATION_JOB"
	SlurmV0039SubmitJobJSONBodyJobKillWarningFlagsWARNINGSENT       SlurmV0039SubmitJobJSONBodyJobKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobMailType.
const (
	SlurmV0039SubmitJobJSONBodyJobMailTypeARRAYTASKS        SlurmV0039SubmitJobJSONBodyJobMailType = "ARRAY_TASKS"
	SlurmV0039SubmitJobJSONBodyJobMailTypeBEGIN             SlurmV0039SubmitJobJSONBodyJobMailType = "BEGIN"
	SlurmV0039SubmitJobJSONBodyJobMailTypeEND               SlurmV0039SubmitJobJSONBodyJobMailType = "END"
	SlurmV0039SubmitJobJSONBodyJobMailTypeFAIL              SlurmV0039SubmitJobJSONBodyJobMailType = "FAIL"
	SlurmV0039SubmitJobJSONBodyJobMailTypeINVALIDDEPENDENCY SlurmV0039SubmitJobJSONBodyJobMailType = "INVALID_DEPENDENCY"
	SlurmV0039SubmitJobJSONBodyJobMailTypeREQUEUE           SlurmV0039SubmitJobJSONBodyJobMailType = "REQUEUE"
	SlurmV0039SubmitJobJSONBodyJobMailTypeSTAGEOUT          SlurmV0039SubmitJobJSONBodyJobMailType = "STAGE_OUT"
	SlurmV0039SubmitJobJSONBodyJobMailTypeTIME100           SlurmV0039SubmitJobJSONBodyJobMailType = "TIME=100%"
	SlurmV0039SubmitJobJSONBodyJobMailTypeTIME50            SlurmV0039SubmitJobJSONBodyJobMailType = "TIME=50%"
	SlurmV0039SubmitJobJSONBodyJobMailTypeTIME80            SlurmV0039SubmitJobJSONBodyJobMailType = "TIME=80%"
	SlurmV0039SubmitJobJSONBodyJobMailTypeTIME90            SlurmV0039SubmitJobJSONBodyJobMailType = "TIME=90%"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobMemoryBindingType.
const (
	SlurmV0039SubmitJobJSONBodyJobMemoryBindingTypeLOCAL   SlurmV0039SubmitJobJSONBodyJobMemoryBindingType = "LOCAL"
	SlurmV0039SubmitJobJSONBodyJobMemoryBindingTypeMAP     SlurmV0039SubmitJobJSONBodyJobMemoryBindingType = "MAP"
	SlurmV0039SubmitJobJSONBodyJobMemoryBindingTypeMASK    SlurmV0039SubmitJobJSONBodyJobMemoryBindingType = "MASK"
	SlurmV0039SubmitJobJSONBodyJobMemoryBindingTypeNONE    SlurmV0039SubmitJobJSONBodyJobMemoryBindingType = "NONE"
	SlurmV0039SubmitJobJSONBodyJobMemoryBindingTypePREFER  SlurmV0039SubmitJobJSONBodyJobMemoryBindingType = "PREFER"
	SlurmV0039SubmitJobJSONBodyJobMemoryBindingTypeRANK    SlurmV0039SubmitJobJSONBodyJobMemoryBindingType = "RANK"
	SlurmV0039SubmitJobJSONBodyJobMemoryBindingTypeSORT    SlurmV0039SubmitJobJSONBodyJobMemoryBindingType = "SORT"
	SlurmV0039SubmitJobJSONBodyJobMemoryBindingTypeVERBOSE SlurmV0039SubmitJobJSONBodyJobMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobOpenMode.
const (
	SlurmV0039SubmitJobJSONBodyJobOpenModeAPPEND   SlurmV0039SubmitJobJSONBodyJobOpenMode = "APPEND"
	SlurmV0039SubmitJobJSONBodyJobOpenModeTRUNCATE SlurmV0039SubmitJobJSONBodyJobOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobPowerFlags.
const (
	SlurmV0039SubmitJobJSONBodyJobPowerFlagsEQUALPOWER SlurmV0039SubmitJobJSONBodyJobPowerFlags = "EQUAL_POWER"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobProfile.
const (
	SlurmV0039SubmitJobJSONBodyJobProfileENERGY  SlurmV0039SubmitJobJSONBodyJobProfile = "ENERGY"
	SlurmV0039SubmitJobJSONBodyJobProfileLUSTRE  SlurmV0039SubmitJobJSONBodyJobProfile = "LUSTRE"
	SlurmV0039SubmitJobJSONBodyJobProfileNETWORK SlurmV0039SubmitJobJSONBodyJobProfile = "NETWORK"
	SlurmV0039SubmitJobJSONBodyJobProfileNONE    SlurmV0039SubmitJobJSONBodyJobProfile = "NONE"
	SlurmV0039SubmitJobJSONBodyJobProfileNOTSET  SlurmV0039SubmitJobJSONBodyJobProfile = "NOT_SET"
	SlurmV0039SubmitJobJSONBodyJobProfileTASK    SlurmV0039SubmitJobJSONBodyJobProfile = "TASK"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobShared.
const (
	SlurmV0039SubmitJobJSONBodyJobSharedMcs           SlurmV0039SubmitJobJSONBodyJobShared = "mcs"
	SlurmV0039SubmitJobJSONBodyJobSharedNone          SlurmV0039SubmitJobJSONBodyJobShared = "none"
	SlurmV0039SubmitJobJSONBodyJobSharedOversubscribe SlurmV0039SubmitJobJSONBodyJobShared = "oversubscribe"
	SlurmV0039SubmitJobJSONBodyJobSharedUser          SlurmV0039SubmitJobJSONBodyJobShared = "user"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobX11.
const (
	SlurmV0039SubmitJobJSONBodyJobX11BATCHNODE       SlurmV0039SubmitJobJSONBodyJobX11 = "BATCH_NODE"
	SlurmV0039SubmitJobJSONBodyJobX11FIRSTNODE       SlurmV0039SubmitJobJSONBodyJobX11 = "FIRST_NODE"
	SlurmV0039SubmitJobJSONBodyJobX11FORWARDALLNODES SlurmV0039SubmitJobJSONBodyJobX11 = "FORWARD_ALL_NODES"
	SlurmV0039SubmitJobJSONBodyJobX11LASTNODE        SlurmV0039SubmitJobJSONBodyJobX11 = "LAST_NODE"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags.
const (
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUAUTOBINDTOCORES      SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_AUTO_BIND_TO_CORES"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUAUTOBINDTOSOCKETS    SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_AUTO_BIND_TO_SOCKETS"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUAUTOBINDTOTHREADS    SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_AUTO_BIND_TO_THREADS"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDLDMAP            SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDLDMASK           SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDLDRANK           SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDMAP              SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDMASK             SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDNONE             SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDOFF              SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_OFF"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDRANK             SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDTOCORES          SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsSLURMDOFFSPEC           SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "SLURMD_OFF_SPEC"
	SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlagsVERBOSE                 SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsCrontabFlags.
const (
	SlurmV0039SubmitJobJSONBodyJobsCrontabFlagsWILDDAYOFMONTH SlurmV0039SubmitJobJSONBodyJobsCrontabFlags = "WILD_DAY_OF_MONTH"
	SlurmV0039SubmitJobJSONBodyJobsCrontabFlagsWILDDAYOFWEEK  SlurmV0039SubmitJobJSONBodyJobsCrontabFlags = "WILD_DAY_OF_WEEK"
	SlurmV0039SubmitJobJSONBodyJobsCrontabFlagsWILDHOUR       SlurmV0039SubmitJobJSONBodyJobsCrontabFlags = "WILD_HOUR"
	SlurmV0039SubmitJobJSONBodyJobsCrontabFlagsWILDMINUTE     SlurmV0039SubmitJobJSONBodyJobsCrontabFlags = "WILD_MINUTE"
	SlurmV0039SubmitJobJSONBodyJobsCrontabFlagsWILDMONTH      SlurmV0039SubmitJobJSONBodyJobsCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsExclusive.
const (
	SlurmV0039SubmitJobJSONBodyJobsExclusiveFalse SlurmV0039SubmitJobJSONBodyJobsExclusive = "false"
	SlurmV0039SubmitJobJSONBodyJobsExclusiveMcs   SlurmV0039SubmitJobJSONBodyJobsExclusive = "mcs"
	SlurmV0039SubmitJobJSONBodyJobsExclusiveTrue  SlurmV0039SubmitJobJSONBodyJobsExclusive = "true"
	SlurmV0039SubmitJobJSONBodyJobsExclusiveUser  SlurmV0039SubmitJobJSONBodyJobsExclusive = "user"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsFlags.
const (
	SlurmV0039SubmitJobJSONBodyJobsFlagsACCRUECOUNTCLEARED       SlurmV0039SubmitJobJSONBodyJobsFlags = "ACCRUE_COUNT_CLEARED"
	SlurmV0039SubmitJobJSONBodyJobsFlagsBACKFILLATTEMPTED        SlurmV0039SubmitJobJSONBodyJobsFlags = "BACKFILL_ATTEMPTED"
	SlurmV0039SubmitJobJSONBodyJobsFlagsCRONJOB                  SlurmV0039SubmitJobJSONBodyJobsFlags = "CRON_JOB"
	SlurmV0039SubmitJobJSONBodyJobsFlagsDEPENDENT                SlurmV0039SubmitJobJSONBodyJobsFlags = "DEPENDENT"
	SlurmV0039SubmitJobJSONBodyJobsFlagsEXACTCPUCOUNTREQUESTED   SlurmV0039SubmitJobJSONBodyJobsFlags = "EXACT_CPU_COUNT_REQUESTED"
	SlurmV0039SubmitJobJSONBodyJobsFlagsEXACTMEMORYREQUESTED     SlurmV0039SubmitJobJSONBodyJobsFlags = "EXACT_MEMORY_REQUESTED"
	SlurmV0039SubmitJobJSONBodyJobsFlagsEXACTTASKCOUNTREQUESTED  SlurmV0039SubmitJobJSONBodyJobsFlags = "EXACT_TASK_COUNT_REQUESTED"
	SlurmV0039SubmitJobJSONBodyJobsFlagsGREDBINDINGDISABLED      SlurmV0039SubmitJobJSONBodyJobsFlags = "GRED_BINDING_DISABLED"
	SlurmV0039SubmitJobJSONBodyJobsFlagsGRESBINDINGENFORCED      SlurmV0039SubmitJobJSONBodyJobsFlags = "GRES_BINDING_ENFORCED"
	SlurmV0039SubmitJobJSONBodyJobsFlagsHASSTATEDIRECTORY        SlurmV0039SubmitJobJSONBodyJobsFlags = "HAS_STATE_DIRECTORY"
	SlurmV0039SubmitJobJSONBodyJobsFlagsHETEROGENEOUSJOB         SlurmV0039SubmitJobJSONBodyJobsFlags = "HETEROGENEOUS_JOB"
	SlurmV0039SubmitJobJSONBodyJobsFlagsJOBACCRUETIMERESET       SlurmV0039SubmitJobJSONBodyJobsFlags = "JOB_ACCRUE_TIME_RESET"
	SlurmV0039SubmitJobJSONBodyJobsFlagsJOBKILLHURRY             SlurmV0039SubmitJobJSONBodyJobsFlags = "JOB_KILL_HURRY"
	SlurmV0039SubmitJobJSONBodyJobsFlagsJOBWASRUNNING            SlurmV0039SubmitJobJSONBodyJobsFlags = "JOB_WAS_RUNNING"
	SlurmV0039SubmitJobJSONBodyJobsFlagsKILLINVALIDDEPENDENCY    SlurmV0039SubmitJobJSONBodyJobsFlags = "KILL_INVALID_DEPENDENCY"
	SlurmV0039SubmitJobJSONBodyJobsFlagsMAGNETIC                 SlurmV0039SubmitJobJSONBodyJobsFlags = "MAGNETIC"
	SlurmV0039SubmitJobJSONBodyJobsFlagsNOKILLINVALIDDEPENDENCY  SlurmV0039SubmitJobJSONBodyJobsFlags = "NO_KILL_INVALID_DEPENDENCY"
	SlurmV0039SubmitJobJSONBodyJobsFlagsPARTITIONASSIGNED        SlurmV0039SubmitJobJSONBodyJobsFlags = "PARTITION_ASSIGNED"
	SlurmV0039SubmitJobJSONBodyJobsFlagsPREFERMINIMUMNODECOUNT   SlurmV0039SubmitJobJSONBodyJobsFlags = "PREFER_MINIMUM_NODE_COUNT"
	SlurmV0039SubmitJobJSONBodyJobsFlagsSAVEBATCHSCRIPT          SlurmV0039SubmitJobJSONBodyJobsFlags = "SAVE_BATCH_SCRIPT"
	SlurmV0039SubmitJobJSONBodyJobsFlagsSCHEDULINGATTEMPTED      SlurmV0039SubmitJobJSONBodyJobsFlags = "SCHEDULING_ATTEMPTED"
	SlurmV0039SubmitJobJSONBodyJobsFlagsSENDJOBENVIRONMENT       SlurmV0039SubmitJobJSONBodyJobsFlags = "SEND_JOB_ENVIRONMENT"
	SlurmV0039SubmitJobJSONBodyJobsFlagsSIBLINGCLUSTERUPDATEONLY SlurmV0039SubmitJobJSONBodyJobsFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SlurmV0039SubmitJobJSONBodyJobsFlagsSKIPTRESSTRINGACCOUNTING SlurmV0039SubmitJobJSONBodyJobsFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SlurmV0039SubmitJobJSONBodyJobsFlagsSPREADJOB                SlurmV0039SubmitJobJSONBodyJobsFlags = "SPREAD_JOB"
	SlurmV0039SubmitJobJSONBodyJobsFlagsTESTINGBACKFILL          SlurmV0039SubmitJobJSONBodyJobsFlags = "TESTING_BACKFILL"
	SlurmV0039SubmitJobJSONBodyJobsFlagsTESTINGWHOLENODEBACKFILL SlurmV0039SubmitJobJSONBodyJobsFlags = "TESTING_WHOLE_NODE_BACKFILL"
	SlurmV0039SubmitJobJSONBodyJobsFlagsTESTNOWONLY              SlurmV0039SubmitJobJSONBodyJobsFlags = "TEST_NOW_ONLY"
	SlurmV0039SubmitJobJSONBodyJobsFlagsTOPPRIORITYJOB           SlurmV0039SubmitJobJSONBodyJobsFlags = "TOP_PRIORITY_JOB"
	SlurmV0039SubmitJobJSONBodyJobsFlagsUSINGDEFAULTACCOUNT      SlurmV0039SubmitJobJSONBodyJobsFlags = "USING_DEFAULT_ACCOUNT"
	SlurmV0039SubmitJobJSONBodyJobsFlagsUSINGDEFAULTPARTITION    SlurmV0039SubmitJobJSONBodyJobsFlags = "USING_DEFAULT_PARTITION"
	SlurmV0039SubmitJobJSONBodyJobsFlagsUSINGDEFAULTQOS          SlurmV0039SubmitJobJSONBodyJobsFlags = "USING_DEFAULT_QOS"
	SlurmV0039SubmitJobJSONBodyJobsFlagsUSINGDEFAULTWCKEY        SlurmV0039SubmitJobJSONBodyJobsFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags.
const (
	SlurmV0039SubmitJobJSONBodyJobsKillWarningFlagsARRAYTASK         SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags = "ARRAY_TASK"
	SlurmV0039SubmitJobJSONBodyJobsKillWarningFlagsBATCHJOB          SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags = "BATCH_JOB"
	SlurmV0039SubmitJobJSONBodyJobsKillWarningFlagsFEDERATIONREQUEUE SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0039SubmitJobJSONBodyJobsKillWarningFlagsFULLJOB           SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags = "FULL_JOB"
	SlurmV0039SubmitJobJSONBodyJobsKillWarningFlagsFULLSTEPSONLY     SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0039SubmitJobJSONBodyJobsKillWarningFlagsHURRY             SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags = "HURRY"
	SlurmV0039SubmitJobJSONBodyJobsKillWarningFlagsNOSIBLINGJOBS     SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0039SubmitJobJSONBodyJobsKillWarningFlagsOUTOFMEMORY       SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0039SubmitJobJSONBodyJobsKillWarningFlagsRESERVATIONJOB    SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags = "RESERVATION_JOB"
	SlurmV0039SubmitJobJSONBodyJobsKillWarningFlagsWARNINGSENT       SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsMailType.
const (
	SlurmV0039SubmitJobJSONBodyJobsMailTypeARRAYTASKS        SlurmV0039SubmitJobJSONBodyJobsMailType = "ARRAY_TASKS"
	SlurmV0039SubmitJobJSONBodyJobsMailTypeBEGIN             SlurmV0039SubmitJobJSONBodyJobsMailType = "BEGIN"
	SlurmV0039SubmitJobJSONBodyJobsMailTypeEND               SlurmV0039SubmitJobJSONBodyJobsMailType = "END"
	SlurmV0039SubmitJobJSONBodyJobsMailTypeFAIL              SlurmV0039SubmitJobJSONBodyJobsMailType = "FAIL"
	SlurmV0039SubmitJobJSONBodyJobsMailTypeINVALIDDEPENDENCY SlurmV0039SubmitJobJSONBodyJobsMailType = "INVALID_DEPENDENCY"
	SlurmV0039SubmitJobJSONBodyJobsMailTypeREQUEUE           SlurmV0039SubmitJobJSONBodyJobsMailType = "REQUEUE"
	SlurmV0039SubmitJobJSONBodyJobsMailTypeSTAGEOUT          SlurmV0039SubmitJobJSONBodyJobsMailType = "STAGE_OUT"
	SlurmV0039SubmitJobJSONBodyJobsMailTypeTIME100           SlurmV0039SubmitJobJSONBodyJobsMailType = "TIME=100%"
	SlurmV0039SubmitJobJSONBodyJobsMailTypeTIME50            SlurmV0039SubmitJobJSONBodyJobsMailType = "TIME=50%"
	SlurmV0039SubmitJobJSONBodyJobsMailTypeTIME80            SlurmV0039SubmitJobJSONBodyJobsMailType = "TIME=80%"
	SlurmV0039SubmitJobJSONBodyJobsMailTypeTIME90            SlurmV0039SubmitJobJSONBodyJobsMailType = "TIME=90%"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType.
const (
	SlurmV0039SubmitJobJSONBodyJobsMemoryBindingTypeLOCAL   SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType = "LOCAL"
	SlurmV0039SubmitJobJSONBodyJobsMemoryBindingTypeMAP     SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType = "MAP"
	SlurmV0039SubmitJobJSONBodyJobsMemoryBindingTypeMASK    SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType = "MASK"
	SlurmV0039SubmitJobJSONBodyJobsMemoryBindingTypeNONE    SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType = "NONE"
	SlurmV0039SubmitJobJSONBodyJobsMemoryBindingTypePREFER  SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType = "PREFER"
	SlurmV0039SubmitJobJSONBodyJobsMemoryBindingTypeRANK    SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType = "RANK"
	SlurmV0039SubmitJobJSONBodyJobsMemoryBindingTypeSORT    SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType = "SORT"
	SlurmV0039SubmitJobJSONBodyJobsMemoryBindingTypeVERBOSE SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsOpenMode.
const (
	SlurmV0039SubmitJobJSONBodyJobsOpenModeAPPEND   SlurmV0039SubmitJobJSONBodyJobsOpenMode = "APPEND"
	SlurmV0039SubmitJobJSONBodyJobsOpenModeTRUNCATE SlurmV0039SubmitJobJSONBodyJobsOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsPowerFlags.
const (
	SlurmV0039SubmitJobJSONBodyJobsPowerFlagsEQUALPOWER SlurmV0039SubmitJobJSONBodyJobsPowerFlags = "EQUAL_POWER"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsProfile.
const (
	SlurmV0039SubmitJobJSONBodyJobsProfileENERGY  SlurmV0039SubmitJobJSONBodyJobsProfile = "ENERGY"
	SlurmV0039SubmitJobJSONBodyJobsProfileLUSTRE  SlurmV0039SubmitJobJSONBodyJobsProfile = "LUSTRE"
	SlurmV0039SubmitJobJSONBodyJobsProfileNETWORK SlurmV0039SubmitJobJSONBodyJobsProfile = "NETWORK"
	SlurmV0039SubmitJobJSONBodyJobsProfileNONE    SlurmV0039SubmitJobJSONBodyJobsProfile = "NONE"
	SlurmV0039SubmitJobJSONBodyJobsProfileNOTSET  SlurmV0039SubmitJobJSONBodyJobsProfile = "NOT_SET"
	SlurmV0039SubmitJobJSONBodyJobsProfileTASK    SlurmV0039SubmitJobJSONBodyJobsProfile = "TASK"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsShared.
const (
	SlurmV0039SubmitJobJSONBodyJobsSharedMcs           SlurmV0039SubmitJobJSONBodyJobsShared = "mcs"
	SlurmV0039SubmitJobJSONBodyJobsSharedNone          SlurmV0039SubmitJobJSONBodyJobsShared = "none"
	SlurmV0039SubmitJobJSONBodyJobsSharedOversubscribe SlurmV0039SubmitJobJSONBodyJobsShared = "oversubscribe"
	SlurmV0039SubmitJobJSONBodyJobsSharedUser          SlurmV0039SubmitJobJSONBodyJobsShared = "user"
)

// Defines values for SlurmV0039SubmitJobJSONBodyJobsX11.
const (
	SlurmV0039SubmitJobJSONBodyJobsX11BATCHNODE       SlurmV0039SubmitJobJSONBodyJobsX11 = "BATCH_NODE"
	SlurmV0039SubmitJobJSONBodyJobsX11FIRSTNODE       SlurmV0039SubmitJobJSONBodyJobsX11 = "FIRST_NODE"
	SlurmV0039SubmitJobJSONBodyJobsX11FORWARDALLNODES SlurmV0039SubmitJobJSONBodyJobsX11 = "FORWARD_ALL_NODES"
	SlurmV0039SubmitJobJSONBodyJobsX11LASTNODE        SlurmV0039SubmitJobJSONBodyJobsX11 = "LAST_NODE"
)

// Defines values for SlurmV0039CancelJobParamsSignal.
const (
	ABRT SlurmV0039CancelJobParamsSignal = "ABRT"
	ALRM SlurmV0039CancelJobParamsSignal = "ALRM"
	CONT SlurmV0039CancelJobParamsSignal = "CONT"
	HUP  SlurmV0039CancelJobParamsSignal = "HUP"
	INT  SlurmV0039CancelJobParamsSignal = "INT"
	KILL SlurmV0039CancelJobParamsSignal = "KILL"
	QUIT SlurmV0039CancelJobParamsSignal = "QUIT"
	STOP SlurmV0039CancelJobParamsSignal = "STOP"
	TERM SlurmV0039CancelJobParamsSignal = "TERM"
	TSTP SlurmV0039CancelJobParamsSignal = "TSTP"
	TTIN SlurmV0039CancelJobParamsSignal = "TTIN"
	TTOU SlurmV0039CancelJobParamsSignal = "TTOU"
	URG  SlurmV0039CancelJobParamsSignal = "URG"
	USR1 SlurmV0039CancelJobParamsSignal = "USR1"
	USR2 SlurmV0039CancelJobParamsSignal = "USR2"
)

// Defines values for SlurmV0039UpdateJobJSONBodyCpuBindingFlags.
const (
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUAUTOBINDTOCORES      SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_AUTO_BIND_TO_CORES"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUAUTOBINDTOSOCKETS    SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_AUTO_BIND_TO_SOCKETS"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUAUTOBINDTOTHREADS    SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_AUTO_BIND_TO_THREADS"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDLDMAP            SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDLDMASK           SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDLDRANK           SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDMAP              SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDMASK             SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDNONE             SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDOFF              SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_OFF"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDRANK             SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDTOCORES          SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsSLURMDOFFSPEC           SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "SLURMD_OFF_SPEC"
	SlurmV0039UpdateJobJSONBodyCpuBindingFlagsVERBOSE                 SlurmV0039UpdateJobJSONBodyCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0039UpdateJobJSONBodyCrontabFlags.
const (
	SlurmV0039UpdateJobJSONBodyCrontabFlagsWILDDAYOFMONTH SlurmV0039UpdateJobJSONBodyCrontabFlags = "WILD_DAY_OF_MONTH"
	SlurmV0039UpdateJobJSONBodyCrontabFlagsWILDDAYOFWEEK  SlurmV0039UpdateJobJSONBodyCrontabFlags = "WILD_DAY_OF_WEEK"
	SlurmV0039UpdateJobJSONBodyCrontabFlagsWILDHOUR       SlurmV0039UpdateJobJSONBodyCrontabFlags = "WILD_HOUR"
	SlurmV0039UpdateJobJSONBodyCrontabFlagsWILDMINUTE     SlurmV0039UpdateJobJSONBodyCrontabFlags = "WILD_MINUTE"
	SlurmV0039UpdateJobJSONBodyCrontabFlagsWILDMONTH      SlurmV0039UpdateJobJSONBodyCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0039UpdateJobJSONBodyExclusive.
const (
	SlurmV0039UpdateJobJSONBodyExclusiveFalse SlurmV0039UpdateJobJSONBodyExclusive = "false"
	SlurmV0039UpdateJobJSONBodyExclusiveMcs   SlurmV0039UpdateJobJSONBodyExclusive = "mcs"
	SlurmV0039UpdateJobJSONBodyExclusiveTrue  SlurmV0039UpdateJobJSONBodyExclusive = "true"
	SlurmV0039UpdateJobJSONBodyExclusiveUser  SlurmV0039UpdateJobJSONBodyExclusive = "user"
)

// Defines values for SlurmV0039UpdateJobJSONBodyFlags.
const (
	SlurmV0039UpdateJobJSONBodyFlagsACCRUECOUNTCLEARED       SlurmV0039UpdateJobJSONBodyFlags = "ACCRUE_COUNT_CLEARED"
	SlurmV0039UpdateJobJSONBodyFlagsBACKFILLATTEMPTED        SlurmV0039UpdateJobJSONBodyFlags = "BACKFILL_ATTEMPTED"
	SlurmV0039UpdateJobJSONBodyFlagsCRONJOB                  SlurmV0039UpdateJobJSONBodyFlags = "CRON_JOB"
	SlurmV0039UpdateJobJSONBodyFlagsDEPENDENT                SlurmV0039UpdateJobJSONBodyFlags = "DEPENDENT"
	SlurmV0039UpdateJobJSONBodyFlagsEXACTCPUCOUNTREQUESTED   SlurmV0039UpdateJobJSONBodyFlags = "EXACT_CPU_COUNT_REQUESTED"
	SlurmV0039UpdateJobJSONBodyFlagsEXACTMEMORYREQUESTED     SlurmV0039UpdateJobJSONBodyFlags = "EXACT_MEMORY_REQUESTED"
	SlurmV0039UpdateJobJSONBodyFlagsEXACTTASKCOUNTREQUESTED  SlurmV0039UpdateJobJSONBodyFlags = "EXACT_TASK_COUNT_REQUESTED"
	SlurmV0039UpdateJobJSONBodyFlagsGREDBINDINGDISABLED      SlurmV0039UpdateJobJSONBodyFlags = "GRED_BINDING_DISABLED"
	SlurmV0039UpdateJobJSONBodyFlagsGRESBINDINGENFORCED      SlurmV0039UpdateJobJSONBodyFlags = "GRES_BINDING_ENFORCED"
	SlurmV0039UpdateJobJSONBodyFlagsHASSTATEDIRECTORY        SlurmV0039UpdateJobJSONBodyFlags = "HAS_STATE_DIRECTORY"
	SlurmV0039UpdateJobJSONBodyFlagsHETEROGENEOUSJOB         SlurmV0039UpdateJobJSONBodyFlags = "HETEROGENEOUS_JOB"
	SlurmV0039UpdateJobJSONBodyFlagsJOBACCRUETIMERESET       SlurmV0039UpdateJobJSONBodyFlags = "JOB_ACCRUE_TIME_RESET"
	SlurmV0039UpdateJobJSONBodyFlagsJOBKILLHURRY             SlurmV0039UpdateJobJSONBodyFlags = "JOB_KILL_HURRY"
	SlurmV0039UpdateJobJSONBodyFlagsJOBWASRUNNING            SlurmV0039UpdateJobJSONBodyFlags = "JOB_WAS_RUNNING"
	SlurmV0039UpdateJobJSONBodyFlagsKILLINVALIDDEPENDENCY    SlurmV0039UpdateJobJSONBodyFlags = "KILL_INVALID_DEPENDENCY"
	SlurmV0039UpdateJobJSONBodyFlagsMAGNETIC                 SlurmV0039UpdateJobJSONBodyFlags = "MAGNETIC"
	SlurmV0039UpdateJobJSONBodyFlagsNOKILLINVALIDDEPENDENCY  SlurmV0039UpdateJobJSONBodyFlags = "NO_KILL_INVALID_DEPENDENCY"
	SlurmV0039UpdateJobJSONBodyFlagsPARTITIONASSIGNED        SlurmV0039UpdateJobJSONBodyFlags = "PARTITION_ASSIGNED"
	SlurmV0039UpdateJobJSONBodyFlagsPREFERMINIMUMNODECOUNT   SlurmV0039UpdateJobJSONBodyFlags = "PREFER_MINIMUM_NODE_COUNT"
	SlurmV0039UpdateJobJSONBodyFlagsSAVEBATCHSCRIPT          SlurmV0039UpdateJobJSONBodyFlags = "SAVE_BATCH_SCRIPT"
	SlurmV0039UpdateJobJSONBodyFlagsSCHEDULINGATTEMPTED      SlurmV0039UpdateJobJSONBodyFlags = "SCHEDULING_ATTEMPTED"
	SlurmV0039UpdateJobJSONBodyFlagsSENDJOBENVIRONMENT       SlurmV0039UpdateJobJSONBodyFlags = "SEND_JOB_ENVIRONMENT"
	SlurmV0039UpdateJobJSONBodyFlagsSIBLINGCLUSTERUPDATEONLY SlurmV0039UpdateJobJSONBodyFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SlurmV0039UpdateJobJSONBodyFlagsSKIPTRESSTRINGACCOUNTING SlurmV0039UpdateJobJSONBodyFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SlurmV0039UpdateJobJSONBodyFlagsSPREADJOB                SlurmV0039UpdateJobJSONBodyFlags = "SPREAD_JOB"
	SlurmV0039UpdateJobJSONBodyFlagsTESTINGBACKFILL          SlurmV0039UpdateJobJSONBodyFlags = "TESTING_BACKFILL"
	SlurmV0039UpdateJobJSONBodyFlagsTESTINGWHOLENODEBACKFILL SlurmV0039UpdateJobJSONBodyFlags = "TESTING_WHOLE_NODE_BACKFILL"
	SlurmV0039UpdateJobJSONBodyFlagsTESTNOWONLY              SlurmV0039UpdateJobJSONBodyFlags = "TEST_NOW_ONLY"
	SlurmV0039UpdateJobJSONBodyFlagsTOPPRIORITYJOB           SlurmV0039UpdateJobJSONBodyFlags = "TOP_PRIORITY_JOB"
	SlurmV0039UpdateJobJSONBodyFlagsUSINGDEFAULTACCOUNT      SlurmV0039UpdateJobJSONBodyFlags = "USING_DEFAULT_ACCOUNT"
	SlurmV0039UpdateJobJSONBodyFlagsUSINGDEFAULTPARTITION    SlurmV0039UpdateJobJSONBodyFlags = "USING_DEFAULT_PARTITION"
	SlurmV0039UpdateJobJSONBodyFlagsUSINGDEFAULTQOS          SlurmV0039UpdateJobJSONBodyFlags = "USING_DEFAULT_QOS"
	SlurmV0039UpdateJobJSONBodyFlagsUSINGDEFAULTWCKEY        SlurmV0039UpdateJobJSONBodyFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0039UpdateJobJSONBodyKillWarningFlags.
const (
	SlurmV0039UpdateJobJSONBodyKillWarningFlagsARRAYTASK         SlurmV0039UpdateJobJSONBodyKillWarningFlags = "ARRAY_TASK"
	SlurmV0039UpdateJobJSONBodyKillWarningFlagsBATCHJOB          SlurmV0039UpdateJobJSONBodyKillWarningFlags = "BATCH_JOB"
	SlurmV0039UpdateJobJSONBodyKillWarningFlagsFEDERATIONREQUEUE SlurmV0039UpdateJobJSONBodyKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0039UpdateJobJSONBodyKillWarningFlagsFULLJOB           SlurmV0039UpdateJobJSONBodyKillWarningFlags = "FULL_JOB"
	SlurmV0039UpdateJobJSONBodyKillWarningFlagsFULLSTEPSONLY     SlurmV0039UpdateJobJSONBodyKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0039UpdateJobJSONBodyKillWarningFlagsHURRY             SlurmV0039UpdateJobJSONBodyKillWarningFlags = "HURRY"
	SlurmV0039UpdateJobJSONBodyKillWarningFlagsNOSIBLINGJOBS     SlurmV0039UpdateJobJSONBodyKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0039UpdateJobJSONBodyKillWarningFlagsOUTOFMEMORY       SlurmV0039UpdateJobJSONBodyKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0039UpdateJobJSONBodyKillWarningFlagsRESERVATIONJOB    SlurmV0039UpdateJobJSONBodyKillWarningFlags = "RESERVATION_JOB"
	SlurmV0039UpdateJobJSONBodyKillWarningFlagsWARNINGSENT       SlurmV0039UpdateJobJSONBodyKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0039UpdateJobJSONBodyMailType.
const (
	SlurmV0039UpdateJobJSONBodyMailTypeARRAYTASKS        SlurmV0039UpdateJobJSONBodyMailType = "ARRAY_TASKS"
	SlurmV0039UpdateJobJSONBodyMailTypeBEGIN             SlurmV0039UpdateJobJSONBodyMailType = "BEGIN"
	SlurmV0039UpdateJobJSONBodyMailTypeEND               SlurmV0039UpdateJobJSONBodyMailType = "END"
	SlurmV0039UpdateJobJSONBodyMailTypeFAIL              SlurmV0039UpdateJobJSONBodyMailType = "FAIL"
	SlurmV0039UpdateJobJSONBodyMailTypeINVALIDDEPENDENCY SlurmV0039UpdateJobJSONBodyMailType = "INVALID_DEPENDENCY"
	SlurmV0039UpdateJobJSONBodyMailTypeREQUEUE           SlurmV0039UpdateJobJSONBodyMailType = "REQUEUE"
	SlurmV0039UpdateJobJSONBodyMailTypeSTAGEOUT          SlurmV0039UpdateJobJSONBodyMailType = "STAGE_OUT"
	SlurmV0039UpdateJobJSONBodyMailTypeTIME100           SlurmV0039UpdateJobJSONBodyMailType = "TIME=100%"
	SlurmV0039UpdateJobJSONBodyMailTypeTIME50            SlurmV0039UpdateJobJSONBodyMailType = "TIME=50%"
	SlurmV0039UpdateJobJSONBodyMailTypeTIME80            SlurmV0039UpdateJobJSONBodyMailType = "TIME=80%"
	SlurmV0039UpdateJobJSONBodyMailTypeTIME90            SlurmV0039UpdateJobJSONBodyMailType = "TIME=90%"
)

// Defines values for SlurmV0039UpdateJobJSONBodyMemoryBindingType.
const (
	SlurmV0039UpdateJobJSONBodyMemoryBindingTypeLOCAL   SlurmV0039UpdateJobJSONBodyMemoryBindingType = "LOCAL"
	SlurmV0039UpdateJobJSONBodyMemoryBindingTypeMAP     SlurmV0039UpdateJobJSONBodyMemoryBindingType = "MAP"
	SlurmV0039UpdateJobJSONBodyMemoryBindingTypeMASK    SlurmV0039UpdateJobJSONBodyMemoryBindingType = "MASK"
	SlurmV0039UpdateJobJSONBodyMemoryBindingTypeNONE    SlurmV0039UpdateJobJSONBodyMemoryBindingType = "NONE"
	SlurmV0039UpdateJobJSONBodyMemoryBindingTypePREFER  SlurmV0039UpdateJobJSONBodyMemoryBindingType = "PREFER"
	SlurmV0039UpdateJobJSONBodyMemoryBindingTypeRANK    SlurmV0039UpdateJobJSONBodyMemoryBindingType = "RANK"
	SlurmV0039UpdateJobJSONBodyMemoryBindingTypeSORT    SlurmV0039UpdateJobJSONBodyMemoryBindingType = "SORT"
	SlurmV0039UpdateJobJSONBodyMemoryBindingTypeVERBOSE SlurmV0039UpdateJobJSONBodyMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0039UpdateJobJSONBodyOpenMode.
const (
	SlurmV0039UpdateJobJSONBodyOpenModeAPPEND   SlurmV0039UpdateJobJSONBodyOpenMode = "APPEND"
	SlurmV0039UpdateJobJSONBodyOpenModeTRUNCATE SlurmV0039UpdateJobJSONBodyOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0039UpdateJobJSONBodyPowerFlags.
const (
	EQUALPOWER SlurmV0039UpdateJobJSONBodyPowerFlags = "EQUAL_POWER"
)

// Defines values for SlurmV0039UpdateJobJSONBodyProfile.
const (
	ENERGY  SlurmV0039UpdateJobJSONBodyProfile = "ENERGY"
	LUSTRE  SlurmV0039UpdateJobJSONBodyProfile = "LUSTRE"
	NETWORK SlurmV0039UpdateJobJSONBodyProfile = "NETWORK"
	NONE    SlurmV0039UpdateJobJSONBodyProfile = "NONE"
	NOTSET  SlurmV0039UpdateJobJSONBodyProfile = "NOT_SET"
	TASK    SlurmV0039UpdateJobJSONBodyProfile = "TASK"
)

// Defines values for SlurmV0039UpdateJobJSONBodyShared.
const (
	SlurmV0039UpdateJobJSONBodySharedMcs           SlurmV0039UpdateJobJSONBodyShared = "mcs"
	SlurmV0039UpdateJobJSONBodySharedNone          SlurmV0039UpdateJobJSONBodyShared = "none"
	SlurmV0039UpdateJobJSONBodySharedOversubscribe SlurmV0039UpdateJobJSONBodyShared = "oversubscribe"
	SlurmV0039UpdateJobJSONBodySharedUser          SlurmV0039UpdateJobJSONBodyShared = "user"
)

// Defines values for SlurmV0039UpdateJobJSONBodyX11.
const (
	SlurmV0039UpdateJobJSONBodyX11BATCHNODE       SlurmV0039UpdateJobJSONBodyX11 = "BATCH_NODE"
	SlurmV0039UpdateJobJSONBodyX11FIRSTNODE       SlurmV0039UpdateJobJSONBodyX11 = "FIRST_NODE"
	SlurmV0039UpdateJobJSONBodyX11FORWARDALLNODES SlurmV0039UpdateJobJSONBodyX11 = "FORWARD_ALL_NODES"
	SlurmV0039UpdateJobJSONBodyX11LASTNODE        SlurmV0039UpdateJobJSONBodyX11 = "LAST_NODE"
)

// Defines values for SlurmV0039UpdateNodeJSONBodyState.
const (
	SlurmV0039UpdateNodeJSONBodyStateALLOCATED       SlurmV0039UpdateNodeJSONBodyState = "ALLOCATED"
	SlurmV0039UpdateNodeJSONBodyStateCLOUD           SlurmV0039UpdateNodeJSONBodyState = "CLOUD"
	SlurmV0039UpdateNodeJSONBodyStateCOMPLETING      SlurmV0039UpdateNodeJSONBodyState = "COMPLETING"
	SlurmV0039UpdateNodeJSONBodyStateDOWN            SlurmV0039UpdateNodeJSONBodyState = "DOWN"
	SlurmV0039UpdateNodeJSONBodyStateDRAIN           SlurmV0039UpdateNodeJSONBodyState = "DRAIN"
	SlurmV0039UpdateNodeJSONBodyStateDYNAMICFUTURE   SlurmV0039UpdateNodeJSONBodyState = "DYNAMIC_FUTURE"
	SlurmV0039UpdateNodeJSONBodyStateDYNAMICNORM     SlurmV0039UpdateNodeJSONBodyState = "DYNAMIC_NORM"
	SlurmV0039UpdateNodeJSONBodyStateERROR           SlurmV0039UpdateNodeJSONBodyState = "ERROR"
	SlurmV0039UpdateNodeJSONBodyStateFAIL            SlurmV0039UpdateNodeJSONBodyState = "FAIL"
	SlurmV0039UpdateNodeJSONBodyStateFUTURE          SlurmV0039UpdateNodeJSONBodyState = "FUTURE"
	SlurmV0039UpdateNodeJSONBodyStateIDLE            SlurmV0039UpdateNodeJSONBodyState = "IDLE"
	SlurmV0039UpdateNodeJSONBodyStateINVALID         SlurmV0039UpdateNodeJSONBodyState = "INVALID"
	SlurmV0039UpdateNodeJSONBodyStateINVALIDREG      SlurmV0039UpdateNodeJSONBodyState = "INVALID_REG"
	SlurmV0039UpdateNodeJSONBodyStateMAINTENANCE     SlurmV0039UpdateNodeJSONBodyState = "MAINTENANCE"
	SlurmV0039UpdateNodeJSONBodyStateMIXED           SlurmV0039UpdateNodeJSONBodyState = "MIXED"
	SlurmV0039UpdateNodeJSONBodyStateNOTRESPONDING   SlurmV0039UpdateNodeJSONBodyState = "NOT_RESPONDING"
	SlurmV0039UpdateNodeJSONBodyStatePERFCTRS        SlurmV0039UpdateNodeJSONBodyState = "PERFCTRS"
	SlurmV0039UpdateNodeJSONBodyStatePLANNED         SlurmV0039UpdateNodeJSONBodyState = "PLANNED"
	SlurmV0039UpdateNodeJSONBodyStatePOWERDOWN       SlurmV0039UpdateNodeJSONBodyState = "POWER_DOWN"
	SlurmV0039UpdateNodeJSONBodyStatePOWERDRAIN      SlurmV0039UpdateNodeJSONBodyState = "POWER_DRAIN"
	SlurmV0039UpdateNodeJSONBodyStatePOWEREDDOWN     SlurmV0039UpdateNodeJSONBodyState = "POWERED_DOWN"
	SlurmV0039UpdateNodeJSONBodyStatePOWERINGDOWN    SlurmV0039UpdateNodeJSONBodyState = "POWERING_DOWN"
	SlurmV0039UpdateNodeJSONBodyStatePOWERINGUP      SlurmV0039UpdateNodeJSONBodyState = "POWERING_UP"
	SlurmV0039UpdateNodeJSONBodyStatePOWERUP         SlurmV0039UpdateNodeJSONBodyState = "POWER_UP"
	SlurmV0039UpdateNodeJSONBodyStateREBOOTCANCELED  SlurmV0039UpdateNodeJSONBodyState = "REBOOT_CANCELED"
	SlurmV0039UpdateNodeJSONBodyStateREBOOTISSUED    SlurmV0039UpdateNodeJSONBodyState = "REBOOT_ISSUED"
	SlurmV0039UpdateNodeJSONBodyStateREBOOTREQUESTED SlurmV0039UpdateNodeJSONBodyState = "REBOOT_REQUESTED"
	SlurmV0039UpdateNodeJSONBodyStateRESERVED        SlurmV0039UpdateNodeJSONBodyState = "RESERVED"
	SlurmV0039UpdateNodeJSONBodyStateRESUME          SlurmV0039UpdateNodeJSONBodyState = "RESUME"
	SlurmV0039UpdateNodeJSONBodyStateUNDRAIN         SlurmV0039UpdateNodeJSONBodyState = "UNDRAIN"
	SlurmV0039UpdateNodeJSONBodyStateUNKNOWN         SlurmV0039UpdateNodeJSONBodyState = "UNKNOWN"
)

// Status defines model for status.
type Status struct {
	// Errors Slurm errors
	Errors *V0039Errors `json:"errors,omitempty"`
	Meta   *V0039Meta   `json:"meta,omitempty"`

	// Warnings Slurm warnings
	Warnings *V0039Warnings `json:"warnings,omitempty"`
}

// V0039AcctGatherEnergy defines model for v0.0.39_acct_gather_energy.
type V0039AcctGatherEnergy struct {
	AverageWatts       *int32 `json:"average_watts,omitempty"`
	BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`
	ConsumedEnergy     *int64 `json:"consumed_energy,omitempty"`

	// CurrentWatts Integer number with flags
	CurrentWatts           *V0039Uint32NoVal `json:"current_watts,omitempty"`
	LastCollected          *int64            `json:"last_collected,omitempty"`
	PreviousConsumedEnergy *int64            `json:"previous_consumed_energy,omitempty"`
}

// V0039AcctGatherEnergyPtr defines model for v0.0.39_acct_gather_energy_ptr.
type V0039AcctGatherEnergyPtr = V0039AcctGatherEnergy

// V0039ControllerPing defines model for v0.0.39_controller_ping.
type V0039ControllerPing struct {
	Hostname *string `json:"hostname,omitempty"`
	Latency  *int64  `json:"latency,omitempty"`
	Mode     *string `json:"mode,omitempty"`
	Pinged   *string `json:"pinged,omitempty"`
}

// V0039ControllerPingArray defines model for v0.0.39_controller_ping_array.
type V0039ControllerPingArray = []V0039ControllerPing

// V0039CronEntry defines model for v0.0.39_cron_entry.
type V0039CronEntry struct {
	Command    *string                `json:"command,omitempty"`
	DayOfMonth *string                `json:"day_of_month,omitempty"`
	DayOfWeek  *string                `json:"day_of_week,omitempty"`
	Flags      *[]V0039CronEntryFlags `json:"flags,omitempty"`
	Hour       *string                `json:"hour,omitempty"`
	Line       *struct {
		End   *int32 `json:"end,omitempty"`
		Start *int32 `json:"start,omitempty"`
	} `json:"line,omitempty"`
	Minute        *string `json:"minute,omitempty"`
	Month         *string `json:"month,omitempty"`
	Specification *string `json:"specification,omitempty"`
}

// V0039CronEntryFlags flags
type V0039CronEntryFlags string

// V0039CronEntryPtr defines model for v0.0.39_cron_entry_ptr.
type V0039CronEntryPtr = V0039CronEntry

// V0039CsvString defines model for v0.0.39_csv_string.
type V0039CsvString = []string

// V0039Diag defines model for v0.0.39_diag.
type V0039Diag struct {
	// Errors Slurm errors
	Errors     *V0039Errors   `json:"errors,omitempty"`
	Meta       *V0039Meta     `json:"meta,omitempty"`
	Statistics *V0039StatsMsg `json:"statistics,omitempty"`

	// Warnings Slurm warnings
	Warnings *V0039Warnings `json:"warnings,omitempty"`
}

// V0039Error defines model for v0.0.39_error.
type V0039Error struct {
	// Description Explanation of cause of error
	Description *string `json:"description,omitempty"`

	// Error Error message
	Error *string `json:"error,omitempty"`

	// ErrorNumber Slurm internal error number
	ErrorNumber *int `json:"error_number,omitempty"`

	// Source Where error occurred in the source
	Source *string `json:"source,omitempty"`
}

// V0039Errors Slurm errors
type V0039Errors = []V0039Error

// V0039ExtSensorsData defines model for v0.0.39_ext_sensors_data.
type V0039ExtSensorsData struct {
	// ConsumedEnergy Integer number with flags
	ConsumedEnergy   *V0039Uint64NoVal `json:"consumed_energy,omitempty"`
	CurrentWatts     *int32            `json:"current_watts,omitempty"`
	EnergyUpdateTime *int64            `json:"energy_update_time,omitempty"`

	// Temperature Integer number with flags
	Temperature *V0039Uint32NoVal `json:"temperature,omitempty"`
}

// V0039ExtSensorsDataPtr defines model for v0.0.39_ext_sensors_data_ptr.
type V0039ExtSensorsDataPtr = V0039ExtSensorsData

// V0039Float64NoVal 64 bit floating point number with flags
type V0039Float64NoVal struct {
	// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
	Infinite *bool `json:"infinite,omitempty"`

	// Number If set is True the number will be set with value. Otherwise ignore number contents.
	Number *float64 `json:"number,omitempty"`

	// Set True if number has been set. False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0039HostlistString defines model for v0.0.39_hostlist_string.
type V0039HostlistString = []string

// V0039JobArrayResponseMsg Result per ArrayJob
type V0039JobArrayResponseMsg = []struct {
	// Error error code description
	Error *string `json:"error,omitempty"`

	// ErrorCode numeric error code
	ErrorCode *int32 `json:"error_code,omitempty"`

	// JobId JobId
	JobId *int32 `json:"job_id,omitempty"`

	// Why error message
	Why *string `json:"why,omitempty"`
}

// V0039JobArrayResponseMsgPtr Result per ArrayJob
type V0039JobArrayResponseMsgPtr = V0039JobArrayResponseMsg

// V0039JobDescMsg defines model for v0.0.39_job_desc_msg.
type V0039JobDescMsg struct {
	Account                 *string                           `json:"account,omitempty"`
	AccountGatherFrequency  *string                           `json:"account_gather_frequency,omitempty"`
	AdminComment            *string                           `json:"admin_comment,omitempty"`
	AllocationNodeList      *string                           `json:"allocation_node_list,omitempty"`
	AllocationNodePort      *int32                            `json:"allocation_node_port,omitempty"`
	Argv                    *V0039JobDescMsgArgv              `json:"argv,omitempty"`
	Array                   *string                           `json:"array,omitempty"`
	BatchFeatures           *string                           `json:"batch_features,omitempty"`
	BeginTime               *int64                            `json:"begin_time,omitempty"`
	BurstBuffer             *string                           `json:"burst_buffer,omitempty"`
	ClusterConstraint       *string                           `json:"cluster_constraint,omitempty"`
	Clusters                *string                           `json:"clusters,omitempty"`
	Comment                 *string                           `json:"comment,omitempty"`
	Constraints             *string                           `json:"constraints,omitempty"`
	Container               *string                           `json:"container,omitempty"`
	ContainerId             *string                           `json:"container_id,omitempty"`
	Contiguous              *bool                             `json:"contiguous,omitempty"`
	CoreSpecification       *int32                            `json:"core_specification,omitempty"`
	CpuBinding              *string                           `json:"cpu_binding,omitempty"`
	CpuBindingFlags         *[]V0039JobDescMsgCpuBindingFlags `json:"cpu_binding_flags,omitempty"`
	CpuFrequency            *string                           `json:"cpu_frequency,omitempty"`
	CpusPerTask             *int32                            `json:"cpus_per_task,omitempty"`
	CpusPerTres             *string                           `json:"cpus_per_tres,omitempty"`
	Crontab                 *V0039CronEntryPtr                `json:"crontab,omitempty"`
	CurrentWorkingDirectory *string                           `json:"current_working_directory,omitempty"`
	Deadline                *int64                            `json:"deadline,omitempty"`
	DelayBoot               *int32                            `json:"delay_boot,omitempty"`
	Dependency              *string                           `json:"dependency,omitempty"`
	Distribution            *string                           `json:"distribution,omitempty"`
	DistributionPlaneSize   *int32                            `json:"distribution_plane_size,omitempty"`
	EndTime                 *int64                            `json:"end_time,omitempty"`
	Environment             V0039JobDescMsgEnv                `json:"environment"`
	ExcludedNodes           *V0039CsvString                   `json:"excluded_nodes,omitempty"`
	Exclusive               *V0039JobExclusive                `json:"exclusive,omitempty"`
	Extra                   *string                           `json:"extra,omitempty"`
	Flags                   *[]V0039JobDescMsgFlags           `json:"flags,omitempty"`
	GroupId                 *string                           `json:"group_id,omitempty"`
	HetjobGroup             *int32                            `json:"hetjob_group,omitempty"`

	// Hold Hold (true) or release (false) job
	Hold           *bool  `json:"hold,omitempty"`
	Immediate      *bool  `json:"immediate,omitempty"`
	JobId          *int32 `json:"job_id,omitempty"`
	KillOnNodeFail *bool  `json:"kill_on_node_fail,omitempty"`

	// KillWarningDelay Integer number with flags
	KillWarningDelay  *V0039Uint16NoVal                   `json:"kill_warning_delay,omitempty"`
	KillWarningFlags  *[]V0039JobDescMsgKillWarningFlags  `json:"kill_warning_flags,omitempty"`
	KillWarningSignal *string                             `json:"kill_warning_signal,omitempty"`
	Licenses          *string                             `json:"licenses,omitempty"`
	MailType          *[]V0039JobDescMsgMailType          `json:"mail_type,omitempty"`
	MailUser          *string                             `json:"mail_user,omitempty"`
	MaximumCpus       *int32                              `json:"maximum_cpus,omitempty"`
	MaximumNodes      *int32                              `json:"maximum_nodes,omitempty"`
	McsLabel          *string                             `json:"mcs_label,omitempty"`
	MemoryBinding     *string                             `json:"memory_binding,omitempty"`
	MemoryBindingType *[]V0039JobDescMsgMemoryBindingType `json:"memory_binding_type,omitempty"`

	// MemoryPerCpu Integer number with flags
	MemoryPerCpu *V0039MemPerCpus `json:"memory_per_cpu,omitempty"`

	// MemoryPerNode Integer number with flags
	MemoryPerNode          *V0039MemPerNode             `json:"memory_per_node,omitempty"`
	MemoryPerTres          *string                      `json:"memory_per_tres,omitempty"`
	MinimumBoardsPerNode   *int32                       `json:"minimum_boards_per_node,omitempty"`
	MinimumCpus            *int32                       `json:"minimum_cpus,omitempty"`
	MinimumCpusPerNode     *int32                       `json:"minimum_cpus_per_node,omitempty"`
	MinimumNodes           *int32                       `json:"minimum_nodes,omitempty"`
	MinimumSocketsPerBoard *int32                       `json:"minimum_sockets_per_board,omitempty"`
	Name                   *string                      `json:"name,omitempty"`
	Network                *string                      `json:"network,omitempty"`
	Nice                   *int32                       `json:"nice,omitempty"`
	Nodes                  *string                      `json:"nodes,omitempty"`
	NtasksPerTres          *int32                       `json:"ntasks_per_tres,omitempty"`
	OpenMode               *[]V0039JobDescMsgOpenMode   `json:"open_mode,omitempty"`
	Overcommit             *bool                        `json:"overcommit,omitempty"`
	Oversubscribe          *bool                        `json:"oversubscribe,omitempty"`
	Partition              *string                      `json:"partition,omitempty"`
	PowerFlags             *[]V0039JobDescMsgPowerFlags `json:"power_flags,omitempty"`
	Prefer                 *string                      `json:"prefer,omitempty"`

	// Priority Integer number with flags
	Priority      *V0039Uint32NoVal         `json:"priority,omitempty"`
	Profile       *[]V0039JobDescMsgProfile `json:"profile,omitempty"`
	Qos           *string                   `json:"qos,omitempty"`
	Reboot        *bool                     `json:"reboot,omitempty"`
	Requeue       *bool                     `json:"requeue,omitempty"`
	RequiredNodes *V0039CsvString           `json:"required_nodes,omitempty"`

	// RequiredSwitches Integer number with flags
	RequiredSwitches     *V0039Uint32NoVal        `json:"required_switches,omitempty"`
	Reservation          *string                  `json:"reservation,omitempty"`
	ReservePorts         *int32                   `json:"reserve_ports,omitempty"`
	Script               *string                  `json:"script,omitempty"`
	SelinuxContext       *string                  `json:"selinux_context,omitempty"`
	Shared               *[]V0039JobDescMsgShared `json:"shared,omitempty"`
	SiteFactor           *int32                   `json:"site_factor,omitempty"`
	SocketsPerNode       *int32                   `json:"sockets_per_node,omitempty"`
	SpankEnvironment     *V0039JobDescMsgSpankEnv `json:"spank_environment,omitempty"`
	StandardError        *string                  `json:"standard_error,omitempty"`
	StandardInput        *string                  `json:"standard_input,omitempty"`
	StandardOutput       *string                  `json:"standard_output,omitempty"`
	Tasks                *int32                   `json:"tasks,omitempty"`
	TasksPerBoard        *int32                   `json:"tasks_per_board,omitempty"`
	TasksPerCore         *int32                   `json:"tasks_per_core,omitempty"`
	TasksPerNode         *int32                   `json:"tasks_per_node,omitempty"`
	TasksPerSocket       *int32                   `json:"tasks_per_socket,omitempty"`
	TemporaryDiskPerNode *int32                   `json:"temporary_disk_per_node,omitempty"`
	ThreadSpecification  *int32                   `json:"thread_specification,omitempty"`
	ThreadsPerCore       *int32                   `json:"threads_per_core,omitempty"`

	// TimeLimit Integer number with flags
	TimeLimit *V0039Uint32NoVal `json:"time_limit,omitempty"`

	// TimeMinimum Integer number with flags
	TimeMinimum    *V0039Uint32NoVal     `json:"time_minimum,omitempty"`
	TresBind       *string               `json:"tres_bind,omitempty"`
	TresFreq       *string               `json:"tres_freq,omitempty"`
	TresPerJob     *string               `json:"tres_per_job,omitempty"`
	TresPerNode    *string               `json:"tres_per_node,omitempty"`
	TresPerSocket  *string               `json:"tres_per_socket,omitempty"`
	TresPerTask    *string               `json:"tres_per_task,omitempty"`
	UserId         *string               `json:"user_id,omitempty"`
	WaitAllNodes   *bool                 `json:"wait_all_nodes,omitempty"`
	WaitForSwitch  *int32                `json:"wait_for_switch,omitempty"`
	Wckey          *string               `json:"wckey,omitempty"`
	X11            *[]V0039JobDescMsgX11 `json:"x11,omitempty"`
	X11MagicCookie *string               `json:"x11_magic_cookie,omitempty"`
	X11TargetHost  *string               `json:"x11_target_host,omitempty"`
	X11TargetPort  *int32                `json:"x11_target_port,omitempty"`
}

// V0039JobDescMsgCpuBindingFlags flags
type V0039JobDescMsgCpuBindingFlags string

// V0039JobDescMsgFlags flags
type V0039JobDescMsgFlags string

// V0039JobDescMsgKillWarningFlags flags
type V0039JobDescMsgKillWarningFlags string

// V0039JobDescMsgMailType flags
type V0039JobDescMsgMailType string

// V0039JobDescMsgMemoryBindingType flags
type V0039JobDescMsgMemoryBindingType string

// V0039JobDescMsgOpenMode flags
type V0039JobDescMsgOpenMode string

// V0039JobDescMsgPowerFlags flags
type V0039JobDescMsgPowerFlags string

// V0039JobDescMsgProfile flags
type V0039JobDescMsgProfile string

// V0039JobDescMsgShared flags
type V0039JobDescMsgShared string

// V0039JobDescMsgX11 flags
type V0039JobDescMsgX11 string

// V0039JobDescMsgArgv defines model for v0.0.39_job_desc_msg_argv.
type V0039JobDescMsgArgv = V0039StringArray

// V0039JobDescMsgEnv defines model for v0.0.39_job_desc_msg_env.
type V0039JobDescMsgEnv = V0039StringArray

// V0039JobDescMsgList defines model for v0.0.39_job_desc_msg_list.
type V0039JobDescMsgList = []V0039JobDescMsg

// V0039JobDescMsgSpankEnv defines model for v0.0.39_job_desc_msg_spank_env.
type V0039JobDescMsgSpankEnv = V0039StringArray

// V0039JobExclusive defines model for v0.0.39_job_exclusive.
type V0039JobExclusive = []string

// V0039JobInfo defines model for v0.0.39_job_info.
type V0039JobInfo struct {
	Account        *string `json:"account,omitempty"`
	AccrueTime     *int64  `json:"accrue_time,omitempty"`
	AdminComment   *string `json:"admin_comment,omitempty"`
	AllocatingNode *string `json:"allocating_node,omitempty"`

	// ArrayJobId Integer number with flags
	ArrayJobId *V0039Uint32NoVal `json:"array_job_id,omitempty"`

	// ArrayMaxTasks Integer number with flags
	ArrayMaxTasks *V0039Uint32NoVal `json:"array_max_tasks,omitempty"`

	// ArrayTaskId Integer number with flags
	ArrayTaskId     *V0039Uint32NoVal `json:"array_task_id,omitempty"`
	ArrayTaskString *string           `json:"array_task_string,omitempty"`
	AssociationId   *int32            `json:"association_id,omitempty"`
	BatchFeatures   *string           `json:"batch_features,omitempty"`
	BatchFlag       *bool             `json:"batch_flag,omitempty"`
	BatchHost       *string           `json:"batch_host,omitempty"`

	// BillableTres 64 bit floating point number with flags
	BillableTres     *V0039Float64NoVal `json:"billable_tres,omitempty"`
	BurstBuffer      *string            `json:"burst_buffer,omitempty"`
	BurstBufferState *string            `json:"burst_buffer_state,omitempty"`
	Cluster          *string            `json:"cluster,omitempty"`
	ClusterFeatures  *string            `json:"cluster_features,omitempty"`
	Command          *string            `json:"command,omitempty"`
	Comment          *string            `json:"comment,omitempty"`
	Container        *string            `json:"container,omitempty"`
	ContainerId      *string            `json:"container_id,omitempty"`
	Contiguous       *bool              `json:"contiguous,omitempty"`
	CoreSpec         *int32             `json:"core_spec,omitempty"`

	// CoresPerSocket Integer number with flags
	CoresPerSocket *V0039Uint16NoVal `json:"cores_per_socket,omitempty"`

	// CpuFrequencyGovernor Integer number with flags
	CpuFrequencyGovernor *V0039Uint32NoVal `json:"cpu_frequency_governor,omitempty"`

	// CpuFrequencyMaximum Integer number with flags
	CpuFrequencyMaximum *V0039Uint32NoVal `json:"cpu_frequency_maximum,omitempty"`

	// CpuFrequencyMinimum Integer number with flags
	CpuFrequencyMinimum *V0039Uint32NoVal `json:"cpu_frequency_minimum,omitempty"`

	// Cpus Integer number with flags
	Cpus *V0039Uint32NoVal `json:"cpus,omitempty"`

	// CpusPerTask Integer number with flags
	CpusPerTask             *V0039Uint16NoVal `json:"cpus_per_task,omitempty"`
	CpusPerTres             *string           `json:"cpus_per_tres,omitempty"`
	Cron                    *string           `json:"cron,omitempty"`
	CurrentWorkingDirectory *string           `json:"current_working_directory,omitempty"`
	Deadline                *int64            `json:"deadline,omitempty"`

	// DelayBoot Integer number with flags
	DelayBoot  *V0039Uint32NoVal `json:"delay_boot,omitempty"`
	Dependency *string           `json:"dependency,omitempty"`

	// DerivedExitCode Integer number with flags
	DerivedExitCode *V0039Uint32NoVal  `json:"derived_exit_code,omitempty"`
	EligibleTime    *int64             `json:"eligible_time,omitempty"`
	EndTime         *int64             `json:"end_time,omitempty"`
	ExcludedNodes   *string            `json:"excluded_nodes,omitempty"`
	Exclusive       *V0039JobExclusive `json:"exclusive,omitempty"`

	// ExitCode Integer number with flags
	ExitCode                 *V0039Uint32NoVal       `json:"exit_code,omitempty"`
	Extra                    *string                 `json:"extra,omitempty"`
	FailedNode               *string                 `json:"failed_node,omitempty"`
	Features                 *string                 `json:"features,omitempty"`
	FederationOrigin         *string                 `json:"federation_origin,omitempty"`
	FederationSiblingsActive *string                 `json:"federation_siblings_active,omitempty"`
	FederationSiblingsViable *string                 `json:"federation_siblings_viable,omitempty"`
	Flags                    *[]V0039JobInfoFlags    `json:"flags,omitempty"`
	GresDetail               *V0039JobInfoGresDetail `json:"gres_detail,omitempty"`
	GroupId                  *int32                  `json:"group_id,omitempty"`
	GroupName                *string                 `json:"group_name,omitempty"`

	// HetJobId Integer number with flags
	HetJobId    *V0039Uint32NoVal `json:"het_job_id,omitempty"`
	HetJobIdSet *string           `json:"het_job_id_set,omitempty"`

	// HetJobOffset Integer number with flags
	HetJobOffset *V0039Uint32NoVal `json:"het_job_offset,omitempty"`

	// Hold Hold (true) or release (false) job
	Hold                *bool                   `json:"hold,omitempty"`
	JobId               *int32                  `json:"job_id,omitempty"`
	JobResources        *V0039JobResPtr         `json:"job_resources,omitempty"`
	JobSizeStr          *V0039CsvString         `json:"job_size_str,omitempty"`
	JobState            *string                 `json:"job_state,omitempty"`
	LastSchedEvaluation *int64                  `json:"last_sched_evaluation,omitempty"`
	Licenses            *string                 `json:"licenses,omitempty"`
	MailType            *[]V0039JobInfoMailType `json:"mail_type,omitempty"`
	MailUser            *string                 `json:"mail_user,omitempty"`

	// MaxCpus Integer number with flags
	MaxCpus *V0039Uint32NoVal `json:"max_cpus,omitempty"`

	// MaxNodes Integer number with flags
	MaxNodes              *V0039Uint32NoVal `json:"max_nodes,omitempty"`
	MaximumSwitchWaitTime *int32            `json:"maximum_switch_wait_time,omitempty"`
	McsLabel              *string           `json:"mcs_label,omitempty"`

	// MemoryPerCpu Integer number with flags
	MemoryPerCpu *V0039MemPerCpus `json:"memory_per_cpu,omitempty"`

	// MemoryPerNode Integer number with flags
	MemoryPerNode *V0039MemPerNode `json:"memory_per_node,omitempty"`
	MemoryPerTres *string          `json:"memory_per_tres,omitempty"`

	// MinimumCpusPerNode Integer number with flags
	MinimumCpusPerNode *V0039Uint16NoVal `json:"minimum_cpus_per_node,omitempty"`
	MinimumSwitches    *int32            `json:"minimum_switches,omitempty"`

	// MinimumTmpDiskPerNode Integer number with flags
	MinimumTmpDiskPerNode *V0039Uint32NoVal `json:"minimum_tmp_disk_per_node,omitempty"`
	Name                  *string           `json:"name,omitempty"`
	Network               *string           `json:"network,omitempty"`
	Nice                  *int32            `json:"nice,omitempty"`

	// NodeCount Integer number with flags
	NodeCount     *V0039Uint32NoVal `json:"node_count,omitempty"`
	Nodes         *string           `json:"nodes,omitempty"`
	Oversubscribe *bool             `json:"oversubscribe,omitempty"`
	Partition     *string           `json:"partition,omitempty"`
	Power         *struct {
		Flags *[]V0039JobInfoPowerFlags `json:"flags,omitempty"`
	} `json:"power,omitempty"`
	PreSusTime      *int64  `json:"pre_sus_time,omitempty"`
	PreemptTime     *int64  `json:"preempt_time,omitempty"`
	PreemptableTime *int64  `json:"preemptable_time,omitempty"`
	Prefer          *string `json:"prefer,omitempty"`

	// Priority Integer number with flags
	Priority        *V0039Uint32NoVal        `json:"priority,omitempty"`
	Profile         *[]V0039JobInfoProfile   `json:"profile,omitempty"`
	Qos             *string                  `json:"qos,omitempty"`
	Reboot          *bool                    `json:"reboot,omitempty"`
	Requeue         *bool                    `json:"requeue,omitempty"`
	RequiredNodes   *string                  `json:"required_nodes,omitempty"`
	ResizeTime      *int64                   `json:"resize_time,omitempty"`
	RestartCnt      *int32                   `json:"restart_cnt,omitempty"`
	ResvName        *string                  `json:"resv_name,omitempty"`
	ScheduledNodes  *string                  `json:"scheduled_nodes,omitempty"`
	SelinuxContext  *string                  `json:"selinux_context,omitempty"`
	Shared          *[]V0039JobInfoShared    `json:"shared,omitempty"`
	ShowFlags       *[]V0039JobInfoShowFlags `json:"show_flags,omitempty"`
	SocketsPerBoard *int32                   `json:"sockets_per_board,omitempty"`

	// SocketsPerNode Integer number with flags
	SocketsPerNode   *V0039Uint16NoVal `json:"sockets_per_node,omitempty"`
	StandardError    *string           `json:"standard_error,omitempty"`
	StandardInput    *string           `json:"standard_input,omitempty"`
	StandardOutput   *string           `json:"standard_output,omitempty"`
	StartTime        *int64            `json:"start_time,omitempty"`
	StateDescription *string           `json:"state_description,omitempty"`
	StateReason      *string           `json:"state_reason,omitempty"`
	SubmitTime       *int64            `json:"submit_time,omitempty"`
	SuspendTime      *int64            `json:"suspend_time,omitempty"`
	SystemComment    *string           `json:"system_comment,omitempty"`

	// Tasks Integer number with flags
	Tasks *V0039Uint32NoVal `json:"tasks,omitempty"`

	// TasksPerBoard Integer number with flags
	TasksPerBoard *V0039Uint16NoVal `json:"tasks_per_board,omitempty"`

	// TasksPerCore Integer number with flags
	TasksPerCore *V0039Uint16NoVal `json:"tasks_per_core,omitempty"`

	// TasksPerNode Integer number with flags
	TasksPerNode *V0039Uint16NoVal `json:"tasks_per_node,omitempty"`

	// TasksPerSocket Integer number with flags
	TasksPerSocket *V0039Uint16NoVal `json:"tasks_per_socket,omitempty"`

	// TasksPerTres Integer number with flags
	TasksPerTres *V0039Uint16NoVal `json:"tasks_per_tres,omitempty"`
	ThreadSpec   *int32            `json:"thread_spec,omitempty"`

	// ThreadsPerCore Integer number with flags
	ThreadsPerCore *V0039Uint16NoVal `json:"threads_per_core,omitempty"`

	// TimeLimit Integer number with flags
	TimeLimit *V0039Uint32NoVal `json:"time_limit,omitempty"`

	// TimeMinimum Integer number with flags
	TimeMinimum   *V0039Uint32NoVal `json:"time_minimum,omitempty"`
	TresAllocStr  *string           `json:"tres_alloc_str,omitempty"`
	TresBind      *string           `json:"tres_bind,omitempty"`
	TresFreq      *string           `json:"tres_freq,omitempty"`
	TresPerJob    *string           `json:"tres_per_job,omitempty"`
	TresPerNode   *string           `json:"tres_per_node,omitempty"`
	TresPerSocket *string           `json:"tres_per_socket,omitempty"`
	TresPerTask   *string           `json:"tres_per_task,omitempty"`
	TresReqStr    *string           `json:"tres_req_str,omitempty"`
	UserId        *int32            `json:"user_id,omitempty"`
	UserName      *string           `json:"user_name,omitempty"`
	Wckey         *string           `json:"wckey,omitempty"`
}

// V0039JobInfoFlags flags
type V0039JobInfoFlags string

// V0039JobInfoMailType flags
type V0039JobInfoMailType string

// V0039JobInfoPowerFlags flags
type V0039JobInfoPowerFlags string

// V0039JobInfoProfile flags
type V0039JobInfoProfile string

// V0039JobInfoShared flags
type V0039JobInfoShared string

// V0039JobInfoShowFlags flags
type V0039JobInfoShowFlags string

// V0039JobInfoGresDetail defines model for v0.0.39_job_info_gres_detail.
type V0039JobInfoGresDetail = []string

// V0039JobInfoMsg defines model for v0.0.39_job_info_msg.
type V0039JobInfoMsg = []V0039JobInfo

// V0039JobRes defines model for v0.0.39_job_res.
type V0039JobRes struct {
	AllocatedCores *int32 `json:"allocated_cores,omitempty"`
	AllocatedCpus  *int32 `json:"allocated_cpus,omitempty"`
	AllocatedHosts *int32 `json:"allocated_hosts,omitempty"`

	// AllocatedNodes job node resources
	AllocatedNodes *V0039JobResNodes `json:"allocated_nodes,omitempty"`
	Nodes          *string           `json:"nodes,omitempty"`
}

// V0039JobResNodes job node resources
type V0039JobResNodes = []interface{}

// V0039JobResPtr defines model for v0.0.39_job_res_ptr.
type V0039JobResPtr = V0039JobRes

// V0039JobSubmission defines model for v0.0.39_job_submission.
type V0039JobSubmission struct {
	Job  *V0039JobDescMsg     `json:"job,omitempty"`
	Jobs *V0039JobDescMsgList `json:"jobs,omitempty"`

	// Script Executable script (full contents) to run in batch step for all job components
	Script *string `json:"script,omitempty"`
}

// V0039JobSubmissionResponse defines model for v0.0.39_job_submission_response.
type V0039JobSubmissionResponse struct {
	// Errors Slurm errors
	Errors *V0039Errors `json:"errors,omitempty"`

	// JobId new job ID
	JobId *int `json:"job_id,omitempty"`

	// JobSubmitUserMsg Message to user from job_submit plugin
	JobSubmitUserMsg *string    `json:"job_submit_user_msg,omitempty"`
	Meta             *V0039Meta `json:"meta,omitempty"`

	// StepId new job step ID
	StepId *string `json:"step_id,omitempty"`

	// Warnings Slurm warnings
	Warnings *V0039Warnings `json:"warnings,omitempty"`
}

// V0039JobUpdateResponse defines model for v0.0.39_job_update_response.
type V0039JobUpdateResponse struct {
	// Errors Slurm errors
	Errors *V0039Errors `json:"errors,omitempty"`
	Meta   *V0039Meta   `json:"meta,omitempty"`

	// Results Result per ArrayJob
	Results *V0039JobArrayResponseMsgPtr `json:"results,omitempty"`

	// Warnings Slurm warnings
	Warnings *V0039Warnings `json:"warnings,omitempty"`
}

// V0039JobsResponse defines model for v0.0.39_jobs_response.
type V0039JobsResponse struct {
	// Errors Slurm errors
	Errors *V0039Errors     `json:"errors,omitempty"`
	Jobs   *V0039JobInfoMsg `json:"jobs,omitempty"`
	Meta   *V0039Meta       `json:"meta,omitempty"`

	// Warnings Slurm warnings
	Warnings *V0039Warnings `json:"warnings,omitempty"`
}

// V0039License defines model for v0.0.39_license.
type V0039License struct {
	Free         *int32  `json:"Free,omitempty"`
	LastConsumed *int32  `json:"LastConsumed,omitempty"`
	LastDeficit  *int32  `json:"LastDeficit,omitempty"`
	LastUpdate   *int64  `json:"LastUpdate,omitempty"`
	LicenseName  *string `json:"LicenseName,omitempty"`
	Remote       *bool   `json:"Remote,omitempty"`
	Reserved     *int32  `json:"Reserved,omitempty"`
	Total        *int32  `json:"Total,omitempty"`
	Used         *int32  `json:"Used,omitempty"`
}

// V0039Licenses defines model for v0.0.39_licenses.
type V0039Licenses = []V0039License

// V0039LicensesInfo defines model for v0.0.39_licenses_info.
type V0039LicensesInfo struct {
	// Errors Slurm errors
	Errors   *V0039Errors   `json:"errors,omitempty"`
	Licenses *V0039Licenses `json:"licenses,omitempty"`
	Meta     *V0039Meta     `json:"meta,omitempty"`

	// Warnings Slurm warnings
	Warnings *V0039Warnings `json:"warnings,omitempty"`
}

// V0039MemPerCpus Integer number with flags
type V0039MemPerCpus = V0039Uint64NoVal

// V0039MemPerNode Integer number with flags
type V0039MemPerNode = V0039Uint64NoVal

// V0039Meta defines model for v0.0.39_meta.
type V0039Meta struct {
	// Slurm Slurm information
	Slurm *struct {
		// Release version specifier
		Release *string `json:"release,omitempty"`
		Version *struct {
			Major *int `json:"major,omitempty"`
			Micro *int `json:"micro,omitempty"`
			Minor *int `json:"minor,omitempty"`
		} `json:"version,omitempty"`
	} `json:"Slurm,omitempty"`
	Plugin *struct {
		Name *string `json:"name,omitempty"`
		Type *string `json:"type,omitempty"`
	} `json:"plugin,omitempty"`
}

// V0039Node defines model for v0.0.39_node.
type V0039Node struct {
	ActiveFeatures            *V0039CsvString `json:"active_features,omitempty"`
	Address                   *string         `json:"address,omitempty"`
	AllocCpus                 *int32          `json:"alloc_cpus,omitempty"`
	AllocIdleCpus             *int32          `json:"alloc_idle_cpus,omitempty"`
	AllocMemory               *int64          `json:"alloc_memory,omitempty"`
	Architecture              *string         `json:"architecture,omitempty"`
	Boards                    *int32          `json:"boards,omitempty"`
	BootTime                  *int64          `json:"boot_time,omitempty"`
	BurstbufferNetworkAddress *string         `json:"burstbuffer_network_address,omitempty"`
	ClusterName               *string         `json:"cluster_name,omitempty"`
	Comment                   *string         `json:"comment,omitempty"`
	Cores                     *int32          `json:"cores,omitempty"`
	CpuBinding                *int32          `json:"cpu_binding,omitempty"`

	// CpuLoad Integer number with flags
	CpuLoad         *V0039Uint32NoVal         `json:"cpu_load,omitempty"`
	Cpus            *int32                    `json:"cpus,omitempty"`
	EffectiveCpus   *int32                    `json:"effective_cpus,omitempty"`
	Energy          *V0039AcctGatherEnergyPtr `json:"energy,omitempty"`
	ExternalSensors *V0039ExtSensorsDataPtr   `json:"external_sensors,omitempty"`
	Extra           *string                   `json:"extra,omitempty"`
	Features        *V0039CsvString           `json:"features,omitempty"`

	// FreeMem Integer number with flags
	FreeMem              *V0039Uint64NoVal                `json:"free_mem,omitempty"`
	Gres                 *string                          `json:"gres,omitempty"`
	GresDrained          *string                          `json:"gres_drained,omitempty"`
	GresUsed             *string                          `json:"gres_used,omitempty"`
	Hostname             *string                          `json:"hostname,omitempty"`
	LastBusy             *int64                           `json:"last_busy,omitempty"`
	McsLabel             *string                          `json:"mcs_label,omitempty"`
	Name                 *string                          `json:"name,omitempty"`
	NextStateAfterReboot *[]V0039NodeNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`
	OperatingSystem      *string                          `json:"operating_system,omitempty"`
	Owner                *string                          `json:"owner,omitempty"`
	Partitions           *V0039CsvString                  `json:"partitions,omitempty"`
	Port                 *int32                           `json:"port,omitempty"`
	Power                *V0039PowerMgmtDataPtr           `json:"power,omitempty"`
	RealMemory           *int64                           `json:"real_memory,omitempty"`
	Reason               *string                          `json:"reason,omitempty"`
	ReasonChangedAt      *int64                           `json:"reason_changed_at,omitempty"`
	ReasonSetByUser      *string                          `json:"reason_set_by_user,omitempty"`
	Reservation          *string                          `json:"reservation,omitempty"`

	// ResumeAfter Integer number with flags
	ResumeAfter       *V0039Uint64NoVal `json:"resume_after,omitempty"`
	SlurmdStartTime   *int64            `json:"slurmd_start_time,omitempty"`
	Sockets           *int32            `json:"sockets,omitempty"`
	SpecializedCores  *int32            `json:"specialized_cores,omitempty"`
	SpecializedCpus   *string           `json:"specialized_cpus,omitempty"`
	SpecializedMemory *int64            `json:"specialized_memory,omitempty"`
	State             *[]V0039NodeState `json:"state,omitempty"`
	TemporaryDisk     *int32            `json:"temporary_disk,omitempty"`
	Threads           *int32            `json:"threads,omitempty"`
	Tres              *string           `json:"tres,omitempty"`
	TresUsed          *string           `json:"tres_used,omitempty"`
	TresWeighted      *float64          `json:"tres_weighted,omitempty"`
	Version           *string           `json:"version,omitempty"`
	Weight            *int32            `json:"weight,omitempty"`
}

// V0039NodeNextStateAfterReboot flags
type V0039NodeNextStateAfterReboot string

// V0039NodeState flags
type V0039NodeState string

// V0039Nodes defines model for v0.0.39_nodes.
type V0039Nodes = []V0039Node

// V0039NodesResponse defines model for v0.0.39_nodes_response.
type V0039NodesResponse struct {
	// Errors Slurm errors
	Errors *V0039Errors `json:"errors,omitempty"`
	Meta   *V0039Meta   `json:"meta,omitempty"`
	Nodes  *V0039Nodes  `json:"nodes,omitempty"`

	// Warnings Slurm warnings
	Warnings *V0039Warnings `json:"warnings,omitempty"`
}

// V0039PartitionInfo defines model for v0.0.39_partition_info.
type V0039PartitionInfo struct {
	Accounts *struct {
		Allowed *string `json:"allowed,omitempty"`
		Deny    *string `json:"deny,omitempty"`
	} `json:"accounts,omitempty"`
	Alternate *string `json:"alternate,omitempty"`
	Cluster   *string `json:"cluster,omitempty"`
	Cpus      *struct {
		TaskBinding *int32 `json:"task_binding,omitempty"`
		Total       *int32 `json:"total,omitempty"`
	} `json:"cpus,omitempty"`
	Defaults *struct {
		Job          *string `json:"job,omitempty"`
		MemoryPerCpu *int64  `json:"memory_per_cpu,omitempty"`

		// Time Integer number with flags
		Time *V0039Uint32NoVal `json:"time,omitempty"`
	} `json:"defaults,omitempty"`
	GraceTime *int32 `json:"grace_time,omitempty"`
	Groups    *struct {
		Allowed *string `json:"allowed,omitempty"`
	} `json:"groups,omitempty"`
	Maximums *struct {
		// CpusPerNode Integer number with flags
		CpusPerNode *V0039Uint32NoVal `json:"cpus_per_node,omitempty"`

		// CpusPerSocket Integer number with flags
		CpusPerSocket *V0039Uint32NoVal `json:"cpus_per_socket,omitempty"`
		MemoryPerCpu  *int64            `json:"memory_per_cpu,omitempty"`

		// Nodes Integer number with flags
		Nodes *V0039Uint32NoVal `json:"nodes,omitempty"`

		// OverTimeLimit Integer number with flags
		OverTimeLimit *V0039Uint16NoVal `json:"over_time_limit,omitempty"`
		Shares        *int32            `json:"shares,omitempty"`

		// Time Integer number with flags
		Time *V0039Uint32NoVal `json:"time,omitempty"`
	} `json:"maximums,omitempty"`
	Minimums *struct {
		Nodes *int32 `json:"nodes,omitempty"`
	} `json:"minimums,omitempty"`
	Name     *string `json:"name,omitempty"`
	NodeSets *string `json:"node_sets,omitempty"`
	Nodes    *struct {
		AllowedAllocation *string `json:"allowed_allocation,omitempty"`
		Configured        *string `json:"configured,omitempty"`
		Total             *int32  `json:"total,omitempty"`
	} `json:"nodes,omitempty"`
	Priority *struct {
		JobFactor *int32 `json:"job_factor,omitempty"`
		Tier      *int32 `json:"tier,omitempty"`
	} `json:"priority,omitempty"`
	Qos *struct {
		Allowed  *string `json:"allowed,omitempty"`
		Assigned *string `json:"assigned,omitempty"`
		Deny     *string `json:"deny,omitempty"`
	} `json:"qos,omitempty"`

	// SuspendTime Integer number with flags
	SuspendTime *V0039Uint32NoVal `json:"suspend_time,omitempty"`
	Timeouts    *struct {
		// Resume Integer number with flags
		Resume *V0039Uint16NoVal `json:"resume,omitempty"`

		// Suspend Integer number with flags
		Suspend *V0039Uint16NoVal `json:"suspend,omitempty"`
	} `json:"timeouts,omitempty"`
	Tres *struct {
		BillingWeights *string `json:"billing_weights,omitempty"`
		Configured     *string `json:"configured,omitempty"`
	} `json:"tres,omitempty"`
}

// V0039PartitionInfoArray defines model for v0.0.39_partition_info_array.
type V0039PartitionInfoArray = []V0039PartitionInfo

// V0039PartitionsResponse defines model for v0.0.39_partitions_response.
type V0039PartitionsResponse struct {
	// Errors Slurm errors
	Errors     *V0039Errors             `json:"errors,omitempty"`
	Meta       *V0039Meta               `json:"meta,omitempty"`
	Partitions *V0039PartitionInfoArray `json:"partitions,omitempty"`

	// Warnings Slurm warnings
	Warnings *V0039Warnings `json:"warnings,omitempty"`
}

// V0039Pings defines model for v0.0.39_pings.
type V0039Pings struct {
	// Errors Slurm errors
	Errors *V0039Errors              `json:"errors,omitempty"`
	Meta   *V0039Meta                `json:"meta,omitempty"`
	Pings  *V0039ControllerPingArray `json:"pings,omitempty"`

	// Warnings Slurm warnings
	Warnings *V0039Warnings `json:"warnings,omitempty"`
}

// V0039PowerMgmtData defines model for v0.0.39_power_mgmt_data.
type V0039PowerMgmtData struct {
	CurrentWatts *int32 `json:"current_watts,omitempty"`
	LowestWatts  *int32 `json:"lowest_watts,omitempty"`

	// MaximumWatts Integer number with flags
	MaximumWatts    *V0039Uint32NoVal `json:"maximum_watts,omitempty"`
	NewJobTime      *int64            `json:"new_job_time,omitempty"`
	NewMaximumWatts *int32            `json:"new_maximum_watts,omitempty"`
	PeakWatts       *int32            `json:"peak_watts,omitempty"`
	State           *int32            `json:"state,omitempty"`
	TimeStartDay    *int64            `json:"time_start_day,omitempty"`
	TotalEnergy     *int64            `json:"total_energy,omitempty"`
}

// V0039PowerMgmtDataPtr defines model for v0.0.39_power_mgmt_data_ptr.
type V0039PowerMgmtDataPtr = V0039PowerMgmtData

// V0039ReservationCoreSpec defines model for v0.0.39_reservation_core_spec.
type V0039ReservationCoreSpec struct {
	Core *string `json:"core,omitempty"`
	Node *string `json:"node,omitempty"`
}

// V0039ReservationInfo defines model for v0.0.39_reservation_info.
type V0039ReservationInfo struct {
	Accounts            *string                       `json:"accounts,omitempty"`
	BurstBuffer         *string                       `json:"burst_buffer,omitempty"`
	CoreCount           *int32                        `json:"core_count,omitempty"`
	CoreSpecializations *V0039ReservationInfoCoreSpec `json:"core_specializations,omitempty"`
	EndTime             *int64                        `json:"end_time,omitempty"`
	Features            *string                       `json:"features,omitempty"`
	Flags               *[]V0039ReservationInfoFlags  `json:"flags,omitempty"`
	Groups              *string                       `json:"groups,omitempty"`
	Licenses            *string                       `json:"licenses,omitempty"`
	MaxStartDelay       *int32                        `json:"max_start_delay,omitempty"`
	Name                *string                       `json:"name,omitempty"`
	NodeCount           *int32                        `json:"node_count,omitempty"`
	NodeList            *string                       `json:"node_list,omitempty"`
	Partition           *string                       `json:"partition,omitempty"`
	PurgeCompleted      *struct {
		// Time Integer number with flags
		Time *V0039Uint32NoVal `json:"time,omitempty"`
	} `json:"purge_completed,omitempty"`
	StartTime *int64  `json:"start_time,omitempty"`
	Tres      *string `json:"tres,omitempty"`
	Users     *string `json:"users,omitempty"`

	// Watts Integer number with flags
	Watts *V0039Uint32NoVal `json:"watts,omitempty"`
}

// V0039ReservationInfoFlags flags
type V0039ReservationInfoFlags string

// V0039ReservationInfoArray defines model for v0.0.39_reservation_info_array.
type V0039ReservationInfoArray = []V0039ReservationInfo

// V0039ReservationInfoCoreSpec defines model for v0.0.39_reservation_info_core_spec.
type V0039ReservationInfoCoreSpec = []V0039ReservationCoreSpec

// V0039ReservationsResponse defines model for v0.0.39_reservations_response.
type V0039ReservationsResponse struct {
	// Errors Slurm errors
	Errors       *V0039Errors               `json:"errors,omitempty"`
	Meta         *V0039Meta                 `json:"meta,omitempty"`
	Reservations *V0039ReservationInfoArray `json:"reservations,omitempty"`

	// Warnings Slurm warnings
	Warnings *V0039Warnings `json:"warnings,omitempty"`
}

// V0039StatsMsg defines model for v0.0.39_stats_msg.
type V0039StatsMsg struct {
	AgentCount           *int32 `json:"agent_count,omitempty"`
	AgentQueueSize       *int32 `json:"agent_queue_size,omitempty"`
	AgentThreadCount     *int32 `json:"agent_thread_count,omitempty"`
	BfActive             *bool  `json:"bf_active,omitempty"`
	BfBackfilledHetJobs  *int32 `json:"bf_backfilled_het_jobs,omitempty"`
	BfBackfilledJobs     *int32 `json:"bf_backfilled_jobs,omitempty"`
	BfCycleCounter       *int32 `json:"bf_cycle_counter,omitempty"`
	BfCycleLast          *int32 `json:"bf_cycle_last,omitempty"`
	BfCycleMean          *int64 `json:"bf_cycle_mean,omitempty"`
	BfCycleSum           *int64 `json:"bf_cycle_sum,omitempty"`
	BfDepthMean          *int64 `json:"bf_depth_mean,omitempty"`
	BfDepthMeanTry       *int64 `json:"bf_depth_mean_try,omitempty"`
	BfDepthSum           *int32 `json:"bf_depth_sum,omitempty"`
	BfDepthTrySum        *int32 `json:"bf_depth_try_sum,omitempty"`
	BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`
	BfLastDepth          *int32 `json:"bf_last_depth,omitempty"`
	BfLastDepthTry       *int32 `json:"bf_last_depth_try,omitempty"`
	BfQueueLen           *int32 `json:"bf_queue_len,omitempty"`
	BfQueueLenMean       *int64 `json:"bf_queue_len_mean,omitempty"`
	BfQueueLenSum        *int32 `json:"bf_queue_len_sum,omitempty"`
	BfTableSize          *int32 `json:"bf_table_size,omitempty"`
	BfTableSizeMean      *int64 `json:"bf_table_size_mean,omitempty"`
	BfWhenLastCycle      *int64 `json:"bf_when_last_cycle,omitempty"`
	DbdAgentQueueSize    *int32 `json:"dbd_agent_queue_size,omitempty"`
	GettimeofdayLatency  *int32 `json:"gettimeofday_latency,omitempty"`
	JobStatesTs          *int64 `json:"job_states_ts,omitempty"`
	JobsCanceled         *int32 `json:"jobs_canceled,omitempty"`
	JobsCompleted        *int32 `json:"jobs_completed,omitempty"`
	JobsFailed           *int32 `json:"jobs_failed,omitempty"`
	JobsPending          *int32 `json:"jobs_pending,omitempty"`
	JobsRunning          *int32 `json:"jobs_running,omitempty"`
	JobsStarted          *int32 `json:"jobs_started,omitempty"`
	JobsSubmitted        *int32 `json:"jobs_submitted,omitempty"`
	PartsPacked          *int32 `json:"parts_packed,omitempty"`
	ReqTime              *int64 `json:"req_time,omitempty"`
	ReqTimeStart         *int64 `json:"req_time_start,omitempty"`

	// RpcsByMessageType RPCs by message type
	RpcsByMessageType *V0039StatsMsgRpcsByType `json:"rpcs_by_message_type,omitempty"`

	// RpcsByUser RPCs by user
	RpcsByUser             *V0039StatsMsgRpcsByUser `json:"rpcs_by_user,omitempty"`
	ScheduleCycleLast      *int32                   `json:"schedule_cycle_last,omitempty"`
	ScheduleCycleMax       *int32                   `json:"schedule_cycle_max,omitempty"`
	ScheduleCycleMean      *int64                   `json:"schedule_cycle_mean,omitempty"`
	ScheduleCycleMeanDepth *int64                   `json:"schedule_cycle_mean_depth,omitempty"`
	ScheduleCyclePerMinute *int64                   `json:"schedule_cycle_per_minute,omitempty"`
	ScheduleCycleTotal     *int32                   `json:"schedule_cycle_total,omitempty"`
	ScheduleQueueLength    *int32                   `json:"schedule_queue_length,omitempty"`
	ServerThreadCount      *int32                   `json:"server_thread_count,omitempty"`
}

// V0039StatsMsgRpcsByType RPCs by message type
type V0039StatsMsgRpcsByType = []struct {
	// AverageTime Average time spent processing RPC in seconds
	AverageTime *int64 `json:"average_time,omitempty"`

	// Count Number of RPCs received
	Count *int64 `json:"count,omitempty"`

	// MessageType Message type as string
	MessageType *string `json:"message_type,omitempty"`

	// TotalTime Total time spent processing RPC in seconds
	TotalTime *int64 `json:"total_time,omitempty"`

	// TypeId Message type as integer
	TypeId *int32 `json:"type_id,omitempty"`
}

// V0039StatsMsgRpcsByUser RPCs by user
type V0039StatsMsgRpcsByUser = []struct {
	// AverageTime Average time spent processing RPC in seconds
	AverageTime *int64 `json:"average_time,omitempty"`

	// Count Number of RPCs received
	Count *int64 `json:"count,omitempty"`

	// TotalTime Total time spent processing RPC in seconds
	TotalTime *int64 `json:"total_time,omitempty"`

	// User user name
	User *string `json:"user,omitempty"`

	// UserId user id (numeric)
	UserId *int32 `json:"user_id,omitempty"`
}

// V0039StringArray defines model for v0.0.39_string_array.
type V0039StringArray = []string

// V0039Uint16NoVal Integer number with flags
type V0039Uint16NoVal struct {
	// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
	Infinite *bool `json:"infinite,omitempty"`

	// Number If set is True the number will be set with value. Otherwise ignore number contents.
	Number *int64 `json:"number,omitempty"`

	// Set True if number has been set. False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0039Uint32NoVal Integer number with flags
type V0039Uint32NoVal struct {
	// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
	Infinite *bool `json:"infinite,omitempty"`

	// Number If set is True the number will be set with value. Otherwise ignore number contents.
	Number *int64 `json:"number,omitempty"`

	// Set True if number has been set. False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0039Uint64NoVal Integer number with flags
type V0039Uint64NoVal struct {
	// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
	Infinite *bool `json:"infinite,omitempty"`

	// Number If set is True the number will be set with value. Otherwise ignore number contents.
	Number *int64 `json:"number,omitempty"`

	// Set True if number has been set. False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0039UpdateNodeMsg defines model for v0.0.39_update_node_msg.
type V0039UpdateNodeMsg struct {
	Address *V0039HostlistString `json:"address,omitempty"`

	// Comment arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// CpuBind default CPU binding type
	CpuBind *int32 `json:"cpu_bind,omitempty"`

	// Extra arbitrary string
	Extra       *string         `json:"extra,omitempty"`
	Features    *V0039CsvString `json:"features,omitempty"`
	FeaturesAct *V0039CsvString `json:"features_act,omitempty"`

	// Gres new generic resources for node
	Gres     *string              `json:"gres,omitempty"`
	Hostname *V0039HostlistString `json:"hostname,omitempty"`
	Name     *V0039HostlistString `json:"name,omitempty"`

	// Reason reason for node being DOWN or DRAINING
	Reason *string `json:"reason,omitempty"`

	// ReasonUid user ID of sending (needed if user root is sending message)
	ReasonUid *string `json:"reason_uid,omitempty"`

	// ResumeAfter Integer number with flags
	ResumeAfter *V0039Uint32NoVal `json:"resume_after,omitempty"`

	// State assign new node state
	State *[]V0039UpdateNodeMsgState `json:"state,omitempty"`

	// Weight Integer number with flags
	Weight *V0039Uint32NoVal `json:"weight,omitempty"`
}

// V0039UpdateNodeMsgState flags
type V0039UpdateNodeMsgState string

// V0039Warning defines model for v0.0.39_warning.
type V0039Warning struct {
	// Description Explanation of cause of error
	Description *string `json:"description,omitempty"`

	// Source Where error occurred in the source
	Source *string `json:"source,omitempty"`

	// Warning Earning message
	Warning *string `json:"warning,omitempty"`
}

// V0039Warnings Slurm warnings
type V0039Warnings = []V0039Warning

// SlurmV0039SubmitJobJSONBody defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBody struct {
	Job *struct {
		Account                *string                                          `json:"account,omitempty"`
		AccountGatherFrequency *string                                          `json:"account_gather_frequency,omitempty"`
		AdminComment           *string                                          `json:"admin_comment,omitempty"`
		AllocationNodeList     *string                                          `json:"allocation_node_list,omitempty"`
		AllocationNodePort     *int32                                           `json:"allocation_node_port,omitempty"`
		Argv                   *[]string                                        `json:"argv,omitempty"`
		Array                  *string                                          `json:"array,omitempty"`
		BatchFeatures          *string                                          `json:"batch_features,omitempty"`
		BeginTime              *int64                                           `json:"begin_time,omitempty"`
		BurstBuffer            *string                                          `json:"burst_buffer,omitempty"`
		ClusterConstraint      *string                                          `json:"cluster_constraint,omitempty"`
		Clusters               *string                                          `json:"clusters,omitempty"`
		Comment                *string                                          `json:"comment,omitempty"`
		Constraints            *string                                          `json:"constraints,omitempty"`
		Container              *string                                          `json:"container,omitempty"`
		ContainerId            *string                                          `json:"container_id,omitempty"`
		Contiguous             *bool                                            `json:"contiguous,omitempty"`
		CoreSpecification      *int32                                           `json:"core_specification,omitempty"`
		CpuBinding             *string                                          `json:"cpu_binding,omitempty"`
		CpuBindingFlags        *[]SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags `json:"cpu_binding_flags,omitempty"`
		CpuFrequency           *string                                          `json:"cpu_frequency,omitempty"`
		CpusPerTask            *int32                                           `json:"cpus_per_task,omitempty"`
		CpusPerTres            *string                                          `json:"cpus_per_tres,omitempty"`
		Crontab                *struct {
			Command    *string                                       `json:"command,omitempty"`
			DayOfMonth *string                                       `json:"day_of_month,omitempty"`
			DayOfWeek  *string                                       `json:"day_of_week,omitempty"`
			Flags      *[]SlurmV0039SubmitJobJSONBodyJobCrontabFlags `json:"flags,omitempty"`
			Hour       *string                                       `json:"hour,omitempty"`
			Line       *struct {
				End   *int32 `json:"end,omitempty"`
				Start *int32 `json:"start,omitempty"`
			} `json:"line,omitempty"`
			Minute        *string `json:"minute,omitempty"`
			Month         *string `json:"month,omitempty"`
			Specification *string `json:"specification,omitempty"`
		} `json:"crontab,omitempty"`
		CurrentWorkingDirectory *string                                    `json:"current_working_directory,omitempty"`
		Deadline                *int64                                     `json:"deadline,omitempty"`
		DelayBoot               *int32                                     `json:"delay_boot,omitempty"`
		Dependency              *string                                    `json:"dependency,omitempty"`
		Distribution            *string                                    `json:"distribution,omitempty"`
		DistributionPlaneSize   *int32                                     `json:"distribution_plane_size,omitempty"`
		EndTime                 *int64                                     `json:"end_time,omitempty"`
		Environment             []string                                   `json:"environment"`
		ExcludedNodes           *[]string                                  `json:"excluded_nodes,omitempty"`
		Exclusive               *[]SlurmV0039SubmitJobJSONBodyJobExclusive `json:"exclusive,omitempty"`
		Extra                   *string                                    `json:"extra,omitempty"`
		Flags                   *[]SlurmV0039SubmitJobJSONBodyJobFlags     `json:"flags,omitempty"`
		GroupId                 *string                                    `json:"group_id,omitempty"`
		HetjobGroup             *int32                                     `json:"hetjob_group,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold           *bool  `json:"hold,omitempty"`
		Immediate      *bool  `json:"immediate,omitempty"`
		JobId          *int32 `json:"job_id,omitempty"`
		KillOnNodeFail *bool  `json:"kill_on_node_fail,omitempty"`

		// KillWarningDelay Integer number with flags
		KillWarningDelay *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"kill_warning_delay,omitempty"`
		KillWarningFlags  *[]SlurmV0039SubmitJobJSONBodyJobKillWarningFlags  `json:"kill_warning_flags,omitempty"`
		KillWarningSignal *string                                            `json:"kill_warning_signal,omitempty"`
		Licenses          *string                                            `json:"licenses,omitempty"`
		MailType          *[]SlurmV0039SubmitJobJSONBodyJobMailType          `json:"mail_type,omitempty"`
		MailUser          *string                                            `json:"mail_user,omitempty"`
		MaximumCpus       *int32                                             `json:"maximum_cpus,omitempty"`
		MaximumNodes      *int32                                             `json:"maximum_nodes,omitempty"`
		McsLabel          *string                                            `json:"mcs_label,omitempty"`
		MemoryBinding     *string                                            `json:"memory_binding,omitempty"`
		MemoryBindingType *[]SlurmV0039SubmitJobJSONBodyJobMemoryBindingType `json:"memory_binding_type,omitempty"`

		// MemoryPerCpu Integer number with flags
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Integer number with flags
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`
		MemoryPerTres          *string                                     `json:"memory_per_tres,omitempty"`
		MinimumBoardsPerNode   *int32                                      `json:"minimum_boards_per_node,omitempty"`
		MinimumCpus            *int32                                      `json:"minimum_cpus,omitempty"`
		MinimumCpusPerNode     *int32                                      `json:"minimum_cpus_per_node,omitempty"`
		MinimumNodes           *int32                                      `json:"minimum_nodes,omitempty"`
		MinimumSocketsPerBoard *int32                                      `json:"minimum_sockets_per_board,omitempty"`
		Name                   *string                                     `json:"name,omitempty"`
		Network                *string                                     `json:"network,omitempty"`
		Nice                   *int32                                      `json:"nice,omitempty"`
		Nodes                  *string                                     `json:"nodes,omitempty"`
		NtasksPerTres          *int32                                      `json:"ntasks_per_tres,omitempty"`
		OpenMode               *[]SlurmV0039SubmitJobJSONBodyJobOpenMode   `json:"open_mode,omitempty"`
		Overcommit             *bool                                       `json:"overcommit,omitempty"`
		Oversubscribe          *bool                                       `json:"oversubscribe,omitempty"`
		Partition              *string                                     `json:"partition,omitempty"`
		PowerFlags             *[]SlurmV0039SubmitJobJSONBodyJobPowerFlags `json:"power_flags,omitempty"`
		Prefer                 *string                                     `json:"prefer,omitempty"`

		// Priority Integer number with flags
		Priority *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`
		Profile       *[]SlurmV0039SubmitJobJSONBodyJobProfile `json:"profile,omitempty"`
		Qos           *string                                  `json:"qos,omitempty"`
		Reboot        *bool                                    `json:"reboot,omitempty"`
		Requeue       *bool                                    `json:"requeue,omitempty"`
		RequiredNodes *[]string                                `json:"required_nodes,omitempty"`

		// RequiredSwitches Integer number with flags
		RequiredSwitches *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"required_switches,omitempty"`
		Reservation          *string                                 `json:"reservation,omitempty"`
		ReservePorts         *int32                                  `json:"reserve_ports,omitempty"`
		Script               *string                                 `json:"script,omitempty"`
		SelinuxContext       *string                                 `json:"selinux_context,omitempty"`
		Shared               *[]SlurmV0039SubmitJobJSONBodyJobShared `json:"shared,omitempty"`
		SiteFactor           *int32                                  `json:"site_factor,omitempty"`
		SocketsPerNode       *int32                                  `json:"sockets_per_node,omitempty"`
		SpankEnvironment     *[]string                               `json:"spank_environment,omitempty"`
		StandardError        *string                                 `json:"standard_error,omitempty"`
		StandardInput        *string                                 `json:"standard_input,omitempty"`
		StandardOutput       *string                                 `json:"standard_output,omitempty"`
		Tasks                *int32                                  `json:"tasks,omitempty"`
		TasksPerBoard        *int32                                  `json:"tasks_per_board,omitempty"`
		TasksPerCore         *int32                                  `json:"tasks_per_core,omitempty"`
		TasksPerNode         *int32                                  `json:"tasks_per_node,omitempty"`
		TasksPerSocket       *int32                                  `json:"tasks_per_socket,omitempty"`
		TemporaryDiskPerNode *int32                                  `json:"temporary_disk_per_node,omitempty"`
		ThreadSpecification  *int32                                  `json:"thread_specification,omitempty"`
		ThreadsPerCore       *int32                                  `json:"threads_per_core,omitempty"`

		// TimeLimit Integer number with flags
		TimeLimit *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Integer number with flags
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`
		TresBind       *string                              `json:"tres_bind,omitempty"`
		TresFreq       *string                              `json:"tres_freq,omitempty"`
		TresPerJob     *string                              `json:"tres_per_job,omitempty"`
		TresPerNode    *string                              `json:"tres_per_node,omitempty"`
		TresPerSocket  *string                              `json:"tres_per_socket,omitempty"`
		TresPerTask    *string                              `json:"tres_per_task,omitempty"`
		UserId         *string                              `json:"user_id,omitempty"`
		WaitAllNodes   *bool                                `json:"wait_all_nodes,omitempty"`
		WaitForSwitch  *int32                               `json:"wait_for_switch,omitempty"`
		Wckey          *string                              `json:"wckey,omitempty"`
		X11            *[]SlurmV0039SubmitJobJSONBodyJobX11 `json:"x11,omitempty"`
		X11MagicCookie *string                              `json:"x11_magic_cookie,omitempty"`
		X11TargetHost  *string                              `json:"x11_target_host,omitempty"`
		X11TargetPort  *int32                               `json:"x11_target_port,omitempty"`
	} `json:"job,omitempty"`
	Jobs *[]struct {
		Account                *string                                           `json:"account,omitempty"`
		AccountGatherFrequency *string                                           `json:"account_gather_frequency,omitempty"`
		AdminComment           *string                                           `json:"admin_comment,omitempty"`
		AllocationNodeList     *string                                           `json:"allocation_node_list,omitempty"`
		AllocationNodePort     *int32                                            `json:"allocation_node_port,omitempty"`
		Argv                   *[]string                                         `json:"argv,omitempty"`
		Array                  *string                                           `json:"array,omitempty"`
		BatchFeatures          *string                                           `json:"batch_features,omitempty"`
		BeginTime              *int64                                            `json:"begin_time,omitempty"`
		BurstBuffer            *string                                           `json:"burst_buffer,omitempty"`
		ClusterConstraint      *string                                           `json:"cluster_constraint,omitempty"`
		Clusters               *string                                           `json:"clusters,omitempty"`
		Comment                *string                                           `json:"comment,omitempty"`
		Constraints            *string                                           `json:"constraints,omitempty"`
		Container              *string                                           `json:"container,omitempty"`
		ContainerId            *string                                           `json:"container_id,omitempty"`
		Contiguous             *bool                                             `json:"contiguous,omitempty"`
		CoreSpecification      *int32                                            `json:"core_specification,omitempty"`
		CpuBinding             *string                                           `json:"cpu_binding,omitempty"`
		CpuBindingFlags        *[]SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags `json:"cpu_binding_flags,omitempty"`
		CpuFrequency           *string                                           `json:"cpu_frequency,omitempty"`
		CpusPerTask            *int32                                            `json:"cpus_per_task,omitempty"`
		CpusPerTres            *string                                           `json:"cpus_per_tres,omitempty"`
		Crontab                *struct {
			Command    *string                                        `json:"command,omitempty"`
			DayOfMonth *string                                        `json:"day_of_month,omitempty"`
			DayOfWeek  *string                                        `json:"day_of_week,omitempty"`
			Flags      *[]SlurmV0039SubmitJobJSONBodyJobsCrontabFlags `json:"flags,omitempty"`
			Hour       *string                                        `json:"hour,omitempty"`
			Line       *struct {
				End   *int32 `json:"end,omitempty"`
				Start *int32 `json:"start,omitempty"`
			} `json:"line,omitempty"`
			Minute        *string `json:"minute,omitempty"`
			Month         *string `json:"month,omitempty"`
			Specification *string `json:"specification,omitempty"`
		} `json:"crontab,omitempty"`
		CurrentWorkingDirectory *string                                     `json:"current_working_directory,omitempty"`
		Deadline                *int64                                      `json:"deadline,omitempty"`
		DelayBoot               *int32                                      `json:"delay_boot,omitempty"`
		Dependency              *string                                     `json:"dependency,omitempty"`
		Distribution            *string                                     `json:"distribution,omitempty"`
		DistributionPlaneSize   *int32                                      `json:"distribution_plane_size,omitempty"`
		EndTime                 *int64                                      `json:"end_time,omitempty"`
		Environment             []string                                    `json:"environment"`
		ExcludedNodes           *[]string                                   `json:"excluded_nodes,omitempty"`
		Exclusive               *[]SlurmV0039SubmitJobJSONBodyJobsExclusive `json:"exclusive,omitempty"`
		Extra                   *string                                     `json:"extra,omitempty"`
		Flags                   *[]SlurmV0039SubmitJobJSONBodyJobsFlags     `json:"flags,omitempty"`
		GroupId                 *string                                     `json:"group_id,omitempty"`
		HetjobGroup             *int32                                      `json:"hetjob_group,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold           *bool  `json:"hold,omitempty"`
		Immediate      *bool  `json:"immediate,omitempty"`
		JobId          *int32 `json:"job_id,omitempty"`
		KillOnNodeFail *bool  `json:"kill_on_node_fail,omitempty"`

		// KillWarningDelay Integer number with flags
		KillWarningDelay *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"kill_warning_delay,omitempty"`
		KillWarningFlags  *[]SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags  `json:"kill_warning_flags,omitempty"`
		KillWarningSignal *string                                             `json:"kill_warning_signal,omitempty"`
		Licenses          *string                                             `json:"licenses,omitempty"`
		MailType          *[]SlurmV0039SubmitJobJSONBodyJobsMailType          `json:"mail_type,omitempty"`
		MailUser          *string                                             `json:"mail_user,omitempty"`
		MaximumCpus       *int32                                              `json:"maximum_cpus,omitempty"`
		MaximumNodes      *int32                                              `json:"maximum_nodes,omitempty"`
		McsLabel          *string                                             `json:"mcs_label,omitempty"`
		MemoryBinding     *string                                             `json:"memory_binding,omitempty"`
		MemoryBindingType *[]SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType `json:"memory_binding_type,omitempty"`

		// MemoryPerCpu Integer number with flags
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Integer number with flags
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`
		MemoryPerTres          *string                                      `json:"memory_per_tres,omitempty"`
		MinimumBoardsPerNode   *int32                                       `json:"minimum_boards_per_node,omitempty"`
		MinimumCpus            *int32                                       `json:"minimum_cpus,omitempty"`
		MinimumCpusPerNode     *int32                                       `json:"minimum_cpus_per_node,omitempty"`
		MinimumNodes           *int32                                       `json:"minimum_nodes,omitempty"`
		MinimumSocketsPerBoard *int32                                       `json:"minimum_sockets_per_board,omitempty"`
		Name                   *string                                      `json:"name,omitempty"`
		Network                *string                                      `json:"network,omitempty"`
		Nice                   *int32                                       `json:"nice,omitempty"`
		Nodes                  *string                                      `json:"nodes,omitempty"`
		NtasksPerTres          *int32                                       `json:"ntasks_per_tres,omitempty"`
		OpenMode               *[]SlurmV0039SubmitJobJSONBodyJobsOpenMode   `json:"open_mode,omitempty"`
		Overcommit             *bool                                        `json:"overcommit,omitempty"`
		Oversubscribe          *bool                                        `json:"oversubscribe,omitempty"`
		Partition              *string                                      `json:"partition,omitempty"`
		PowerFlags             *[]SlurmV0039SubmitJobJSONBodyJobsPowerFlags `json:"power_flags,omitempty"`
		Prefer                 *string                                      `json:"prefer,omitempty"`

		// Priority Integer number with flags
		Priority *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`
		Profile       *[]SlurmV0039SubmitJobJSONBodyJobsProfile `json:"profile,omitempty"`
		Qos           *string                                   `json:"qos,omitempty"`
		Reboot        *bool                                     `json:"reboot,omitempty"`
		Requeue       *bool                                     `json:"requeue,omitempty"`
		RequiredNodes *[]string                                 `json:"required_nodes,omitempty"`

		// RequiredSwitches Integer number with flags
		RequiredSwitches *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"required_switches,omitempty"`
		Reservation          *string                                  `json:"reservation,omitempty"`
		ReservePorts         *int32                                   `json:"reserve_ports,omitempty"`
		Script               *string                                  `json:"script,omitempty"`
		SelinuxContext       *string                                  `json:"selinux_context,omitempty"`
		Shared               *[]SlurmV0039SubmitJobJSONBodyJobsShared `json:"shared,omitempty"`
		SiteFactor           *int32                                   `json:"site_factor,omitempty"`
		SocketsPerNode       *int32                                   `json:"sockets_per_node,omitempty"`
		SpankEnvironment     *[]string                                `json:"spank_environment,omitempty"`
		StandardError        *string                                  `json:"standard_error,omitempty"`
		StandardInput        *string                                  `json:"standard_input,omitempty"`
		StandardOutput       *string                                  `json:"standard_output,omitempty"`
		Tasks                *int32                                   `json:"tasks,omitempty"`
		TasksPerBoard        *int32                                   `json:"tasks_per_board,omitempty"`
		TasksPerCore         *int32                                   `json:"tasks_per_core,omitempty"`
		TasksPerNode         *int32                                   `json:"tasks_per_node,omitempty"`
		TasksPerSocket       *int32                                   `json:"tasks_per_socket,omitempty"`
		TemporaryDiskPerNode *int32                                   `json:"temporary_disk_per_node,omitempty"`
		ThreadSpecification  *int32                                   `json:"thread_specification,omitempty"`
		ThreadsPerCore       *int32                                   `json:"threads_per_core,omitempty"`

		// TimeLimit Integer number with flags
		TimeLimit *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Integer number with flags
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
			Infinite *bool `json:"infinite,omitempty"`

			// Number If set is True the number will be set with value. Otherwise ignore number contents.
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set. False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`
		TresBind       *string                               `json:"tres_bind,omitempty"`
		TresFreq       *string                               `json:"tres_freq,omitempty"`
		TresPerJob     *string                               `json:"tres_per_job,omitempty"`
		TresPerNode    *string                               `json:"tres_per_node,omitempty"`
		TresPerSocket  *string                               `json:"tres_per_socket,omitempty"`
		TresPerTask    *string                               `json:"tres_per_task,omitempty"`
		UserId         *string                               `json:"user_id,omitempty"`
		WaitAllNodes   *bool                                 `json:"wait_all_nodes,omitempty"`
		WaitForSwitch  *int32                                `json:"wait_for_switch,omitempty"`
		Wckey          *string                               `json:"wckey,omitempty"`
		X11            *[]SlurmV0039SubmitJobJSONBodyJobsX11 `json:"x11,omitempty"`
		X11MagicCookie *string                               `json:"x11_magic_cookie,omitempty"`
		X11TargetHost  *string                               `json:"x11_target_host,omitempty"`
		X11TargetPort  *int32                                `json:"x11_target_port,omitempty"`
	} `json:"jobs,omitempty"`

	// Script Executable script (full contents) to run in batch step for all job components
	Script *string `json:"script,omitempty"`
}

// SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobCpuBindingFlags string

// SlurmV0039SubmitJobJSONBodyJobCrontabFlags defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobCrontabFlags string

// SlurmV0039SubmitJobJSONBodyJobExclusive defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobExclusive string

// SlurmV0039SubmitJobJSONBodyJobFlags defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobFlags string

// SlurmV0039SubmitJobJSONBodyJobKillWarningFlags defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobKillWarningFlags string

// SlurmV0039SubmitJobJSONBodyJobMailType defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobMailType string

// SlurmV0039SubmitJobJSONBodyJobMemoryBindingType defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobMemoryBindingType string

// SlurmV0039SubmitJobJSONBodyJobOpenMode defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobOpenMode string

// SlurmV0039SubmitJobJSONBodyJobPowerFlags defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobPowerFlags string

// SlurmV0039SubmitJobJSONBodyJobProfile defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobProfile string

// SlurmV0039SubmitJobJSONBodyJobShared defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobShared string

// SlurmV0039SubmitJobJSONBodyJobX11 defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobX11 string

// SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsCpuBindingFlags string

// SlurmV0039SubmitJobJSONBodyJobsCrontabFlags defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsCrontabFlags string

// SlurmV0039SubmitJobJSONBodyJobsExclusive defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsExclusive string

// SlurmV0039SubmitJobJSONBodyJobsFlags defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsFlags string

// SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsKillWarningFlags string

// SlurmV0039SubmitJobJSONBodyJobsMailType defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsMailType string

// SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsMemoryBindingType string

// SlurmV0039SubmitJobJSONBodyJobsOpenMode defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsOpenMode string

// SlurmV0039SubmitJobJSONBodyJobsPowerFlags defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsPowerFlags string

// SlurmV0039SubmitJobJSONBodyJobsProfile defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsProfile string

// SlurmV0039SubmitJobJSONBodyJobsShared defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsShared string

// SlurmV0039SubmitJobJSONBodyJobsX11 defines parameters for SlurmV0039SubmitJob.
type SlurmV0039SubmitJobJSONBodyJobsX11 string

// SlurmV0039CancelJobParams defines parameters for SlurmV0039CancelJob.
type SlurmV0039CancelJobParams struct {
	// Signal signal to send to job
	Signal *SlurmV0039CancelJobParamsSignal `form:"signal,omitempty" json:"signal,omitempty"`
}

// SlurmV0039CancelJobParamsSignal defines parameters for SlurmV0039CancelJob.
type SlurmV0039CancelJobParamsSignal string

// SlurmV0039UpdateJobJSONBody defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBody struct {
	Account                *string                                       `json:"account,omitempty"`
	AccountGatherFrequency *string                                       `json:"account_gather_frequency,omitempty"`
	AdminComment           *string                                       `json:"admin_comment,omitempty"`
	AllocationNodeList     *string                                       `json:"allocation_node_list,omitempty"`
	AllocationNodePort     *int32                                        `json:"allocation_node_port,omitempty"`
	Argv                   *[]string                                     `json:"argv,omitempty"`
	Array                  *string                                       `json:"array,omitempty"`
	BatchFeatures          *string                                       `json:"batch_features,omitempty"`
	BeginTime              *int64                                        `json:"begin_time,omitempty"`
	BurstBuffer            *string                                       `json:"burst_buffer,omitempty"`
	ClusterConstraint      *string                                       `json:"cluster_constraint,omitempty"`
	Clusters               *string                                       `json:"clusters,omitempty"`
	Comment                *string                                       `json:"comment,omitempty"`
	Constraints            *string                                       `json:"constraints,omitempty"`
	Container              *string                                       `json:"container,omitempty"`
	ContainerId            *string                                       `json:"container_id,omitempty"`
	Contiguous             *bool                                         `json:"contiguous,omitempty"`
	CoreSpecification      *int32                                        `json:"core_specification,omitempty"`
	CpuBinding             *string                                       `json:"cpu_binding,omitempty"`
	CpuBindingFlags        *[]SlurmV0039UpdateJobJSONBodyCpuBindingFlags `json:"cpu_binding_flags,omitempty"`
	CpuFrequency           *string                                       `json:"cpu_frequency,omitempty"`
	CpusPerTask            *int32                                        `json:"cpus_per_task,omitempty"`
	CpusPerTres            *string                                       `json:"cpus_per_tres,omitempty"`
	Crontab                *struct {
		Command    *string                                    `json:"command,omitempty"`
		DayOfMonth *string                                    `json:"day_of_month,omitempty"`
		DayOfWeek  *string                                    `json:"day_of_week,omitempty"`
		Flags      *[]SlurmV0039UpdateJobJSONBodyCrontabFlags `json:"flags,omitempty"`
		Hour       *string                                    `json:"hour,omitempty"`
		Line       *struct {
			End   *int32 `json:"end,omitempty"`
			Start *int32 `json:"start,omitempty"`
		} `json:"line,omitempty"`
		Minute        *string `json:"minute,omitempty"`
		Month         *string `json:"month,omitempty"`
		Specification *string `json:"specification,omitempty"`
	} `json:"crontab,omitempty"`
	CurrentWorkingDirectory *string                                 `json:"current_working_directory,omitempty"`
	Deadline                *int64                                  `json:"deadline,omitempty"`
	DelayBoot               *int32                                  `json:"delay_boot,omitempty"`
	Dependency              *string                                 `json:"dependency,omitempty"`
	Distribution            *string                                 `json:"distribution,omitempty"`
	DistributionPlaneSize   *int32                                  `json:"distribution_plane_size,omitempty"`
	EndTime                 *int64                                  `json:"end_time,omitempty"`
	Environment             []string                                `json:"environment"`
	ExcludedNodes           *[]string                               `json:"excluded_nodes,omitempty"`
	Exclusive               *[]SlurmV0039UpdateJobJSONBodyExclusive `json:"exclusive,omitempty"`
	Extra                   *string                                 `json:"extra,omitempty"`
	Flags                   *[]SlurmV0039UpdateJobJSONBodyFlags     `json:"flags,omitempty"`
	GroupId                 *string                                 `json:"group_id,omitempty"`
	HetjobGroup             *int32                                  `json:"hetjob_group,omitempty"`

	// Hold Hold (true) or release (false) job
	Hold           *bool  `json:"hold,omitempty"`
	Immediate      *bool  `json:"immediate,omitempty"`
	JobId          *int32 `json:"job_id,omitempty"`
	KillOnNodeFail *bool  `json:"kill_on_node_fail,omitempty"`

	// KillWarningDelay Integer number with flags
	KillWarningDelay *struct {
		// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
		Infinite *bool `json:"infinite,omitempty"`

		// Number If set is True the number will be set with value. Otherwise ignore number contents.
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set. False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"kill_warning_delay,omitempty"`
	KillWarningFlags  *[]SlurmV0039UpdateJobJSONBodyKillWarningFlags  `json:"kill_warning_flags,omitempty"`
	KillWarningSignal *string                                         `json:"kill_warning_signal,omitempty"`
	Licenses          *string                                         `json:"licenses,omitempty"`
	MailType          *[]SlurmV0039UpdateJobJSONBodyMailType          `json:"mail_type,omitempty"`
	MailUser          *string                                         `json:"mail_user,omitempty"`
	MaximumCpus       *int32                                          `json:"maximum_cpus,omitempty"`
	MaximumNodes      *int32                                          `json:"maximum_nodes,omitempty"`
	McsLabel          *string                                         `json:"mcs_label,omitempty"`
	MemoryBinding     *string                                         `json:"memory_binding,omitempty"`
	MemoryBindingType *[]SlurmV0039UpdateJobJSONBodyMemoryBindingType `json:"memory_binding_type,omitempty"`

	// MemoryPerCpu Integer number with flags
	MemoryPerCpu *struct {
		// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
		Infinite *bool `json:"infinite,omitempty"`

		// Number If set is True the number will be set with value. Otherwise ignore number contents.
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set. False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"memory_per_cpu,omitempty"`

	// MemoryPerNode Integer number with flags
	MemoryPerNode *struct {
		// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
		Infinite *bool `json:"infinite,omitempty"`

		// Number If set is True the number will be set with value. Otherwise ignore number contents.
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set. False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"memory_per_node,omitempty"`
	MemoryPerTres          *string                                  `json:"memory_per_tres,omitempty"`
	MinimumBoardsPerNode   *int32                                   `json:"minimum_boards_per_node,omitempty"`
	MinimumCpus            *int32                                   `json:"minimum_cpus,omitempty"`
	MinimumCpusPerNode     *int32                                   `json:"minimum_cpus_per_node,omitempty"`
	MinimumNodes           *int32                                   `json:"minimum_nodes,omitempty"`
	MinimumSocketsPerBoard *int32                                   `json:"minimum_sockets_per_board,omitempty"`
	Name                   *string                                  `json:"name,omitempty"`
	Network                *string                                  `json:"network,omitempty"`
	Nice                   *int32                                   `json:"nice,omitempty"`
	Nodes                  *string                                  `json:"nodes,omitempty"`
	NtasksPerTres          *int32                                   `json:"ntasks_per_tres,omitempty"`
	OpenMode               *[]SlurmV0039UpdateJobJSONBodyOpenMode   `json:"open_mode,omitempty"`
	Overcommit             *bool                                    `json:"overcommit,omitempty"`
	Oversubscribe          *bool                                    `json:"oversubscribe,omitempty"`
	Partition              *string                                  `json:"partition,omitempty"`
	PowerFlags             *[]SlurmV0039UpdateJobJSONBodyPowerFlags `json:"power_flags,omitempty"`
	Prefer                 *string                                  `json:"prefer,omitempty"`

	// Priority Integer number with flags
	Priority *struct {
		// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
		Infinite *bool `json:"infinite,omitempty"`

		// Number If set is True the number will be set with value. Otherwise ignore number contents.
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set. False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"priority,omitempty"`
	Profile       *[]SlurmV0039UpdateJobJSONBodyProfile `json:"profile,omitempty"`
	Qos           *string                               `json:"qos,omitempty"`
	Reboot        *bool                                 `json:"reboot,omitempty"`
	Requeue       *bool                                 `json:"requeue,omitempty"`
	RequiredNodes *[]string                             `json:"required_nodes,omitempty"`

	// RequiredSwitches Integer number with flags
	RequiredSwitches *struct {
		// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
		Infinite *bool `json:"infinite,omitempty"`

		// Number If set is True the number will be set with value. Otherwise ignore number contents.
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set. False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"required_switches,omitempty"`
	Reservation          *string                              `json:"reservation,omitempty"`
	ReservePorts         *int32                               `json:"reserve_ports,omitempty"`
	Script               *string                              `json:"script,omitempty"`
	SelinuxContext       *string                              `json:"selinux_context,omitempty"`
	Shared               *[]SlurmV0039UpdateJobJSONBodyShared `json:"shared,omitempty"`
	SiteFactor           *int32                               `json:"site_factor,omitempty"`
	SocketsPerNode       *int32                               `json:"sockets_per_node,omitempty"`
	SpankEnvironment     *[]string                            `json:"spank_environment,omitempty"`
	StandardError        *string                              `json:"standard_error,omitempty"`
	StandardInput        *string                              `json:"standard_input,omitempty"`
	StandardOutput       *string                              `json:"standard_output,omitempty"`
	Tasks                *int32                               `json:"tasks,omitempty"`
	TasksPerBoard        *int32                               `json:"tasks_per_board,omitempty"`
	TasksPerCore         *int32                               `json:"tasks_per_core,omitempty"`
	TasksPerNode         *int32                               `json:"tasks_per_node,omitempty"`
	TasksPerSocket       *int32                               `json:"tasks_per_socket,omitempty"`
	TemporaryDiskPerNode *int32                               `json:"temporary_disk_per_node,omitempty"`
	ThreadSpecification  *int32                               `json:"thread_specification,omitempty"`
	ThreadsPerCore       *int32                               `json:"threads_per_core,omitempty"`

	// TimeLimit Integer number with flags
	TimeLimit *struct {
		// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
		Infinite *bool `json:"infinite,omitempty"`

		// Number If set is True the number will be set with value. Otherwise ignore number contents.
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set. False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"time_limit,omitempty"`

	// TimeMinimum Integer number with flags
	TimeMinimum *struct {
		// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
		Infinite *bool `json:"infinite,omitempty"`

		// Number If set is True the number will be set with value. Otherwise ignore number contents.
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set. False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"time_minimum,omitempty"`
	TresBind       *string                           `json:"tres_bind,omitempty"`
	TresFreq       *string                           `json:"tres_freq,omitempty"`
	TresPerJob     *string                           `json:"tres_per_job,omitempty"`
	TresPerNode    *string                           `json:"tres_per_node,omitempty"`
	TresPerSocket  *string                           `json:"tres_per_socket,omitempty"`
	TresPerTask    *string                           `json:"tres_per_task,omitempty"`
	UserId         *string                           `json:"user_id,omitempty"`
	WaitAllNodes   *bool                             `json:"wait_all_nodes,omitempty"`
	WaitForSwitch  *int32                            `json:"wait_for_switch,omitempty"`
	Wckey          *string                           `json:"wckey,omitempty"`
	X11            *[]SlurmV0039UpdateJobJSONBodyX11 `json:"x11,omitempty"`
	X11MagicCookie *string                           `json:"x11_magic_cookie,omitempty"`
	X11TargetHost  *string                           `json:"x11_target_host,omitempty"`
	X11TargetPort  *int32                            `json:"x11_target_port,omitempty"`
}

// SlurmV0039UpdateJobJSONBodyCpuBindingFlags defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyCpuBindingFlags string

// SlurmV0039UpdateJobJSONBodyCrontabFlags defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyCrontabFlags string

// SlurmV0039UpdateJobJSONBodyExclusive defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyExclusive string

// SlurmV0039UpdateJobJSONBodyFlags defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyFlags string

// SlurmV0039UpdateJobJSONBodyKillWarningFlags defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyKillWarningFlags string

// SlurmV0039UpdateJobJSONBodyMailType defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyMailType string

// SlurmV0039UpdateJobJSONBodyMemoryBindingType defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyMemoryBindingType string

// SlurmV0039UpdateJobJSONBodyOpenMode defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyOpenMode string

// SlurmV0039UpdateJobJSONBodyPowerFlags defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyPowerFlags string

// SlurmV0039UpdateJobJSONBodyProfile defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyProfile string

// SlurmV0039UpdateJobJSONBodyShared defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyShared string

// SlurmV0039UpdateJobJSONBodyX11 defines parameters for SlurmV0039UpdateJob.
type SlurmV0039UpdateJobJSONBodyX11 string

// SlurmV0039GetJobsParams defines parameters for SlurmV0039GetJobs.
type SlurmV0039GetJobsParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0039UpdateNodeJSONBody defines parameters for SlurmV0039UpdateNode.
type SlurmV0039UpdateNodeJSONBody struct {
	Address *[]string `json:"address,omitempty"`

	// Comment arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// CpuBind default CPU binding type
	CpuBind *int32 `json:"cpu_bind,omitempty"`

	// Extra arbitrary string
	Extra       *string   `json:"extra,omitempty"`
	Features    *[]string `json:"features,omitempty"`
	FeaturesAct *[]string `json:"features_act,omitempty"`

	// Gres new generic resources for node
	Gres     *string   `json:"gres,omitempty"`
	Hostname *[]string `json:"hostname,omitempty"`
	Name     *[]string `json:"name,omitempty"`

	// Reason reason for node being DOWN or DRAINING
	Reason *string `json:"reason,omitempty"`

	// ReasonUid user ID of sending (needed if user root is sending message)
	ReasonUid *string `json:"reason_uid,omitempty"`

	// ResumeAfter Integer number with flags
	ResumeAfter *struct {
		// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
		Infinite *bool `json:"infinite,omitempty"`

		// Number If set is True the number will be set with value. Otherwise ignore number contents.
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set. False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"resume_after,omitempty"`

	// State assign new node state
	State *[]SlurmV0039UpdateNodeJSONBodyState `json:"state,omitempty"`

	// Weight Integer number with flags
	Weight *struct {
		// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
		Infinite *bool `json:"infinite,omitempty"`

		// Number If set is True the number will be set with value. Otherwise ignore number contents.
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set. False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"weight,omitempty"`
}

// SlurmV0039UpdateNodeJSONBodyState defines parameters for SlurmV0039UpdateNode.
type SlurmV0039UpdateNodeJSONBodyState string

// SlurmV0039GetNodesParams defines parameters for SlurmV0039GetNodes.
type SlurmV0039GetNodesParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0039GetPartitionParams defines parameters for SlurmV0039GetPartition.
type SlurmV0039GetPartitionParams struct {
	// UpdateTime Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0039GetPartitionsParams defines parameters for SlurmV0039GetPartitions.
type SlurmV0039GetPartitionsParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0039GetReservationParams defines parameters for SlurmV0039GetReservation.
type SlurmV0039GetReservationParams struct {
	// UpdateTime Filter if no reservation (not limited to reservation in URL) changed since update_time.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0039GetReservationsParams defines parameters for SlurmV0039GetReservations.
type SlurmV0039GetReservationsParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0039SubmitJobJSONRequestBody defines body for SlurmV0039SubmitJob for application/json ContentType.
type SlurmV0039SubmitJobJSONRequestBody SlurmV0039SubmitJobJSONBody

// SlurmV0039UpdateJobJSONRequestBody defines body for SlurmV0039UpdateJob for application/json ContentType.
type SlurmV0039UpdateJobJSONRequestBody SlurmV0039UpdateJobJSONBody

// SlurmV0039UpdateNodeJSONRequestBody defines body for SlurmV0039UpdateNode for application/json ContentType.
type SlurmV0039UpdateNodeJSONRequestBody SlurmV0039UpdateNodeJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetOpenapi request
	GetOpenapi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenapiJson request
	GetOpenapiJson(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenapiYaml request
	GetOpenapiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenapiV3 request
	GetOpenapiV3(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039Diag request
	SlurmV0039Diag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039SubmitJobWithBody request with any body
	SlurmV0039SubmitJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0039SubmitJob(ctx context.Context, body SlurmV0039SubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039CancelJob request
	SlurmV0039CancelJob(ctx context.Context, jobId string, params *SlurmV0039CancelJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039GetJob request
	SlurmV0039GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039UpdateJobWithBody request with any body
	SlurmV0039UpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0039UpdateJob(ctx context.Context, jobId string, body SlurmV0039UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039GetJobs request
	SlurmV0039GetJobs(ctx context.Context, params *SlurmV0039GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039SlurmctldGetLicenses request
	SlurmV0039SlurmctldGetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039DeleteNode request
	SlurmV0039DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039GetNode request
	SlurmV0039GetNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039UpdateNodeWithBody request with any body
	SlurmV0039UpdateNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0039UpdateNode(ctx context.Context, nodeName string, body SlurmV0039UpdateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039GetNodes request
	SlurmV0039GetNodes(ctx context.Context, params *SlurmV0039GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039GetPartition request
	SlurmV0039GetPartition(ctx context.Context, partitionName string, params *SlurmV0039GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039GetPartitions request
	SlurmV0039GetPartitions(ctx context.Context, params *SlurmV0039GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039Ping request
	SlurmV0039Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039GetReservation request
	SlurmV0039GetReservation(ctx context.Context, reservationName string, params *SlurmV0039GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0039GetReservations request
	SlurmV0039GetReservations(ctx context.Context, params *SlurmV0039GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetOpenapi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenapiJson(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiJsonRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenapiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiYamlRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenapiV3(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiV3Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039Diag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039DiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039SubmitJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039SubmitJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039SubmitJob(ctx context.Context, body SlurmV0039SubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039SubmitJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039CancelJob(ctx context.Context, jobId string, params *SlurmV0039CancelJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039CancelJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039GetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039UpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039UpdateJobRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039UpdateJob(ctx context.Context, jobId string, body SlurmV0039UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039UpdateJobRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039GetJobs(ctx context.Context, params *SlurmV0039GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039SlurmctldGetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039SlurmctldGetLicensesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039DeleteNodeRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039GetNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039GetNodeRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039UpdateNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039UpdateNodeRequestWithBody(c.Server, nodeName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039UpdateNode(ctx context.Context, nodeName string, body SlurmV0039UpdateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039UpdateNodeRequest(c.Server, nodeName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039GetNodes(ctx context.Context, params *SlurmV0039GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039GetNodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039GetPartition(ctx context.Context, partitionName string, params *SlurmV0039GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039GetPartitionRequest(c.Server, partitionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039GetPartitions(ctx context.Context, params *SlurmV0039GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039GetPartitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039PingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039GetReservation(ctx context.Context, reservationName string, params *SlurmV0039GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039GetReservationRequest(c.Server, reservationName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0039GetReservations(ctx context.Context, params *SlurmV0039GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0039GetReservationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetOpenapiRequest generates requests for GetOpenapi
func NewGetOpenapiRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenapiJsonRequest generates requests for GetOpenapiJson
func NewGetOpenapiJsonRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenapiYamlRequest generates requests for GetOpenapiYaml
func NewGetOpenapiYamlRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi.yaml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenapiV3Request generates requests for GetOpenapiV3
func NewGetOpenapiV3Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi/v3")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039DiagRequest generates requests for SlurmV0039Diag
func NewSlurmV0039DiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/diag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039SubmitJobRequest calls the generic SlurmV0039SubmitJob builder with application/json body
func NewSlurmV0039SubmitJobRequest(server string, body SlurmV0039SubmitJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0039SubmitJobRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0039SubmitJobRequestWithBody generates requests for SlurmV0039SubmitJob with any type of body
func NewSlurmV0039SubmitJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/job/submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0039CancelJobRequest generates requests for SlurmV0039CancelJob
func NewSlurmV0039CancelJobRequest(server string, jobId string, params *SlurmV0039CancelJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Signal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signal", runtime.ParamLocationQuery, *params.Signal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039GetJobRequest generates requests for SlurmV0039GetJob
func NewSlurmV0039GetJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039UpdateJobRequest calls the generic SlurmV0039UpdateJob builder with application/json body
func NewSlurmV0039UpdateJobRequest(server string, jobId string, body SlurmV0039UpdateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0039UpdateJobRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewSlurmV0039UpdateJobRequestWithBody generates requests for SlurmV0039UpdateJob with any type of body
func NewSlurmV0039UpdateJobRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0039GetJobsRequest generates requests for SlurmV0039GetJobs
func NewSlurmV0039GetJobsRequest(server string, params *SlurmV0039GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039SlurmctldGetLicensesRequest generates requests for SlurmV0039SlurmctldGetLicenses
func NewSlurmV0039SlurmctldGetLicensesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/licenses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039DeleteNodeRequest generates requests for SlurmV0039DeleteNode
func NewSlurmV0039DeleteNodeRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039GetNodeRequest generates requests for SlurmV0039GetNode
func NewSlurmV0039GetNodeRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039UpdateNodeRequest calls the generic SlurmV0039UpdateNode builder with application/json body
func NewSlurmV0039UpdateNodeRequest(server string, nodeName string, body SlurmV0039UpdateNodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0039UpdateNodeRequestWithBody(server, nodeName, "application/json", bodyReader)
}

// NewSlurmV0039UpdateNodeRequestWithBody generates requests for SlurmV0039UpdateNode with any type of body
func NewSlurmV0039UpdateNodeRequestWithBody(server string, nodeName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0039GetNodesRequest generates requests for SlurmV0039GetNodes
func NewSlurmV0039GetNodesRequest(server string, params *SlurmV0039GetNodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/nodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039GetPartitionRequest generates requests for SlurmV0039GetPartition
func NewSlurmV0039GetPartitionRequest(server string, partitionName string, params *SlurmV0039GetPartitionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "partition_name", runtime.ParamLocationPath, partitionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/partition/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039GetPartitionsRequest generates requests for SlurmV0039GetPartitions
func NewSlurmV0039GetPartitionsRequest(server string, params *SlurmV0039GetPartitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/partitions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039PingRequest generates requests for SlurmV0039Ping
func NewSlurmV0039PingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039GetReservationRequest generates requests for SlurmV0039GetReservation
func NewSlurmV0039GetReservationRequest(server string, reservationName string, params *SlurmV0039GetReservationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservation_name", runtime.ParamLocationPath, reservationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0039GetReservationsRequest generates requests for SlurmV0039GetReservations
func NewSlurmV0039GetReservationsRequest(server string, params *SlurmV0039GetReservationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.39/reservations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetOpenapiWithResponse request
	GetOpenapiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiResponse, error)

	// GetOpenapiJsonWithResponse request
	GetOpenapiJsonWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiJsonResponse, error)

	// GetOpenapiYamlWithResponse request
	GetOpenapiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiYamlResponse, error)

	// GetOpenapiV3WithResponse request
	GetOpenapiV3WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiV3Response, error)

	// SlurmV0039DiagWithResponse request
	SlurmV0039DiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0039DiagResponse, error)

	// SlurmV0039SubmitJobWithBodyWithResponse request with any body
	SlurmV0039SubmitJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0039SubmitJobResponse, error)

	SlurmV0039SubmitJobWithResponse(ctx context.Context, body SlurmV0039SubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0039SubmitJobResponse, error)

	// SlurmV0039CancelJobWithResponse request
	SlurmV0039CancelJobWithResponse(ctx context.Context, jobId string, params *SlurmV0039CancelJobParams, reqEditors ...RequestEditorFn) (*SlurmV0039CancelJobResponse, error)

	// SlurmV0039GetJobWithResponse request
	SlurmV0039GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmV0039GetJobResponse, error)

	// SlurmV0039UpdateJobWithBodyWithResponse request with any body
	SlurmV0039UpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0039UpdateJobResponse, error)

	SlurmV0039UpdateJobWithResponse(ctx context.Context, jobId string, body SlurmV0039UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0039UpdateJobResponse, error)

	// SlurmV0039GetJobsWithResponse request
	SlurmV0039GetJobsWithResponse(ctx context.Context, params *SlurmV0039GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetJobsResponse, error)

	// SlurmV0039SlurmctldGetLicensesWithResponse request
	SlurmV0039SlurmctldGetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0039SlurmctldGetLicensesResponse, error)

	// SlurmV0039DeleteNodeWithResponse request
	SlurmV0039DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0039DeleteNodeResponse, error)

	// SlurmV0039GetNodeWithResponse request
	SlurmV0039GetNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0039GetNodeResponse, error)

	// SlurmV0039UpdateNodeWithBodyWithResponse request with any body
	SlurmV0039UpdateNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0039UpdateNodeResponse, error)

	SlurmV0039UpdateNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0039UpdateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0039UpdateNodeResponse, error)

	// SlurmV0039GetNodesWithResponse request
	SlurmV0039GetNodesWithResponse(ctx context.Context, params *SlurmV0039GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetNodesResponse, error)

	// SlurmV0039GetPartitionWithResponse request
	SlurmV0039GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0039GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetPartitionResponse, error)

	// SlurmV0039GetPartitionsWithResponse request
	SlurmV0039GetPartitionsWithResponse(ctx context.Context, params *SlurmV0039GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetPartitionsResponse, error)

	// SlurmV0039PingWithResponse request
	SlurmV0039PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0039PingResponse, error)

	// SlurmV0039GetReservationWithResponse request
	SlurmV0039GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0039GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetReservationResponse, error)

	// SlurmV0039GetReservationsWithResponse request
	SlurmV0039GetReservationsWithResponse(ctx context.Context, params *SlurmV0039GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetReservationsResponse, error)
}

type GetOpenapiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenapiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenapiJsonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenapiJsonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiJsonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenapiYamlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenapiYamlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiYamlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenapiV3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenapiV3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiV3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039DiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Statistics *struct {
			AgentCount           *int32 `json:"agent_count,omitempty"`
			AgentQueueSize       *int32 `json:"agent_queue_size,omitempty"`
			AgentThreadCount     *int32 `json:"agent_thread_count,omitempty"`
			BfActive             *bool  `json:"bf_active,omitempty"`
			BfBackfilledHetJobs  *int32 `json:"bf_backfilled_het_jobs,omitempty"`
			BfBackfilledJobs     *int32 `json:"bf_backfilled_jobs,omitempty"`
			BfCycleCounter       *int32 `json:"bf_cycle_counter,omitempty"`
			BfCycleLast          *int32 `json:"bf_cycle_last,omitempty"`
			BfCycleMean          *int64 `json:"bf_cycle_mean,omitempty"`
			BfCycleSum           *int64 `json:"bf_cycle_sum,omitempty"`
			BfDepthMean          *int64 `json:"bf_depth_mean,omitempty"`
			BfDepthMeanTry       *int64 `json:"bf_depth_mean_try,omitempty"`
			BfDepthSum           *int32 `json:"bf_depth_sum,omitempty"`
			BfDepthTrySum        *int32 `json:"bf_depth_try_sum,omitempty"`
			BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`
			BfLastDepth          *int32 `json:"bf_last_depth,omitempty"`
			BfLastDepthTry       *int32 `json:"bf_last_depth_try,omitempty"`
			BfQueueLen           *int32 `json:"bf_queue_len,omitempty"`
			BfQueueLenMean       *int64 `json:"bf_queue_len_mean,omitempty"`
			BfQueueLenSum        *int32 `json:"bf_queue_len_sum,omitempty"`
			BfTableSize          *int32 `json:"bf_table_size,omitempty"`
			BfTableSizeMean      *int64 `json:"bf_table_size_mean,omitempty"`
			BfWhenLastCycle      *int64 `json:"bf_when_last_cycle,omitempty"`
			DbdAgentQueueSize    *int32 `json:"dbd_agent_queue_size,omitempty"`
			GettimeofdayLatency  *int32 `json:"gettimeofday_latency,omitempty"`
			JobStatesTs          *int64 `json:"job_states_ts,omitempty"`
			JobsCanceled         *int32 `json:"jobs_canceled,omitempty"`
			JobsCompleted        *int32 `json:"jobs_completed,omitempty"`
			JobsFailed           *int32 `json:"jobs_failed,omitempty"`
			JobsPending          *int32 `json:"jobs_pending,omitempty"`
			JobsRunning          *int32 `json:"jobs_running,omitempty"`
			JobsStarted          *int32 `json:"jobs_started,omitempty"`
			JobsSubmitted        *int32 `json:"jobs_submitted,omitempty"`
			PartsPacked          *int32 `json:"parts_packed,omitempty"`
			ReqTime              *int64 `json:"req_time,omitempty"`
			ReqTimeStart         *int64 `json:"req_time_start,omitempty"`

			// RpcsByMessageType RPCs by message type
			RpcsByMessageType *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime *int64 `json:"average_time,omitempty"`

				// Count Number of RPCs received
				Count *int64 `json:"count,omitempty"`

				// MessageType Message type as string
				MessageType *string `json:"message_type,omitempty"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime *int64 `json:"total_time,omitempty"`

				// TypeId Message type as integer
				TypeId *int32 `json:"type_id,omitempty"`
			} `json:"rpcs_by_message_type,omitempty"`

			// RpcsByUser RPCs by user
			RpcsByUser *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime *int64 `json:"average_time,omitempty"`

				// Count Number of RPCs received
				Count *int64 `json:"count,omitempty"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime *int64 `json:"total_time,omitempty"`

				// User user name
				User *string `json:"user,omitempty"`

				// UserId user id (numeric)
				UserId *int32 `json:"user_id,omitempty"`
			} `json:"rpcs_by_user,omitempty"`
			ScheduleCycleLast      *int32 `json:"schedule_cycle_last,omitempty"`
			ScheduleCycleMax       *int32 `json:"schedule_cycle_max,omitempty"`
			ScheduleCycleMean      *int64 `json:"schedule_cycle_mean,omitempty"`
			ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`
			ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`
			ScheduleCycleTotal     *int32 `json:"schedule_cycle_total,omitempty"`
			ScheduleQueueLength    *int32 `json:"schedule_queue_length,omitempty"`
			ServerThreadCount      *int32 `json:"server_thread_count,omitempty"`
		} `json:"statistics,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Statistics *struct {
			AgentCount           *int32 `json:"agent_count,omitempty"`
			AgentQueueSize       *int32 `json:"agent_queue_size,omitempty"`
			AgentThreadCount     *int32 `json:"agent_thread_count,omitempty"`
			BfActive             *bool  `json:"bf_active,omitempty"`
			BfBackfilledHetJobs  *int32 `json:"bf_backfilled_het_jobs,omitempty"`
			BfBackfilledJobs     *int32 `json:"bf_backfilled_jobs,omitempty"`
			BfCycleCounter       *int32 `json:"bf_cycle_counter,omitempty"`
			BfCycleLast          *int32 `json:"bf_cycle_last,omitempty"`
			BfCycleMean          *int64 `json:"bf_cycle_mean,omitempty"`
			BfCycleSum           *int64 `json:"bf_cycle_sum,omitempty"`
			BfDepthMean          *int64 `json:"bf_depth_mean,omitempty"`
			BfDepthMeanTry       *int64 `json:"bf_depth_mean_try,omitempty"`
			BfDepthSum           *int32 `json:"bf_depth_sum,omitempty"`
			BfDepthTrySum        *int32 `json:"bf_depth_try_sum,omitempty"`
			BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`
			BfLastDepth          *int32 `json:"bf_last_depth,omitempty"`
			BfLastDepthTry       *int32 `json:"bf_last_depth_try,omitempty"`
			BfQueueLen           *int32 `json:"bf_queue_len,omitempty"`
			BfQueueLenMean       *int64 `json:"bf_queue_len_mean,omitempty"`
			BfQueueLenSum        *int32 `json:"bf_queue_len_sum,omitempty"`
			BfTableSize          *int32 `json:"bf_table_size,omitempty"`
			BfTableSizeMean      *int64 `json:"bf_table_size_mean,omitempty"`
			BfWhenLastCycle      *int64 `json:"bf_when_last_cycle,omitempty"`
			DbdAgentQueueSize    *int32 `json:"dbd_agent_queue_size,omitempty"`
			GettimeofdayLatency  *int32 `json:"gettimeofday_latency,omitempty"`
			JobStatesTs          *int64 `json:"job_states_ts,omitempty"`
			JobsCanceled         *int32 `json:"jobs_canceled,omitempty"`
			JobsCompleted        *int32 `json:"jobs_completed,omitempty"`
			JobsFailed           *int32 `json:"jobs_failed,omitempty"`
			JobsPending          *int32 `json:"jobs_pending,omitempty"`
			JobsRunning          *int32 `json:"jobs_running,omitempty"`
			JobsStarted          *int32 `json:"jobs_started,omitempty"`
			JobsSubmitted        *int32 `json:"jobs_submitted,omitempty"`
			PartsPacked          *int32 `json:"parts_packed,omitempty"`
			ReqTime              *int64 `json:"req_time,omitempty"`
			ReqTimeStart         *int64 `json:"req_time_start,omitempty"`

			// RpcsByMessageType RPCs by message type
			RpcsByMessageType *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime *int64 `json:"average_time,omitempty"`

				// Count Number of RPCs received
				Count *int64 `json:"count,omitempty"`

				// MessageType Message type as string
				MessageType *string `json:"message_type,omitempty"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime *int64 `json:"total_time,omitempty"`

				// TypeId Message type as integer
				TypeId *int32 `json:"type_id,omitempty"`
			} `json:"rpcs_by_message_type,omitempty"`

			// RpcsByUser RPCs by user
			RpcsByUser *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime *int64 `json:"average_time,omitempty"`

				// Count Number of RPCs received
				Count *int64 `json:"count,omitempty"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime *int64 `json:"total_time,omitempty"`

				// User user name
				User *string `json:"user,omitempty"`

				// UserId user id (numeric)
				UserId *int32 `json:"user_id,omitempty"`
			} `json:"rpcs_by_user,omitempty"`
			ScheduleCycleLast      *int32 `json:"schedule_cycle_last,omitempty"`
			ScheduleCycleMax       *int32 `json:"schedule_cycle_max,omitempty"`
			ScheduleCycleMean      *int64 `json:"schedule_cycle_mean,omitempty"`
			ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`
			ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`
			ScheduleCycleTotal     *int32 `json:"schedule_cycle_total,omitempty"`
			ScheduleQueueLength    *int32 `json:"schedule_queue_length,omitempty"`
			ServerThreadCount      *int32 `json:"server_thread_count,omitempty"`
		} `json:"statistics,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0039DiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039DiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039SubmitJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId new job ID
		JobId *int `json:"job_id,omitempty"`

		// JobSubmitUserMsg Message to user from job_submit plugin
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`
		Meta             *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// StepId new job step ID
		StepId *string `json:"step_id,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId new job ID
		JobId *int `json:"job_id,omitempty"`

		// JobSubmitUserMsg Message to user from job_submit plugin
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`
		Meta             *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// StepId new job step ID
		StepId *string `json:"step_id,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0039SubmitJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039SubmitJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039CancelJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0039CancelJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039CancelJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Jobs *[]struct {
			Account        *string `json:"account,omitempty"`
			AccrueTime     *int64  `json:"accrue_time,omitempty"`
			AdminComment   *string `json:"admin_comment,omitempty"`
			AllocatingNode *string `json:"allocating_node,omitempty"`

			// ArrayJobId Integer number with flags
			ArrayJobId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_job_id,omitempty"`

			// ArrayMaxTasks Integer number with flags
			ArrayMaxTasks *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_max_tasks,omitempty"`

			// ArrayTaskId Integer number with flags
			ArrayTaskId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_task_id,omitempty"`
			ArrayTaskString *string `json:"array_task_string,omitempty"`
			AssociationId   *int32  `json:"association_id,omitempty"`
			BatchFeatures   *string `json:"batch_features,omitempty"`
			BatchFlag       *bool   `json:"batch_flag,omitempty"`
			BatchHost       *string `json:"batch_host,omitempty"`

			// BillableTres 64 bit floating point number with flags
			BillableTres *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"billable_tres,omitempty"`
			BurstBuffer      *string `json:"burst_buffer,omitempty"`
			BurstBufferState *string `json:"burst_buffer_state,omitempty"`
			Cluster          *string `json:"cluster,omitempty"`
			ClusterFeatures  *string `json:"cluster_features,omitempty"`
			Command          *string `json:"command,omitempty"`
			Comment          *string `json:"comment,omitempty"`
			Container        *string `json:"container,omitempty"`
			ContainerId      *string `json:"container_id,omitempty"`
			Contiguous       *bool   `json:"contiguous,omitempty"`
			CoreSpec         *int32  `json:"core_spec,omitempty"`

			// CoresPerSocket Integer number with flags
			CoresPerSocket *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cores_per_socket,omitempty"`

			// CpuFrequencyGovernor Integer number with flags
			CpuFrequencyGovernor *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_governor,omitempty"`

			// CpuFrequencyMaximum Integer number with flags
			CpuFrequencyMaximum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_maximum,omitempty"`

			// CpuFrequencyMinimum Integer number with flags
			CpuFrequencyMinimum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_minimum,omitempty"`

			// Cpus Integer number with flags
			Cpus *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus,omitempty"`

			// CpusPerTask Integer number with flags
			CpusPerTask *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus_per_task,omitempty"`
			CpusPerTres             *string `json:"cpus_per_tres,omitempty"`
			Cron                    *string `json:"cron,omitempty"`
			CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`
			Deadline                *int64  `json:"deadline,omitempty"`

			// DelayBoot Integer number with flags
			DelayBoot *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"delay_boot,omitempty"`
			Dependency *string `json:"dependency,omitempty"`

			// DerivedExitCode Integer number with flags
			DerivedExitCode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"derived_exit_code,omitempty"`
			EligibleTime  *int64                              `json:"eligible_time,omitempty"`
			EndTime       *int64                              `json:"end_time,omitempty"`
			ExcludedNodes *string                             `json:"excluded_nodes,omitempty"`
			Exclusive     *[]SlurmV0039GetJob200JobsExclusive `json:"exclusive,omitempty"`

			// ExitCode Integer number with flags
			ExitCode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"exit_code,omitempty"`
			Extra                    *string                         `json:"extra,omitempty"`
			FailedNode               *string                         `json:"failed_node,omitempty"`
			Features                 *string                         `json:"features,omitempty"`
			FederationOrigin         *string                         `json:"federation_origin,omitempty"`
			FederationSiblingsActive *string                         `json:"federation_siblings_active,omitempty"`
			FederationSiblingsViable *string                         `json:"federation_siblings_viable,omitempty"`
			Flags                    *[]SlurmV0039GetJob200JobsFlags `json:"flags,omitempty"`
			GresDetail               *[]string                       `json:"gres_detail,omitempty"`
			GroupId                  *int32                          `json:"group_id,omitempty"`
			GroupName                *string                         `json:"group_name,omitempty"`

			// HetJobId Integer number with flags
			HetJobId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"het_job_id,omitempty"`
			HetJobIdSet *string `json:"het_job_id_set,omitempty"`

			// HetJobOffset Integer number with flags
			HetJobOffset *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"het_job_offset,omitempty"`

			// Hold Hold (true) or release (false) job
			Hold         *bool  `json:"hold,omitempty"`
			JobId        *int32 `json:"job_id,omitempty"`
			JobResources *struct {
				AllocatedCores *int32 `json:"allocated_cores,omitempty"`
				AllocatedCpus  *int32 `json:"allocated_cpus,omitempty"`
				AllocatedHosts *int32 `json:"allocated_hosts,omitempty"`

				// AllocatedNodes job node resources
				AllocatedNodes *[]interface{} `json:"allocated_nodes,omitempty"`
				Nodes          *string        `json:"nodes,omitempty"`
			} `json:"job_resources,omitempty"`
			JobSizeStr          *[]string                          `json:"job_size_str,omitempty"`
			JobState            *string                            `json:"job_state,omitempty"`
			LastSchedEvaluation *int64                             `json:"last_sched_evaluation,omitempty"`
			Licenses            *string                            `json:"licenses,omitempty"`
			MailType            *[]SlurmV0039GetJob200JobsMailType `json:"mail_type,omitempty"`
			MailUser            *string                            `json:"mail_user,omitempty"`

			// MaxCpus Integer number with flags
			MaxCpus *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"max_cpus,omitempty"`

			// MaxNodes Integer number with flags
			MaxNodes *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"max_nodes,omitempty"`
			MaximumSwitchWaitTime *int32  `json:"maximum_switch_wait_time,omitempty"`
			McsLabel              *string `json:"mcs_label,omitempty"`

			// MemoryPerCpu Integer number with flags
			MemoryPerCpu *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_cpu,omitempty"`

			// MemoryPerNode Integer number with flags
			MemoryPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_node,omitempty"`
			MemoryPerTres *string `json:"memory_per_tres,omitempty"`

			// MinimumCpusPerNode Integer number with flags
			MinimumCpusPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minimum_cpus_per_node,omitempty"`
			MinimumSwitches *int32 `json:"minimum_switches,omitempty"`

			// MinimumTmpDiskPerNode Integer number with flags
			MinimumTmpDiskPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minimum_tmp_disk_per_node,omitempty"`
			Name    *string `json:"name,omitempty"`
			Network *string `json:"network,omitempty"`
			Nice    *int32  `json:"nice,omitempty"`

			// NodeCount Integer number with flags
			NodeCount *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"node_count,omitempty"`
			Nodes         *string `json:"nodes,omitempty"`
			Oversubscribe *bool   `json:"oversubscribe,omitempty"`
			Partition     *string `json:"partition,omitempty"`
			Power         *struct {
				Flags *[]SlurmV0039GetJob200JobsPowerFlags `json:"flags,omitempty"`
			} `json:"power,omitempty"`
			PreSusTime      *int64  `json:"pre_sus_time,omitempty"`
			PreemptTime     *int64  `json:"preempt_time,omitempty"`
			PreemptableTime *int64  `json:"preemptable_time,omitempty"`
			Prefer          *string `json:"prefer,omitempty"`

			// Priority Integer number with flags
			Priority *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority,omitempty"`
			Profile         *[]SlurmV0039GetJob200JobsProfile   `json:"profile,omitempty"`
			Qos             *string                             `json:"qos,omitempty"`
			Reboot          *bool                               `json:"reboot,omitempty"`
			Requeue         *bool                               `json:"requeue,omitempty"`
			RequiredNodes   *string                             `json:"required_nodes,omitempty"`
			ResizeTime      *int64                              `json:"resize_time,omitempty"`
			RestartCnt      *int32                              `json:"restart_cnt,omitempty"`
			ResvName        *string                             `json:"resv_name,omitempty"`
			ScheduledNodes  *string                             `json:"scheduled_nodes,omitempty"`
			SelinuxContext  *string                             `json:"selinux_context,omitempty"`
			Shared          *[]SlurmV0039GetJob200JobsShared    `json:"shared,omitempty"`
			ShowFlags       *[]SlurmV0039GetJob200JobsShowFlags `json:"show_flags,omitempty"`
			SocketsPerBoard *int32                              `json:"sockets_per_board,omitempty"`

			// SocketsPerNode Integer number with flags
			SocketsPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"sockets_per_node,omitempty"`
			StandardError    *string `json:"standard_error,omitempty"`
			StandardInput    *string `json:"standard_input,omitempty"`
			StandardOutput   *string `json:"standard_output,omitempty"`
			StartTime        *int64  `json:"start_time,omitempty"`
			StateDescription *string `json:"state_description,omitempty"`
			StateReason      *string `json:"state_reason,omitempty"`
			SubmitTime       *int64  `json:"submit_time,omitempty"`
			SuspendTime      *int64  `json:"suspend_time,omitempty"`
			SystemComment    *string `json:"system_comment,omitempty"`

			// Tasks Integer number with flags
			Tasks *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks,omitempty"`

			// TasksPerBoard Integer number with flags
			TasksPerBoard *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_board,omitempty"`

			// TasksPerCore Integer number with flags
			TasksPerCore *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_core,omitempty"`

			// TasksPerNode Integer number with flags
			TasksPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_node,omitempty"`

			// TasksPerSocket Integer number with flags
			TasksPerSocket *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_socket,omitempty"`

			// TasksPerTres Integer number with flags
			TasksPerTres *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_tres,omitempty"`
			ThreadSpec *int32 `json:"thread_spec,omitempty"`

			// ThreadsPerCore Integer number with flags
			ThreadsPerCore *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"threads_per_core,omitempty"`

			// TimeLimit Integer number with flags
			TimeLimit *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time_limit,omitempty"`

			// TimeMinimum Integer number with flags
			TimeMinimum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time_minimum,omitempty"`
			TresAllocStr  *string `json:"tres_alloc_str,omitempty"`
			TresBind      *string `json:"tres_bind,omitempty"`
			TresFreq      *string `json:"tres_freq,omitempty"`
			TresPerJob    *string `json:"tres_per_job,omitempty"`
			TresPerNode   *string `json:"tres_per_node,omitempty"`
			TresPerSocket *string `json:"tres_per_socket,omitempty"`
			TresPerTask   *string `json:"tres_per_task,omitempty"`
			TresReqStr    *string `json:"tres_req_str,omitempty"`
			UserId        *int32  `json:"user_id,omitempty"`
			UserName      *string `json:"user_name,omitempty"`
			Wckey         *string `json:"wckey,omitempty"`
		} `json:"jobs,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Jobs *[]struct {
			Account        *string `json:"account,omitempty"`
			AccrueTime     *int64  `json:"accrue_time,omitempty"`
			AdminComment   *string `json:"admin_comment,omitempty"`
			AllocatingNode *string `json:"allocating_node,omitempty"`

			// ArrayJobId Integer number with flags
			ArrayJobId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_job_id,omitempty"`

			// ArrayMaxTasks Integer number with flags
			ArrayMaxTasks *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_max_tasks,omitempty"`

			// ArrayTaskId Integer number with flags
			ArrayTaskId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_task_id,omitempty"`
			ArrayTaskString *string `json:"array_task_string,omitempty"`
			AssociationId   *int32  `json:"association_id,omitempty"`
			BatchFeatures   *string `json:"batch_features,omitempty"`
			BatchFlag       *bool   `json:"batch_flag,omitempty"`
			BatchHost       *string `json:"batch_host,omitempty"`

			// BillableTres 64 bit floating point number with flags
			BillableTres *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"billable_tres,omitempty"`
			BurstBuffer      *string `json:"burst_buffer,omitempty"`
			BurstBufferState *string `json:"burst_buffer_state,omitempty"`
			Cluster          *string `json:"cluster,omitempty"`
			ClusterFeatures  *string `json:"cluster_features,omitempty"`
			Command          *string `json:"command,omitempty"`
			Comment          *string `json:"comment,omitempty"`
			Container        *string `json:"container,omitempty"`
			ContainerId      *string `json:"container_id,omitempty"`
			Contiguous       *bool   `json:"contiguous,omitempty"`
			CoreSpec         *int32  `json:"core_spec,omitempty"`

			// CoresPerSocket Integer number with flags
			CoresPerSocket *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cores_per_socket,omitempty"`

			// CpuFrequencyGovernor Integer number with flags
			CpuFrequencyGovernor *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_governor,omitempty"`

			// CpuFrequencyMaximum Integer number with flags
			CpuFrequencyMaximum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_maximum,omitempty"`

			// CpuFrequencyMinimum Integer number with flags
			CpuFrequencyMinimum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_minimum,omitempty"`

			// Cpus Integer number with flags
			Cpus *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus,omitempty"`

			// CpusPerTask Integer number with flags
			CpusPerTask *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus_per_task,omitempty"`
			CpusPerTres             *string `json:"cpus_per_tres,omitempty"`
			Cron                    *string `json:"cron,omitempty"`
			CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`
			Deadline                *int64  `json:"deadline,omitempty"`

			// DelayBoot Integer number with flags
			DelayBoot *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"delay_boot,omitempty"`
			Dependency *string `json:"dependency,omitempty"`

			// DerivedExitCode Integer number with flags
			DerivedExitCode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"derived_exit_code,omitempty"`
			EligibleTime  *int64                              `json:"eligible_time,omitempty"`
			EndTime       *int64                              `json:"end_time,omitempty"`
			ExcludedNodes *string                             `json:"excluded_nodes,omitempty"`
			Exclusive     *[]SlurmV0039GetJob200JobsExclusive `json:"exclusive,omitempty"`

			// ExitCode Integer number with flags
			ExitCode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"exit_code,omitempty"`
			Extra                    *string                         `json:"extra,omitempty"`
			FailedNode               *string                         `json:"failed_node,omitempty"`
			Features                 *string                         `json:"features,omitempty"`
			FederationOrigin         *string                         `json:"federation_origin,omitempty"`
			FederationSiblingsActive *string                         `json:"federation_siblings_active,omitempty"`
			FederationSiblingsViable *string                         `json:"federation_siblings_viable,omitempty"`
			Flags                    *[]SlurmV0039GetJob200JobsFlags `json:"flags,omitempty"`
			GresDetail               *[]string                       `json:"gres_detail,omitempty"`
			GroupId                  *int32                          `json:"group_id,omitempty"`
			GroupName                *string                         `json:"group_name,omitempty"`

			// HetJobId Integer number with flags
			HetJobId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"het_job_id,omitempty"`
			HetJobIdSet *string `json:"het_job_id_set,omitempty"`

			// HetJobOffset Integer number with flags
			HetJobOffset *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"het_job_offset,omitempty"`

			// Hold Hold (true) or release (false) job
			Hold         *bool  `json:"hold,omitempty"`
			JobId        *int32 `json:"job_id,omitempty"`
			JobResources *struct {
				AllocatedCores *int32 `json:"allocated_cores,omitempty"`
				AllocatedCpus  *int32 `json:"allocated_cpus,omitempty"`
				AllocatedHosts *int32 `json:"allocated_hosts,omitempty"`

				// AllocatedNodes job node resources
				AllocatedNodes *[]interface{} `json:"allocated_nodes,omitempty"`
				Nodes          *string        `json:"nodes,omitempty"`
			} `json:"job_resources,omitempty"`
			JobSizeStr          *[]string                          `json:"job_size_str,omitempty"`
			JobState            *string                            `json:"job_state,omitempty"`
			LastSchedEvaluation *int64                             `json:"last_sched_evaluation,omitempty"`
			Licenses            *string                            `json:"licenses,omitempty"`
			MailType            *[]SlurmV0039GetJob200JobsMailType `json:"mail_type,omitempty"`
			MailUser            *string                            `json:"mail_user,omitempty"`

			// MaxCpus Integer number with flags
			MaxCpus *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"max_cpus,omitempty"`

			// MaxNodes Integer number with flags
			MaxNodes *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"max_nodes,omitempty"`
			MaximumSwitchWaitTime *int32  `json:"maximum_switch_wait_time,omitempty"`
			McsLabel              *string `json:"mcs_label,omitempty"`

			// MemoryPerCpu Integer number with flags
			MemoryPerCpu *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_cpu,omitempty"`

			// MemoryPerNode Integer number with flags
			MemoryPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_node,omitempty"`
			MemoryPerTres *string `json:"memory_per_tres,omitempty"`

			// MinimumCpusPerNode Integer number with flags
			MinimumCpusPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minimum_cpus_per_node,omitempty"`
			MinimumSwitches *int32 `json:"minimum_switches,omitempty"`

			// MinimumTmpDiskPerNode Integer number with flags
			MinimumTmpDiskPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minimum_tmp_disk_per_node,omitempty"`
			Name    *string `json:"name,omitempty"`
			Network *string `json:"network,omitempty"`
			Nice    *int32  `json:"nice,omitempty"`

			// NodeCount Integer number with flags
			NodeCount *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"node_count,omitempty"`
			Nodes         *string `json:"nodes,omitempty"`
			Oversubscribe *bool   `json:"oversubscribe,omitempty"`
			Partition     *string `json:"partition,omitempty"`
			Power         *struct {
				Flags *[]SlurmV0039GetJob200JobsPowerFlags `json:"flags,omitempty"`
			} `json:"power,omitempty"`
			PreSusTime      *int64  `json:"pre_sus_time,omitempty"`
			PreemptTime     *int64  `json:"preempt_time,omitempty"`
			PreemptableTime *int64  `json:"preemptable_time,omitempty"`
			Prefer          *string `json:"prefer,omitempty"`

			// Priority Integer number with flags
			Priority *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority,omitempty"`
			Profile         *[]SlurmV0039GetJob200JobsProfile   `json:"profile,omitempty"`
			Qos             *string                             `json:"qos,omitempty"`
			Reboot          *bool                               `json:"reboot,omitempty"`
			Requeue         *bool                               `json:"requeue,omitempty"`
			RequiredNodes   *string                             `json:"required_nodes,omitempty"`
			ResizeTime      *int64                              `json:"resize_time,omitempty"`
			RestartCnt      *int32                              `json:"restart_cnt,omitempty"`
			ResvName        *string                             `json:"resv_name,omitempty"`
			ScheduledNodes  *string                             `json:"scheduled_nodes,omitempty"`
			SelinuxContext  *string                             `json:"selinux_context,omitempty"`
			Shared          *[]SlurmV0039GetJob200JobsShared    `json:"shared,omitempty"`
			ShowFlags       *[]SlurmV0039GetJob200JobsShowFlags `json:"show_flags,omitempty"`
			SocketsPerBoard *int32                              `json:"sockets_per_board,omitempty"`

			// SocketsPerNode Integer number with flags
			SocketsPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"sockets_per_node,omitempty"`
			StandardError    *string `json:"standard_error,omitempty"`
			StandardInput    *string `json:"standard_input,omitempty"`
			StandardOutput   *string `json:"standard_output,omitempty"`
			StartTime        *int64  `json:"start_time,omitempty"`
			StateDescription *string `json:"state_description,omitempty"`
			StateReason      *string `json:"state_reason,omitempty"`
			SubmitTime       *int64  `json:"submit_time,omitempty"`
			SuspendTime      *int64  `json:"suspend_time,omitempty"`
			SystemComment    *string `json:"system_comment,omitempty"`

			// Tasks Integer number with flags
			Tasks *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks,omitempty"`

			// TasksPerBoard Integer number with flags
			TasksPerBoard *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_board,omitempty"`

			// TasksPerCore Integer number with flags
			TasksPerCore *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_core,omitempty"`

			// TasksPerNode Integer number with flags
			TasksPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_node,omitempty"`

			// TasksPerSocket Integer number with flags
			TasksPerSocket *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_socket,omitempty"`

			// TasksPerTres Integer number with flags
			TasksPerTres *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_tres,omitempty"`
			ThreadSpec *int32 `json:"thread_spec,omitempty"`

			// ThreadsPerCore Integer number with flags
			ThreadsPerCore *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"threads_per_core,omitempty"`

			// TimeLimit Integer number with flags
			TimeLimit *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time_limit,omitempty"`

			// TimeMinimum Integer number with flags
			TimeMinimum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time_minimum,omitempty"`
			TresAllocStr  *string `json:"tres_alloc_str,omitempty"`
			TresBind      *string `json:"tres_bind,omitempty"`
			TresFreq      *string `json:"tres_freq,omitempty"`
			TresPerJob    *string `json:"tres_per_job,omitempty"`
			TresPerNode   *string `json:"tres_per_node,omitempty"`
			TresPerSocket *string `json:"tres_per_socket,omitempty"`
			TresPerTask   *string `json:"tres_per_task,omitempty"`
			TresReqStr    *string `json:"tres_req_str,omitempty"`
			UserId        *int32  `json:"user_id,omitempty"`
			UserName      *string `json:"user_name,omitempty"`
			Wckey         *string `json:"wckey,omitempty"`
		} `json:"jobs,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}
type SlurmV0039GetJob200JobsExclusive string
type SlurmV0039GetJob200JobsFlags string
type SlurmV0039GetJob200JobsMailType string
type SlurmV0039GetJob200JobsPowerFlags string
type SlurmV0039GetJob200JobsProfile string
type SlurmV0039GetJob200JobsShared string
type SlurmV0039GetJob200JobsShowFlags string

// Status returns HTTPResponse.Status
func (r SlurmV0039GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039UpdateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Results Result per ArrayJob
		Results *[]struct {
			// Error error code description
			Error *string `json:"error,omitempty"`

			// ErrorCode numeric error code
			ErrorCode *int32 `json:"error_code,omitempty"`

			// JobId JobId
			JobId *int32 `json:"job_id,omitempty"`

			// Why error message
			Why *string `json:"why,omitempty"`
		} `json:"results,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Results Result per ArrayJob
		Results *[]struct {
			// Error error code description
			Error *string `json:"error,omitempty"`

			// ErrorCode numeric error code
			ErrorCode *int32 `json:"error_code,omitempty"`

			// JobId JobId
			JobId *int32 `json:"job_id,omitempty"`

			// Why error message
			Why *string `json:"why,omitempty"`
		} `json:"results,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0039UpdateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039UpdateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Jobs *[]struct {
			Account        *string `json:"account,omitempty"`
			AccrueTime     *int64  `json:"accrue_time,omitempty"`
			AdminComment   *string `json:"admin_comment,omitempty"`
			AllocatingNode *string `json:"allocating_node,omitempty"`

			// ArrayJobId Integer number with flags
			ArrayJobId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_job_id,omitempty"`

			// ArrayMaxTasks Integer number with flags
			ArrayMaxTasks *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_max_tasks,omitempty"`

			// ArrayTaskId Integer number with flags
			ArrayTaskId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_task_id,omitempty"`
			ArrayTaskString *string `json:"array_task_string,omitempty"`
			AssociationId   *int32  `json:"association_id,omitempty"`
			BatchFeatures   *string `json:"batch_features,omitempty"`
			BatchFlag       *bool   `json:"batch_flag,omitempty"`
			BatchHost       *string `json:"batch_host,omitempty"`

			// BillableTres 64 bit floating point number with flags
			BillableTres *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"billable_tres,omitempty"`
			BurstBuffer      *string `json:"burst_buffer,omitempty"`
			BurstBufferState *string `json:"burst_buffer_state,omitempty"`
			Cluster          *string `json:"cluster,omitempty"`
			ClusterFeatures  *string `json:"cluster_features,omitempty"`
			Command          *string `json:"command,omitempty"`
			Comment          *string `json:"comment,omitempty"`
			Container        *string `json:"container,omitempty"`
			ContainerId      *string `json:"container_id,omitempty"`
			Contiguous       *bool   `json:"contiguous,omitempty"`
			CoreSpec         *int32  `json:"core_spec,omitempty"`

			// CoresPerSocket Integer number with flags
			CoresPerSocket *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cores_per_socket,omitempty"`

			// CpuFrequencyGovernor Integer number with flags
			CpuFrequencyGovernor *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_governor,omitempty"`

			// CpuFrequencyMaximum Integer number with flags
			CpuFrequencyMaximum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_maximum,omitempty"`

			// CpuFrequencyMinimum Integer number with flags
			CpuFrequencyMinimum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_minimum,omitempty"`

			// Cpus Integer number with flags
			Cpus *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus,omitempty"`

			// CpusPerTask Integer number with flags
			CpusPerTask *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus_per_task,omitempty"`
			CpusPerTres             *string `json:"cpus_per_tres,omitempty"`
			Cron                    *string `json:"cron,omitempty"`
			CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`
			Deadline                *int64  `json:"deadline,omitempty"`

			// DelayBoot Integer number with flags
			DelayBoot *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"delay_boot,omitempty"`
			Dependency *string `json:"dependency,omitempty"`

			// DerivedExitCode Integer number with flags
			DerivedExitCode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"derived_exit_code,omitempty"`
			EligibleTime  *int64                               `json:"eligible_time,omitempty"`
			EndTime       *int64                               `json:"end_time,omitempty"`
			ExcludedNodes *string                              `json:"excluded_nodes,omitempty"`
			Exclusive     *[]SlurmV0039GetJobs200JobsExclusive `json:"exclusive,omitempty"`

			// ExitCode Integer number with flags
			ExitCode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"exit_code,omitempty"`
			Extra                    *string                          `json:"extra,omitempty"`
			FailedNode               *string                          `json:"failed_node,omitempty"`
			Features                 *string                          `json:"features,omitempty"`
			FederationOrigin         *string                          `json:"federation_origin,omitempty"`
			FederationSiblingsActive *string                          `json:"federation_siblings_active,omitempty"`
			FederationSiblingsViable *string                          `json:"federation_siblings_viable,omitempty"`
			Flags                    *[]SlurmV0039GetJobs200JobsFlags `json:"flags,omitempty"`
			GresDetail               *[]string                        `json:"gres_detail,omitempty"`
			GroupId                  *int32                           `json:"group_id,omitempty"`
			GroupName                *string                          `json:"group_name,omitempty"`

			// HetJobId Integer number with flags
			HetJobId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"het_job_id,omitempty"`
			HetJobIdSet *string `json:"het_job_id_set,omitempty"`

			// HetJobOffset Integer number with flags
			HetJobOffset *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"het_job_offset,omitempty"`

			// Hold Hold (true) or release (false) job
			Hold         *bool  `json:"hold,omitempty"`
			JobId        *int32 `json:"job_id,omitempty"`
			JobResources *struct {
				AllocatedCores *int32 `json:"allocated_cores,omitempty"`
				AllocatedCpus  *int32 `json:"allocated_cpus,omitempty"`
				AllocatedHosts *int32 `json:"allocated_hosts,omitempty"`

				// AllocatedNodes job node resources
				AllocatedNodes *[]interface{} `json:"allocated_nodes,omitempty"`
				Nodes          *string        `json:"nodes,omitempty"`
			} `json:"job_resources,omitempty"`
			JobSizeStr          *[]string                           `json:"job_size_str,omitempty"`
			JobState            *string                             `json:"job_state,omitempty"`
			LastSchedEvaluation *int64                              `json:"last_sched_evaluation,omitempty"`
			Licenses            *string                             `json:"licenses,omitempty"`
			MailType            *[]SlurmV0039GetJobs200JobsMailType `json:"mail_type,omitempty"`
			MailUser            *string                             `json:"mail_user,omitempty"`

			// MaxCpus Integer number with flags
			MaxCpus *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"max_cpus,omitempty"`

			// MaxNodes Integer number with flags
			MaxNodes *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"max_nodes,omitempty"`
			MaximumSwitchWaitTime *int32  `json:"maximum_switch_wait_time,omitempty"`
			McsLabel              *string `json:"mcs_label,omitempty"`

			// MemoryPerCpu Integer number with flags
			MemoryPerCpu *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_cpu,omitempty"`

			// MemoryPerNode Integer number with flags
			MemoryPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_node,omitempty"`
			MemoryPerTres *string `json:"memory_per_tres,omitempty"`

			// MinimumCpusPerNode Integer number with flags
			MinimumCpusPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minimum_cpus_per_node,omitempty"`
			MinimumSwitches *int32 `json:"minimum_switches,omitempty"`

			// MinimumTmpDiskPerNode Integer number with flags
			MinimumTmpDiskPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minimum_tmp_disk_per_node,omitempty"`
			Name    *string `json:"name,omitempty"`
			Network *string `json:"network,omitempty"`
			Nice    *int32  `json:"nice,omitempty"`

			// NodeCount Integer number with flags
			NodeCount *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"node_count,omitempty"`
			Nodes         *string `json:"nodes,omitempty"`
			Oversubscribe *bool   `json:"oversubscribe,omitempty"`
			Partition     *string `json:"partition,omitempty"`
			Power         *struct {
				Flags *[]SlurmV0039GetJobs200JobsPowerFlags `json:"flags,omitempty"`
			} `json:"power,omitempty"`
			PreSusTime      *int64  `json:"pre_sus_time,omitempty"`
			PreemptTime     *int64  `json:"preempt_time,omitempty"`
			PreemptableTime *int64  `json:"preemptable_time,omitempty"`
			Prefer          *string `json:"prefer,omitempty"`

			// Priority Integer number with flags
			Priority *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority,omitempty"`
			Profile         *[]SlurmV0039GetJobs200JobsProfile   `json:"profile,omitempty"`
			Qos             *string                              `json:"qos,omitempty"`
			Reboot          *bool                                `json:"reboot,omitempty"`
			Requeue         *bool                                `json:"requeue,omitempty"`
			RequiredNodes   *string                              `json:"required_nodes,omitempty"`
			ResizeTime      *int64                               `json:"resize_time,omitempty"`
			RestartCnt      *int32                               `json:"restart_cnt,omitempty"`
			ResvName        *string                              `json:"resv_name,omitempty"`
			ScheduledNodes  *string                              `json:"scheduled_nodes,omitempty"`
			SelinuxContext  *string                              `json:"selinux_context,omitempty"`
			Shared          *[]SlurmV0039GetJobs200JobsShared    `json:"shared,omitempty"`
			ShowFlags       *[]SlurmV0039GetJobs200JobsShowFlags `json:"show_flags,omitempty"`
			SocketsPerBoard *int32                               `json:"sockets_per_board,omitempty"`

			// SocketsPerNode Integer number with flags
			SocketsPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"sockets_per_node,omitempty"`
			StandardError    *string `json:"standard_error,omitempty"`
			StandardInput    *string `json:"standard_input,omitempty"`
			StandardOutput   *string `json:"standard_output,omitempty"`
			StartTime        *int64  `json:"start_time,omitempty"`
			StateDescription *string `json:"state_description,omitempty"`
			StateReason      *string `json:"state_reason,omitempty"`
			SubmitTime       *int64  `json:"submit_time,omitempty"`
			SuspendTime      *int64  `json:"suspend_time,omitempty"`
			SystemComment    *string `json:"system_comment,omitempty"`

			// Tasks Integer number with flags
			Tasks *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks,omitempty"`

			// TasksPerBoard Integer number with flags
			TasksPerBoard *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_board,omitempty"`

			// TasksPerCore Integer number with flags
			TasksPerCore *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_core,omitempty"`

			// TasksPerNode Integer number with flags
			TasksPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_node,omitempty"`

			// TasksPerSocket Integer number with flags
			TasksPerSocket *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_socket,omitempty"`

			// TasksPerTres Integer number with flags
			TasksPerTres *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_tres,omitempty"`
			ThreadSpec *int32 `json:"thread_spec,omitempty"`

			// ThreadsPerCore Integer number with flags
			ThreadsPerCore *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"threads_per_core,omitempty"`

			// TimeLimit Integer number with flags
			TimeLimit *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time_limit,omitempty"`

			// TimeMinimum Integer number with flags
			TimeMinimum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time_minimum,omitempty"`
			TresAllocStr  *string `json:"tres_alloc_str,omitempty"`
			TresBind      *string `json:"tres_bind,omitempty"`
			TresFreq      *string `json:"tres_freq,omitempty"`
			TresPerJob    *string `json:"tres_per_job,omitempty"`
			TresPerNode   *string `json:"tres_per_node,omitempty"`
			TresPerSocket *string `json:"tres_per_socket,omitempty"`
			TresPerTask   *string `json:"tres_per_task,omitempty"`
			TresReqStr    *string `json:"tres_req_str,omitempty"`
			UserId        *int32  `json:"user_id,omitempty"`
			UserName      *string `json:"user_name,omitempty"`
			Wckey         *string `json:"wckey,omitempty"`
		} `json:"jobs,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Jobs *[]struct {
			Account        *string `json:"account,omitempty"`
			AccrueTime     *int64  `json:"accrue_time,omitempty"`
			AdminComment   *string `json:"admin_comment,omitempty"`
			AllocatingNode *string `json:"allocating_node,omitempty"`

			// ArrayJobId Integer number with flags
			ArrayJobId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_job_id,omitempty"`

			// ArrayMaxTasks Integer number with flags
			ArrayMaxTasks *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_max_tasks,omitempty"`

			// ArrayTaskId Integer number with flags
			ArrayTaskId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"array_task_id,omitempty"`
			ArrayTaskString *string `json:"array_task_string,omitempty"`
			AssociationId   *int32  `json:"association_id,omitempty"`
			BatchFeatures   *string `json:"batch_features,omitempty"`
			BatchFlag       *bool   `json:"batch_flag,omitempty"`
			BatchHost       *string `json:"batch_host,omitempty"`

			// BillableTres 64 bit floating point number with flags
			BillableTres *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"billable_tres,omitempty"`
			BurstBuffer      *string `json:"burst_buffer,omitempty"`
			BurstBufferState *string `json:"burst_buffer_state,omitempty"`
			Cluster          *string `json:"cluster,omitempty"`
			ClusterFeatures  *string `json:"cluster_features,omitempty"`
			Command          *string `json:"command,omitempty"`
			Comment          *string `json:"comment,omitempty"`
			Container        *string `json:"container,omitempty"`
			ContainerId      *string `json:"container_id,omitempty"`
			Contiguous       *bool   `json:"contiguous,omitempty"`
			CoreSpec         *int32  `json:"core_spec,omitempty"`

			// CoresPerSocket Integer number with flags
			CoresPerSocket *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cores_per_socket,omitempty"`

			// CpuFrequencyGovernor Integer number with flags
			CpuFrequencyGovernor *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_governor,omitempty"`

			// CpuFrequencyMaximum Integer number with flags
			CpuFrequencyMaximum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_maximum,omitempty"`

			// CpuFrequencyMinimum Integer number with flags
			CpuFrequencyMinimum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_frequency_minimum,omitempty"`

			// Cpus Integer number with flags
			Cpus *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus,omitempty"`

			// CpusPerTask Integer number with flags
			CpusPerTask *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus_per_task,omitempty"`
			CpusPerTres             *string `json:"cpus_per_tres,omitempty"`
			Cron                    *string `json:"cron,omitempty"`
			CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`
			Deadline                *int64  `json:"deadline,omitempty"`

			// DelayBoot Integer number with flags
			DelayBoot *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"delay_boot,omitempty"`
			Dependency *string `json:"dependency,omitempty"`

			// DerivedExitCode Integer number with flags
			DerivedExitCode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"derived_exit_code,omitempty"`
			EligibleTime  *int64                               `json:"eligible_time,omitempty"`
			EndTime       *int64                               `json:"end_time,omitempty"`
			ExcludedNodes *string                              `json:"excluded_nodes,omitempty"`
			Exclusive     *[]SlurmV0039GetJobs200JobsExclusive `json:"exclusive,omitempty"`

			// ExitCode Integer number with flags
			ExitCode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"exit_code,omitempty"`
			Extra                    *string                          `json:"extra,omitempty"`
			FailedNode               *string                          `json:"failed_node,omitempty"`
			Features                 *string                          `json:"features,omitempty"`
			FederationOrigin         *string                          `json:"federation_origin,omitempty"`
			FederationSiblingsActive *string                          `json:"federation_siblings_active,omitempty"`
			FederationSiblingsViable *string                          `json:"federation_siblings_viable,omitempty"`
			Flags                    *[]SlurmV0039GetJobs200JobsFlags `json:"flags,omitempty"`
			GresDetail               *[]string                        `json:"gres_detail,omitempty"`
			GroupId                  *int32                           `json:"group_id,omitempty"`
			GroupName                *string                          `json:"group_name,omitempty"`

			// HetJobId Integer number with flags
			HetJobId *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"het_job_id,omitempty"`
			HetJobIdSet *string `json:"het_job_id_set,omitempty"`

			// HetJobOffset Integer number with flags
			HetJobOffset *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"het_job_offset,omitempty"`

			// Hold Hold (true) or release (false) job
			Hold         *bool  `json:"hold,omitempty"`
			JobId        *int32 `json:"job_id,omitempty"`
			JobResources *struct {
				AllocatedCores *int32 `json:"allocated_cores,omitempty"`
				AllocatedCpus  *int32 `json:"allocated_cpus,omitempty"`
				AllocatedHosts *int32 `json:"allocated_hosts,omitempty"`

				// AllocatedNodes job node resources
				AllocatedNodes *[]interface{} `json:"allocated_nodes,omitempty"`
				Nodes          *string        `json:"nodes,omitempty"`
			} `json:"job_resources,omitempty"`
			JobSizeStr          *[]string                           `json:"job_size_str,omitempty"`
			JobState            *string                             `json:"job_state,omitempty"`
			LastSchedEvaluation *int64                              `json:"last_sched_evaluation,omitempty"`
			Licenses            *string                             `json:"licenses,omitempty"`
			MailType            *[]SlurmV0039GetJobs200JobsMailType `json:"mail_type,omitempty"`
			MailUser            *string                             `json:"mail_user,omitempty"`

			// MaxCpus Integer number with flags
			MaxCpus *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"max_cpus,omitempty"`

			// MaxNodes Integer number with flags
			MaxNodes *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"max_nodes,omitempty"`
			MaximumSwitchWaitTime *int32  `json:"maximum_switch_wait_time,omitempty"`
			McsLabel              *string `json:"mcs_label,omitempty"`

			// MemoryPerCpu Integer number with flags
			MemoryPerCpu *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_cpu,omitempty"`

			// MemoryPerNode Integer number with flags
			MemoryPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_node,omitempty"`
			MemoryPerTres *string `json:"memory_per_tres,omitempty"`

			// MinimumCpusPerNode Integer number with flags
			MinimumCpusPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minimum_cpus_per_node,omitempty"`
			MinimumSwitches *int32 `json:"minimum_switches,omitempty"`

			// MinimumTmpDiskPerNode Integer number with flags
			MinimumTmpDiskPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minimum_tmp_disk_per_node,omitempty"`
			Name    *string `json:"name,omitempty"`
			Network *string `json:"network,omitempty"`
			Nice    *int32  `json:"nice,omitempty"`

			// NodeCount Integer number with flags
			NodeCount *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"node_count,omitempty"`
			Nodes         *string `json:"nodes,omitempty"`
			Oversubscribe *bool   `json:"oversubscribe,omitempty"`
			Partition     *string `json:"partition,omitempty"`
			Power         *struct {
				Flags *[]SlurmV0039GetJobs200JobsPowerFlags `json:"flags,omitempty"`
			} `json:"power,omitempty"`
			PreSusTime      *int64  `json:"pre_sus_time,omitempty"`
			PreemptTime     *int64  `json:"preempt_time,omitempty"`
			PreemptableTime *int64  `json:"preemptable_time,omitempty"`
			Prefer          *string `json:"prefer,omitempty"`

			// Priority Integer number with flags
			Priority *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority,omitempty"`
			Profile         *[]SlurmV0039GetJobs200JobsProfile   `json:"profile,omitempty"`
			Qos             *string                              `json:"qos,omitempty"`
			Reboot          *bool                                `json:"reboot,omitempty"`
			Requeue         *bool                                `json:"requeue,omitempty"`
			RequiredNodes   *string                              `json:"required_nodes,omitempty"`
			ResizeTime      *int64                               `json:"resize_time,omitempty"`
			RestartCnt      *int32                               `json:"restart_cnt,omitempty"`
			ResvName        *string                              `json:"resv_name,omitempty"`
			ScheduledNodes  *string                              `json:"scheduled_nodes,omitempty"`
			SelinuxContext  *string                              `json:"selinux_context,omitempty"`
			Shared          *[]SlurmV0039GetJobs200JobsShared    `json:"shared,omitempty"`
			ShowFlags       *[]SlurmV0039GetJobs200JobsShowFlags `json:"show_flags,omitempty"`
			SocketsPerBoard *int32                               `json:"sockets_per_board,omitempty"`

			// SocketsPerNode Integer number with flags
			SocketsPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"sockets_per_node,omitempty"`
			StandardError    *string `json:"standard_error,omitempty"`
			StandardInput    *string `json:"standard_input,omitempty"`
			StandardOutput   *string `json:"standard_output,omitempty"`
			StartTime        *int64  `json:"start_time,omitempty"`
			StateDescription *string `json:"state_description,omitempty"`
			StateReason      *string `json:"state_reason,omitempty"`
			SubmitTime       *int64  `json:"submit_time,omitempty"`
			SuspendTime      *int64  `json:"suspend_time,omitempty"`
			SystemComment    *string `json:"system_comment,omitempty"`

			// Tasks Integer number with flags
			Tasks *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks,omitempty"`

			// TasksPerBoard Integer number with flags
			TasksPerBoard *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_board,omitempty"`

			// TasksPerCore Integer number with flags
			TasksPerCore *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_core,omitempty"`

			// TasksPerNode Integer number with flags
			TasksPerNode *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_node,omitempty"`

			// TasksPerSocket Integer number with flags
			TasksPerSocket *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_socket,omitempty"`

			// TasksPerTres Integer number with flags
			TasksPerTres *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"tasks_per_tres,omitempty"`
			ThreadSpec *int32 `json:"thread_spec,omitempty"`

			// ThreadsPerCore Integer number with flags
			ThreadsPerCore *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"threads_per_core,omitempty"`

			// TimeLimit Integer number with flags
			TimeLimit *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time_limit,omitempty"`

			// TimeMinimum Integer number with flags
			TimeMinimum *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time_minimum,omitempty"`
			TresAllocStr  *string `json:"tres_alloc_str,omitempty"`
			TresBind      *string `json:"tres_bind,omitempty"`
			TresFreq      *string `json:"tres_freq,omitempty"`
			TresPerJob    *string `json:"tres_per_job,omitempty"`
			TresPerNode   *string `json:"tres_per_node,omitempty"`
			TresPerSocket *string `json:"tres_per_socket,omitempty"`
			TresPerTask   *string `json:"tres_per_task,omitempty"`
			TresReqStr    *string `json:"tres_req_str,omitempty"`
			UserId        *int32  `json:"user_id,omitempty"`
			UserName      *string `json:"user_name,omitempty"`
			Wckey         *string `json:"wckey,omitempty"`
		} `json:"jobs,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}
type SlurmV0039GetJobs200JobsExclusive string
type SlurmV0039GetJobs200JobsFlags string
type SlurmV0039GetJobs200JobsMailType string
type SlurmV0039GetJobs200JobsPowerFlags string
type SlurmV0039GetJobs200JobsProfile string
type SlurmV0039GetJobs200JobsShared string
type SlurmV0039GetJobs200JobsShowFlags string

// Status returns HTTPResponse.Status
func (r SlurmV0039GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039SlurmctldGetLicensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Licenses *[]struct {
			Free         *int32  `json:"Free,omitempty"`
			LastConsumed *int32  `json:"LastConsumed,omitempty"`
			LastDeficit  *int32  `json:"LastDeficit,omitempty"`
			LastUpdate   *int64  `json:"LastUpdate,omitempty"`
			LicenseName  *string `json:"LicenseName,omitempty"`
			Remote       *bool   `json:"Remote,omitempty"`
			Reserved     *int32  `json:"Reserved,omitempty"`
			Total        *int32  `json:"Total,omitempty"`
			Used         *int32  `json:"Used,omitempty"`
		} `json:"licenses,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Licenses *[]struct {
			Free         *int32  `json:"Free,omitempty"`
			LastConsumed *int32  `json:"LastConsumed,omitempty"`
			LastDeficit  *int32  `json:"LastDeficit,omitempty"`
			LastUpdate   *int64  `json:"LastUpdate,omitempty"`
			LicenseName  *string `json:"LicenseName,omitempty"`
			Remote       *bool   `json:"Remote,omitempty"`
			Reserved     *int32  `json:"Reserved,omitempty"`
			Total        *int32  `json:"Total,omitempty"`
			Used         *int32  `json:"Used,omitempty"`
		} `json:"licenses,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0039SlurmctldGetLicensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039SlurmctldGetLicensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039DeleteNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0039DeleteNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039DeleteNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039GetNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Nodes *[]struct {
			ActiveFeatures            *[]string `json:"active_features,omitempty"`
			Address                   *string   `json:"address,omitempty"`
			AllocCpus                 *int32    `json:"alloc_cpus,omitempty"`
			AllocIdleCpus             *int32    `json:"alloc_idle_cpus,omitempty"`
			AllocMemory               *int64    `json:"alloc_memory,omitempty"`
			Architecture              *string   `json:"architecture,omitempty"`
			Boards                    *int32    `json:"boards,omitempty"`
			BootTime                  *int64    `json:"boot_time,omitempty"`
			BurstbufferNetworkAddress *string   `json:"burstbuffer_network_address,omitempty"`
			ClusterName               *string   `json:"cluster_name,omitempty"`
			Comment                   *string   `json:"comment,omitempty"`
			Cores                     *int32    `json:"cores,omitempty"`
			CpuBinding                *int32    `json:"cpu_binding,omitempty"`

			// CpuLoad Integer number with flags
			CpuLoad *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_load,omitempty"`
			Cpus          *int32 `json:"cpus,omitempty"`
			EffectiveCpus *int32 `json:"effective_cpus,omitempty"`
			Energy        *struct {
				AverageWatts       *int32 `json:"average_watts,omitempty"`
				BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`
				ConsumedEnergy     *int64 `json:"consumed_energy,omitempty"`

				// CurrentWatts Integer number with flags
				CurrentWatts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"current_watts,omitempty"`
				LastCollected          *int64 `json:"last_collected,omitempty"`
				PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
			} `json:"energy,omitempty"`
			ExternalSensors *struct {
				// ConsumedEnergy Integer number with flags
				ConsumedEnergy *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"consumed_energy,omitempty"`
				CurrentWatts     *int32 `json:"current_watts,omitempty"`
				EnergyUpdateTime *int64 `json:"energy_update_time,omitempty"`

				// Temperature Integer number with flags
				Temperature *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"temperature,omitempty"`
			} `json:"external_sensors,omitempty"`
			Extra    *string   `json:"extra,omitempty"`
			Features *[]string `json:"features,omitempty"`

			// FreeMem Integer number with flags
			FreeMem *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"free_mem,omitempty"`
			Gres                 *string                                          `json:"gres,omitempty"`
			GresDrained          *string                                          `json:"gres_drained,omitempty"`
			GresUsed             *string                                          `json:"gres_used,omitempty"`
			Hostname             *string                                          `json:"hostname,omitempty"`
			LastBusy             *int64                                           `json:"last_busy,omitempty"`
			McsLabel             *string                                          `json:"mcs_label,omitempty"`
			Name                 *string                                          `json:"name,omitempty"`
			NextStateAfterReboot *[]SlurmV0039GetNode200NodesNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`
			OperatingSystem      *string                                          `json:"operating_system,omitempty"`
			Owner                *string                                          `json:"owner,omitempty"`
			Partitions           *[]string                                        `json:"partitions,omitempty"`
			Port                 *int32                                           `json:"port,omitempty"`
			Power                *struct {
				CurrentWatts *int32 `json:"current_watts,omitempty"`
				LowestWatts  *int32 `json:"lowest_watts,omitempty"`

				// MaximumWatts Integer number with flags
				MaximumWatts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"maximum_watts,omitempty"`
				NewJobTime      *int64 `json:"new_job_time,omitempty"`
				NewMaximumWatts *int32 `json:"new_maximum_watts,omitempty"`
				PeakWatts       *int32 `json:"peak_watts,omitempty"`
				State           *int32 `json:"state,omitempty"`
				TimeStartDay    *int64 `json:"time_start_day,omitempty"`
				TotalEnergy     *int64 `json:"total_energy,omitempty"`
			} `json:"power,omitempty"`
			RealMemory      *int64  `json:"real_memory,omitempty"`
			Reason          *string `json:"reason,omitempty"`
			ReasonChangedAt *int64  `json:"reason_changed_at,omitempty"`
			ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`
			Reservation     *string `json:"reservation,omitempty"`

			// ResumeAfter Integer number with flags
			ResumeAfter *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"resume_after,omitempty"`
			SlurmdStartTime   *int64                            `json:"slurmd_start_time,omitempty"`
			Sockets           *int32                            `json:"sockets,omitempty"`
			SpecializedCores  *int32                            `json:"specialized_cores,omitempty"`
			SpecializedCpus   *string                           `json:"specialized_cpus,omitempty"`
			SpecializedMemory *int64                            `json:"specialized_memory,omitempty"`
			State             *[]SlurmV0039GetNode200NodesState `json:"state,omitempty"`
			TemporaryDisk     *int32                            `json:"temporary_disk,omitempty"`
			Threads           *int32                            `json:"threads,omitempty"`
			Tres              *string                           `json:"tres,omitempty"`
			TresUsed          *string                           `json:"tres_used,omitempty"`
			TresWeighted      *float64                          `json:"tres_weighted,omitempty"`
			Version           *string                           `json:"version,omitempty"`
			Weight            *int32                            `json:"weight,omitempty"`
		} `json:"nodes,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Nodes *[]struct {
			ActiveFeatures            *[]string `json:"active_features,omitempty"`
			Address                   *string   `json:"address,omitempty"`
			AllocCpus                 *int32    `json:"alloc_cpus,omitempty"`
			AllocIdleCpus             *int32    `json:"alloc_idle_cpus,omitempty"`
			AllocMemory               *int64    `json:"alloc_memory,omitempty"`
			Architecture              *string   `json:"architecture,omitempty"`
			Boards                    *int32    `json:"boards,omitempty"`
			BootTime                  *int64    `json:"boot_time,omitempty"`
			BurstbufferNetworkAddress *string   `json:"burstbuffer_network_address,omitempty"`
			ClusterName               *string   `json:"cluster_name,omitempty"`
			Comment                   *string   `json:"comment,omitempty"`
			Cores                     *int32    `json:"cores,omitempty"`
			CpuBinding                *int32    `json:"cpu_binding,omitempty"`

			// CpuLoad Integer number with flags
			CpuLoad *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_load,omitempty"`
			Cpus          *int32 `json:"cpus,omitempty"`
			EffectiveCpus *int32 `json:"effective_cpus,omitempty"`
			Energy        *struct {
				AverageWatts       *int32 `json:"average_watts,omitempty"`
				BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`
				ConsumedEnergy     *int64 `json:"consumed_energy,omitempty"`

				// CurrentWatts Integer number with flags
				CurrentWatts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"current_watts,omitempty"`
				LastCollected          *int64 `json:"last_collected,omitempty"`
				PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
			} `json:"energy,omitempty"`
			ExternalSensors *struct {
				// ConsumedEnergy Integer number with flags
				ConsumedEnergy *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"consumed_energy,omitempty"`
				CurrentWatts     *int32 `json:"current_watts,omitempty"`
				EnergyUpdateTime *int64 `json:"energy_update_time,omitempty"`

				// Temperature Integer number with flags
				Temperature *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"temperature,omitempty"`
			} `json:"external_sensors,omitempty"`
			Extra    *string   `json:"extra,omitempty"`
			Features *[]string `json:"features,omitempty"`

			// FreeMem Integer number with flags
			FreeMem *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"free_mem,omitempty"`
			Gres                 *string                                          `json:"gres,omitempty"`
			GresDrained          *string                                          `json:"gres_drained,omitempty"`
			GresUsed             *string                                          `json:"gres_used,omitempty"`
			Hostname             *string                                          `json:"hostname,omitempty"`
			LastBusy             *int64                                           `json:"last_busy,omitempty"`
			McsLabel             *string                                          `json:"mcs_label,omitempty"`
			Name                 *string                                          `json:"name,omitempty"`
			NextStateAfterReboot *[]SlurmV0039GetNode200NodesNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`
			OperatingSystem      *string                                          `json:"operating_system,omitempty"`
			Owner                *string                                          `json:"owner,omitempty"`
			Partitions           *[]string                                        `json:"partitions,omitempty"`
			Port                 *int32                                           `json:"port,omitempty"`
			Power                *struct {
				CurrentWatts *int32 `json:"current_watts,omitempty"`
				LowestWatts  *int32 `json:"lowest_watts,omitempty"`

				// MaximumWatts Integer number with flags
				MaximumWatts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"maximum_watts,omitempty"`
				NewJobTime      *int64 `json:"new_job_time,omitempty"`
				NewMaximumWatts *int32 `json:"new_maximum_watts,omitempty"`
				PeakWatts       *int32 `json:"peak_watts,omitempty"`
				State           *int32 `json:"state,omitempty"`
				TimeStartDay    *int64 `json:"time_start_day,omitempty"`
				TotalEnergy     *int64 `json:"total_energy,omitempty"`
			} `json:"power,omitempty"`
			RealMemory      *int64  `json:"real_memory,omitempty"`
			Reason          *string `json:"reason,omitempty"`
			ReasonChangedAt *int64  `json:"reason_changed_at,omitempty"`
			ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`
			Reservation     *string `json:"reservation,omitempty"`

			// ResumeAfter Integer number with flags
			ResumeAfter *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"resume_after,omitempty"`
			SlurmdStartTime   *int64                            `json:"slurmd_start_time,omitempty"`
			Sockets           *int32                            `json:"sockets,omitempty"`
			SpecializedCores  *int32                            `json:"specialized_cores,omitempty"`
			SpecializedCpus   *string                           `json:"specialized_cpus,omitempty"`
			SpecializedMemory *int64                            `json:"specialized_memory,omitempty"`
			State             *[]SlurmV0039GetNode200NodesState `json:"state,omitempty"`
			TemporaryDisk     *int32                            `json:"temporary_disk,omitempty"`
			Threads           *int32                            `json:"threads,omitempty"`
			Tres              *string                           `json:"tres,omitempty"`
			TresUsed          *string                           `json:"tres_used,omitempty"`
			TresWeighted      *float64                          `json:"tres_weighted,omitempty"`
			Version           *string                           `json:"version,omitempty"`
			Weight            *int32                            `json:"weight,omitempty"`
		} `json:"nodes,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}
type SlurmV0039GetNode200NodesNextStateAfterReboot string
type SlurmV0039GetNode200NodesState string

// Status returns HTTPResponse.Status
func (r SlurmV0039GetNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039GetNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039UpdateNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0039UpdateNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039UpdateNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039GetNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Nodes *[]struct {
			ActiveFeatures            *[]string `json:"active_features,omitempty"`
			Address                   *string   `json:"address,omitempty"`
			AllocCpus                 *int32    `json:"alloc_cpus,omitempty"`
			AllocIdleCpus             *int32    `json:"alloc_idle_cpus,omitempty"`
			AllocMemory               *int64    `json:"alloc_memory,omitempty"`
			Architecture              *string   `json:"architecture,omitempty"`
			Boards                    *int32    `json:"boards,omitempty"`
			BootTime                  *int64    `json:"boot_time,omitempty"`
			BurstbufferNetworkAddress *string   `json:"burstbuffer_network_address,omitempty"`
			ClusterName               *string   `json:"cluster_name,omitempty"`
			Comment                   *string   `json:"comment,omitempty"`
			Cores                     *int32    `json:"cores,omitempty"`
			CpuBinding                *int32    `json:"cpu_binding,omitempty"`

			// CpuLoad Integer number with flags
			CpuLoad *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_load,omitempty"`
			Cpus          *int32 `json:"cpus,omitempty"`
			EffectiveCpus *int32 `json:"effective_cpus,omitempty"`
			Energy        *struct {
				AverageWatts       *int32 `json:"average_watts,omitempty"`
				BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`
				ConsumedEnergy     *int64 `json:"consumed_energy,omitempty"`

				// CurrentWatts Integer number with flags
				CurrentWatts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"current_watts,omitempty"`
				LastCollected          *int64 `json:"last_collected,omitempty"`
				PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
			} `json:"energy,omitempty"`
			ExternalSensors *struct {
				// ConsumedEnergy Integer number with flags
				ConsumedEnergy *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"consumed_energy,omitempty"`
				CurrentWatts     *int32 `json:"current_watts,omitempty"`
				EnergyUpdateTime *int64 `json:"energy_update_time,omitempty"`

				// Temperature Integer number with flags
				Temperature *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"temperature,omitempty"`
			} `json:"external_sensors,omitempty"`
			Extra    *string   `json:"extra,omitempty"`
			Features *[]string `json:"features,omitempty"`

			// FreeMem Integer number with flags
			FreeMem *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"free_mem,omitempty"`
			Gres                 *string                                           `json:"gres,omitempty"`
			GresDrained          *string                                           `json:"gres_drained,omitempty"`
			GresUsed             *string                                           `json:"gres_used,omitempty"`
			Hostname             *string                                           `json:"hostname,omitempty"`
			LastBusy             *int64                                            `json:"last_busy,omitempty"`
			McsLabel             *string                                           `json:"mcs_label,omitempty"`
			Name                 *string                                           `json:"name,omitempty"`
			NextStateAfterReboot *[]SlurmV0039GetNodes200NodesNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`
			OperatingSystem      *string                                           `json:"operating_system,omitempty"`
			Owner                *string                                           `json:"owner,omitempty"`
			Partitions           *[]string                                         `json:"partitions,omitempty"`
			Port                 *int32                                            `json:"port,omitempty"`
			Power                *struct {
				CurrentWatts *int32 `json:"current_watts,omitempty"`
				LowestWatts  *int32 `json:"lowest_watts,omitempty"`

				// MaximumWatts Integer number with flags
				MaximumWatts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"maximum_watts,omitempty"`
				NewJobTime      *int64 `json:"new_job_time,omitempty"`
				NewMaximumWatts *int32 `json:"new_maximum_watts,omitempty"`
				PeakWatts       *int32 `json:"peak_watts,omitempty"`
				State           *int32 `json:"state,omitempty"`
				TimeStartDay    *int64 `json:"time_start_day,omitempty"`
				TotalEnergy     *int64 `json:"total_energy,omitempty"`
			} `json:"power,omitempty"`
			RealMemory      *int64  `json:"real_memory,omitempty"`
			Reason          *string `json:"reason,omitempty"`
			ReasonChangedAt *int64  `json:"reason_changed_at,omitempty"`
			ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`
			Reservation     *string `json:"reservation,omitempty"`

			// ResumeAfter Integer number with flags
			ResumeAfter *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"resume_after,omitempty"`
			SlurmdStartTime   *int64                             `json:"slurmd_start_time,omitempty"`
			Sockets           *int32                             `json:"sockets,omitempty"`
			SpecializedCores  *int32                             `json:"specialized_cores,omitempty"`
			SpecializedCpus   *string                            `json:"specialized_cpus,omitempty"`
			SpecializedMemory *int64                             `json:"specialized_memory,omitempty"`
			State             *[]SlurmV0039GetNodes200NodesState `json:"state,omitempty"`
			TemporaryDisk     *int32                             `json:"temporary_disk,omitempty"`
			Threads           *int32                             `json:"threads,omitempty"`
			Tres              *string                            `json:"tres,omitempty"`
			TresUsed          *string                            `json:"tres_used,omitempty"`
			TresWeighted      *float64                           `json:"tres_weighted,omitempty"`
			Version           *string                            `json:"version,omitempty"`
			Weight            *int32                             `json:"weight,omitempty"`
		} `json:"nodes,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Nodes *[]struct {
			ActiveFeatures            *[]string `json:"active_features,omitempty"`
			Address                   *string   `json:"address,omitempty"`
			AllocCpus                 *int32    `json:"alloc_cpus,omitempty"`
			AllocIdleCpus             *int32    `json:"alloc_idle_cpus,omitempty"`
			AllocMemory               *int64    `json:"alloc_memory,omitempty"`
			Architecture              *string   `json:"architecture,omitempty"`
			Boards                    *int32    `json:"boards,omitempty"`
			BootTime                  *int64    `json:"boot_time,omitempty"`
			BurstbufferNetworkAddress *string   `json:"burstbuffer_network_address,omitempty"`
			ClusterName               *string   `json:"cluster_name,omitempty"`
			Comment                   *string   `json:"comment,omitempty"`
			Cores                     *int32    `json:"cores,omitempty"`
			CpuBinding                *int32    `json:"cpu_binding,omitempty"`

			// CpuLoad Integer number with flags
			CpuLoad *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu_load,omitempty"`
			Cpus          *int32 `json:"cpus,omitempty"`
			EffectiveCpus *int32 `json:"effective_cpus,omitempty"`
			Energy        *struct {
				AverageWatts       *int32 `json:"average_watts,omitempty"`
				BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`
				ConsumedEnergy     *int64 `json:"consumed_energy,omitempty"`

				// CurrentWatts Integer number with flags
				CurrentWatts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"current_watts,omitempty"`
				LastCollected          *int64 `json:"last_collected,omitempty"`
				PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
			} `json:"energy,omitempty"`
			ExternalSensors *struct {
				// ConsumedEnergy Integer number with flags
				ConsumedEnergy *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"consumed_energy,omitempty"`
				CurrentWatts     *int32 `json:"current_watts,omitempty"`
				EnergyUpdateTime *int64 `json:"energy_update_time,omitempty"`

				// Temperature Integer number with flags
				Temperature *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"temperature,omitempty"`
			} `json:"external_sensors,omitempty"`
			Extra    *string   `json:"extra,omitempty"`
			Features *[]string `json:"features,omitempty"`

			// FreeMem Integer number with flags
			FreeMem *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"free_mem,omitempty"`
			Gres                 *string                                           `json:"gres,omitempty"`
			GresDrained          *string                                           `json:"gres_drained,omitempty"`
			GresUsed             *string                                           `json:"gres_used,omitempty"`
			Hostname             *string                                           `json:"hostname,omitempty"`
			LastBusy             *int64                                            `json:"last_busy,omitempty"`
			McsLabel             *string                                           `json:"mcs_label,omitempty"`
			Name                 *string                                           `json:"name,omitempty"`
			NextStateAfterReboot *[]SlurmV0039GetNodes200NodesNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`
			OperatingSystem      *string                                           `json:"operating_system,omitempty"`
			Owner                *string                                           `json:"owner,omitempty"`
			Partitions           *[]string                                         `json:"partitions,omitempty"`
			Port                 *int32                                            `json:"port,omitempty"`
			Power                *struct {
				CurrentWatts *int32 `json:"current_watts,omitempty"`
				LowestWatts  *int32 `json:"lowest_watts,omitempty"`

				// MaximumWatts Integer number with flags
				MaximumWatts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"maximum_watts,omitempty"`
				NewJobTime      *int64 `json:"new_job_time,omitempty"`
				NewMaximumWatts *int32 `json:"new_maximum_watts,omitempty"`
				PeakWatts       *int32 `json:"peak_watts,omitempty"`
				State           *int32 `json:"state,omitempty"`
				TimeStartDay    *int64 `json:"time_start_day,omitempty"`
				TotalEnergy     *int64 `json:"total_energy,omitempty"`
			} `json:"power,omitempty"`
			RealMemory      *int64  `json:"real_memory,omitempty"`
			Reason          *string `json:"reason,omitempty"`
			ReasonChangedAt *int64  `json:"reason_changed_at,omitempty"`
			ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`
			Reservation     *string `json:"reservation,omitempty"`

			// ResumeAfter Integer number with flags
			ResumeAfter *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"resume_after,omitempty"`
			SlurmdStartTime   *int64                             `json:"slurmd_start_time,omitempty"`
			Sockets           *int32                             `json:"sockets,omitempty"`
			SpecializedCores  *int32                             `json:"specialized_cores,omitempty"`
			SpecializedCpus   *string                            `json:"specialized_cpus,omitempty"`
			SpecializedMemory *int64                             `json:"specialized_memory,omitempty"`
			State             *[]SlurmV0039GetNodes200NodesState `json:"state,omitempty"`
			TemporaryDisk     *int32                             `json:"temporary_disk,omitempty"`
			Threads           *int32                             `json:"threads,omitempty"`
			Tres              *string                            `json:"tres,omitempty"`
			TresUsed          *string                            `json:"tres_used,omitempty"`
			TresWeighted      *float64                           `json:"tres_weighted,omitempty"`
			Version           *string                            `json:"version,omitempty"`
			Weight            *int32                             `json:"weight,omitempty"`
		} `json:"nodes,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}
type SlurmV0039GetNodes200NodesNextStateAfterReboot string
type SlurmV0039GetNodes200NodesState string

// Status returns HTTPResponse.Status
func (r SlurmV0039GetNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039GetNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039GetPartitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Partitions *[]struct {
			Accounts *struct {
				Allowed *string `json:"allowed,omitempty"`
				Deny    *string `json:"deny,omitempty"`
			} `json:"accounts,omitempty"`
			Alternate *string `json:"alternate,omitempty"`
			Cluster   *string `json:"cluster,omitempty"`
			Cpus      *struct {
				TaskBinding *int32 `json:"task_binding,omitempty"`
				Total       *int32 `json:"total,omitempty"`
			} `json:"cpus,omitempty"`
			Defaults *struct {
				Job          *string `json:"job,omitempty"`
				MemoryPerCpu *int64  `json:"memory_per_cpu,omitempty"`

				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"defaults,omitempty"`
			GraceTime *int32 `json:"grace_time,omitempty"`
			Groups    *struct {
				Allowed *string `json:"allowed,omitempty"`
			} `json:"groups,omitempty"`
			Maximums *struct {
				// CpusPerNode Integer number with flags
				CpusPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_node,omitempty"`

				// CpusPerSocket Integer number with flags
				CpusPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_socket,omitempty"`
				MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

				// Nodes Integer number with flags
				Nodes *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"nodes,omitempty"`

				// OverTimeLimit Integer number with flags
				OverTimeLimit *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"over_time_limit,omitempty"`
				Shares *int32 `json:"shares,omitempty"`

				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"maximums,omitempty"`
			Minimums *struct {
				Nodes *int32 `json:"nodes,omitempty"`
			} `json:"minimums,omitempty"`
			Name     *string `json:"name,omitempty"`
			NodeSets *string `json:"node_sets,omitempty"`
			Nodes    *struct {
				AllowedAllocation *string `json:"allowed_allocation,omitempty"`
				Configured        *string `json:"configured,omitempty"`
				Total             *int32  `json:"total,omitempty"`
			} `json:"nodes,omitempty"`
			Priority *struct {
				JobFactor *int32 `json:"job_factor,omitempty"`
				Tier      *int32 `json:"tier,omitempty"`
			} `json:"priority,omitempty"`
			Qos *struct {
				Allowed  *string `json:"allowed,omitempty"`
				Assigned *string `json:"assigned,omitempty"`
				Deny     *string `json:"deny,omitempty"`
			} `json:"qos,omitempty"`

			// SuspendTime Integer number with flags
			SuspendTime *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"suspend_time,omitempty"`
			Timeouts *struct {
				// Resume Integer number with flags
				Resume *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"resume,omitempty"`

				// Suspend Integer number with flags
				Suspend *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"suspend,omitempty"`
			} `json:"timeouts,omitempty"`
			Tres *struct {
				BillingWeights *string `json:"billing_weights,omitempty"`
				Configured     *string `json:"configured,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"partitions,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Partitions *[]struct {
			Accounts *struct {
				Allowed *string `json:"allowed,omitempty"`
				Deny    *string `json:"deny,omitempty"`
			} `json:"accounts,omitempty"`
			Alternate *string `json:"alternate,omitempty"`
			Cluster   *string `json:"cluster,omitempty"`
			Cpus      *struct {
				TaskBinding *int32 `json:"task_binding,omitempty"`
				Total       *int32 `json:"total,omitempty"`
			} `json:"cpus,omitempty"`
			Defaults *struct {
				Job          *string `json:"job,omitempty"`
				MemoryPerCpu *int64  `json:"memory_per_cpu,omitempty"`

				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"defaults,omitempty"`
			GraceTime *int32 `json:"grace_time,omitempty"`
			Groups    *struct {
				Allowed *string `json:"allowed,omitempty"`
			} `json:"groups,omitempty"`
			Maximums *struct {
				// CpusPerNode Integer number with flags
				CpusPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_node,omitempty"`

				// CpusPerSocket Integer number with flags
				CpusPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_socket,omitempty"`
				MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

				// Nodes Integer number with flags
				Nodes *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"nodes,omitempty"`

				// OverTimeLimit Integer number with flags
				OverTimeLimit *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"over_time_limit,omitempty"`
				Shares *int32 `json:"shares,omitempty"`

				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"maximums,omitempty"`
			Minimums *struct {
				Nodes *int32 `json:"nodes,omitempty"`
			} `json:"minimums,omitempty"`
			Name     *string `json:"name,omitempty"`
			NodeSets *string `json:"node_sets,omitempty"`
			Nodes    *struct {
				AllowedAllocation *string `json:"allowed_allocation,omitempty"`
				Configured        *string `json:"configured,omitempty"`
				Total             *int32  `json:"total,omitempty"`
			} `json:"nodes,omitempty"`
			Priority *struct {
				JobFactor *int32 `json:"job_factor,omitempty"`
				Tier      *int32 `json:"tier,omitempty"`
			} `json:"priority,omitempty"`
			Qos *struct {
				Allowed  *string `json:"allowed,omitempty"`
				Assigned *string `json:"assigned,omitempty"`
				Deny     *string `json:"deny,omitempty"`
			} `json:"qos,omitempty"`

			// SuspendTime Integer number with flags
			SuspendTime *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"suspend_time,omitempty"`
			Timeouts *struct {
				// Resume Integer number with flags
				Resume *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"resume,omitempty"`

				// Suspend Integer number with flags
				Suspend *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"suspend,omitempty"`
			} `json:"timeouts,omitempty"`
			Tres *struct {
				BillingWeights *string `json:"billing_weights,omitempty"`
				Configured     *string `json:"configured,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"partitions,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0039GetPartitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039GetPartitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039GetPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Partitions *[]struct {
			Accounts *struct {
				Allowed *string `json:"allowed,omitempty"`
				Deny    *string `json:"deny,omitempty"`
			} `json:"accounts,omitempty"`
			Alternate *string `json:"alternate,omitempty"`
			Cluster   *string `json:"cluster,omitempty"`
			Cpus      *struct {
				TaskBinding *int32 `json:"task_binding,omitempty"`
				Total       *int32 `json:"total,omitempty"`
			} `json:"cpus,omitempty"`
			Defaults *struct {
				Job          *string `json:"job,omitempty"`
				MemoryPerCpu *int64  `json:"memory_per_cpu,omitempty"`

				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"defaults,omitempty"`
			GraceTime *int32 `json:"grace_time,omitempty"`
			Groups    *struct {
				Allowed *string `json:"allowed,omitempty"`
			} `json:"groups,omitempty"`
			Maximums *struct {
				// CpusPerNode Integer number with flags
				CpusPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_node,omitempty"`

				// CpusPerSocket Integer number with flags
				CpusPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_socket,omitempty"`
				MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

				// Nodes Integer number with flags
				Nodes *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"nodes,omitempty"`

				// OverTimeLimit Integer number with flags
				OverTimeLimit *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"over_time_limit,omitempty"`
				Shares *int32 `json:"shares,omitempty"`

				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"maximums,omitempty"`
			Minimums *struct {
				Nodes *int32 `json:"nodes,omitempty"`
			} `json:"minimums,omitempty"`
			Name     *string `json:"name,omitempty"`
			NodeSets *string `json:"node_sets,omitempty"`
			Nodes    *struct {
				AllowedAllocation *string `json:"allowed_allocation,omitempty"`
				Configured        *string `json:"configured,omitempty"`
				Total             *int32  `json:"total,omitempty"`
			} `json:"nodes,omitempty"`
			Priority *struct {
				JobFactor *int32 `json:"job_factor,omitempty"`
				Tier      *int32 `json:"tier,omitempty"`
			} `json:"priority,omitempty"`
			Qos *struct {
				Allowed  *string `json:"allowed,omitempty"`
				Assigned *string `json:"assigned,omitempty"`
				Deny     *string `json:"deny,omitempty"`
			} `json:"qos,omitempty"`

			// SuspendTime Integer number with flags
			SuspendTime *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"suspend_time,omitempty"`
			Timeouts *struct {
				// Resume Integer number with flags
				Resume *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"resume,omitempty"`

				// Suspend Integer number with flags
				Suspend *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"suspend,omitempty"`
			} `json:"timeouts,omitempty"`
			Tres *struct {
				BillingWeights *string `json:"billing_weights,omitempty"`
				Configured     *string `json:"configured,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"partitions,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Partitions *[]struct {
			Accounts *struct {
				Allowed *string `json:"allowed,omitempty"`
				Deny    *string `json:"deny,omitempty"`
			} `json:"accounts,omitempty"`
			Alternate *string `json:"alternate,omitempty"`
			Cluster   *string `json:"cluster,omitempty"`
			Cpus      *struct {
				TaskBinding *int32 `json:"task_binding,omitempty"`
				Total       *int32 `json:"total,omitempty"`
			} `json:"cpus,omitempty"`
			Defaults *struct {
				Job          *string `json:"job,omitempty"`
				MemoryPerCpu *int64  `json:"memory_per_cpu,omitempty"`

				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"defaults,omitempty"`
			GraceTime *int32 `json:"grace_time,omitempty"`
			Groups    *struct {
				Allowed *string `json:"allowed,omitempty"`
			} `json:"groups,omitempty"`
			Maximums *struct {
				// CpusPerNode Integer number with flags
				CpusPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_node,omitempty"`

				// CpusPerSocket Integer number with flags
				CpusPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_socket,omitempty"`
				MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

				// Nodes Integer number with flags
				Nodes *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"nodes,omitempty"`

				// OverTimeLimit Integer number with flags
				OverTimeLimit *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"over_time_limit,omitempty"`
				Shares *int32 `json:"shares,omitempty"`

				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"maximums,omitempty"`
			Minimums *struct {
				Nodes *int32 `json:"nodes,omitempty"`
			} `json:"minimums,omitempty"`
			Name     *string `json:"name,omitempty"`
			NodeSets *string `json:"node_sets,omitempty"`
			Nodes    *struct {
				AllowedAllocation *string `json:"allowed_allocation,omitempty"`
				Configured        *string `json:"configured,omitempty"`
				Total             *int32  `json:"total,omitempty"`
			} `json:"nodes,omitempty"`
			Priority *struct {
				JobFactor *int32 `json:"job_factor,omitempty"`
				Tier      *int32 `json:"tier,omitempty"`
			} `json:"priority,omitempty"`
			Qos *struct {
				Allowed  *string `json:"allowed,omitempty"`
				Assigned *string `json:"assigned,omitempty"`
				Deny     *string `json:"deny,omitempty"`
			} `json:"qos,omitempty"`

			// SuspendTime Integer number with flags
			SuspendTime *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"suspend_time,omitempty"`
			Timeouts *struct {
				// Resume Integer number with flags
				Resume *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"resume,omitempty"`

				// Suspend Integer number with flags
				Suspend *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"suspend,omitempty"`
			} `json:"timeouts,omitempty"`
			Tres *struct {
				BillingWeights *string `json:"billing_weights,omitempty"`
				Configured     *string `json:"configured,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"partitions,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0039GetPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039GetPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039PingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Pings *[]struct {
			Hostname *string `json:"hostname,omitempty"`
			Latency  *int64  `json:"latency,omitempty"`
			Mode     *string `json:"mode,omitempty"`
			Pinged   *string `json:"pinged,omitempty"`
		} `json:"pings,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Pings *[]struct {
			Hostname *string `json:"hostname,omitempty"`
			Latency  *int64  `json:"latency,omitempty"`
			Mode     *string `json:"mode,omitempty"`
			Pinged   *string `json:"pinged,omitempty"`
		} `json:"pings,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0039PingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039PingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039GetReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Reservations *[]struct {
			Accounts            *string `json:"accounts,omitempty"`
			BurstBuffer         *string `json:"burst_buffer,omitempty"`
			CoreCount           *int32  `json:"core_count,omitempty"`
			CoreSpecializations *[]struct {
				Core *string `json:"core,omitempty"`
				Node *string `json:"node,omitempty"`
			} `json:"core_specializations,omitempty"`
			EndTime        *int64                                          `json:"end_time,omitempty"`
			Features       *string                                         `json:"features,omitempty"`
			Flags          *[]SlurmV0039GetReservation200ReservationsFlags `json:"flags,omitempty"`
			Groups         *string                                         `json:"groups,omitempty"`
			Licenses       *string                                         `json:"licenses,omitempty"`
			MaxStartDelay  *int32                                          `json:"max_start_delay,omitempty"`
			Name           *string                                         `json:"name,omitempty"`
			NodeCount      *int32                                          `json:"node_count,omitempty"`
			NodeList       *string                                         `json:"node_list,omitempty"`
			Partition      *string                                         `json:"partition,omitempty"`
			PurgeCompleted *struct {
				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"purge_completed,omitempty"`
			StartTime *int64  `json:"start_time,omitempty"`
			Tres      *string `json:"tres,omitempty"`
			Users     *string `json:"users,omitempty"`

			// Watts Integer number with flags
			Watts *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"watts,omitempty"`
		} `json:"reservations,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Reservations *[]struct {
			Accounts            *string `json:"accounts,omitempty"`
			BurstBuffer         *string `json:"burst_buffer,omitempty"`
			CoreCount           *int32  `json:"core_count,omitempty"`
			CoreSpecializations *[]struct {
				Core *string `json:"core,omitempty"`
				Node *string `json:"node,omitempty"`
			} `json:"core_specializations,omitempty"`
			EndTime        *int64                                          `json:"end_time,omitempty"`
			Features       *string                                         `json:"features,omitempty"`
			Flags          *[]SlurmV0039GetReservation200ReservationsFlags `json:"flags,omitempty"`
			Groups         *string                                         `json:"groups,omitempty"`
			Licenses       *string                                         `json:"licenses,omitempty"`
			MaxStartDelay  *int32                                          `json:"max_start_delay,omitempty"`
			Name           *string                                         `json:"name,omitempty"`
			NodeCount      *int32                                          `json:"node_count,omitempty"`
			NodeList       *string                                         `json:"node_list,omitempty"`
			Partition      *string                                         `json:"partition,omitempty"`
			PurgeCompleted *struct {
				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"purge_completed,omitempty"`
			StartTime *int64  `json:"start_time,omitempty"`
			Tres      *string `json:"tres,omitempty"`
			Users     *string `json:"users,omitempty"`

			// Watts Integer number with flags
			Watts *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"watts,omitempty"`
		} `json:"reservations,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}
type SlurmV0039GetReservation200ReservationsFlags string

// Status returns HTTPResponse.Status
func (r SlurmV0039GetReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039GetReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0039GetReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Reservations *[]struct {
			Accounts            *string `json:"accounts,omitempty"`
			BurstBuffer         *string `json:"burst_buffer,omitempty"`
			CoreCount           *int32  `json:"core_count,omitempty"`
			CoreSpecializations *[]struct {
				Core *string `json:"core,omitempty"`
				Node *string `json:"node,omitempty"`
			} `json:"core_specializations,omitempty"`
			EndTime        *int64                                           `json:"end_time,omitempty"`
			Features       *string                                          `json:"features,omitempty"`
			Flags          *[]SlurmV0039GetReservations200ReservationsFlags `json:"flags,omitempty"`
			Groups         *string                                          `json:"groups,omitempty"`
			Licenses       *string                                          `json:"licenses,omitempty"`
			MaxStartDelay  *int32                                           `json:"max_start_delay,omitempty"`
			Name           *string                                          `json:"name,omitempty"`
			NodeCount      *int32                                           `json:"node_count,omitempty"`
			NodeList       *string                                          `json:"node_list,omitempty"`
			Partition      *string                                          `json:"partition,omitempty"`
			PurgeCompleted *struct {
				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"purge_completed,omitempty"`
			StartTime *int64  `json:"start_time,omitempty"`
			Tres      *string `json:"tres,omitempty"`
			Users     *string `json:"users,omitempty"`

			// Watts Integer number with flags
			Watts *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"watts,omitempty"`
		} `json:"reservations,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAML200 *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`
		Reservations *[]struct {
			Accounts            *string `json:"accounts,omitempty"`
			BurstBuffer         *string `json:"burst_buffer,omitempty"`
			CoreCount           *int32  `json:"core_count,omitempty"`
			CoreSpecializations *[]struct {
				Core *string `json:"core,omitempty"`
				Node *string `json:"node,omitempty"`
			} `json:"core_specializations,omitempty"`
			EndTime        *int64                                           `json:"end_time,omitempty"`
			Features       *string                                          `json:"features,omitempty"`
			Flags          *[]SlurmV0039GetReservations200ReservationsFlags `json:"flags,omitempty"`
			Groups         *string                                          `json:"groups,omitempty"`
			Licenses       *string                                          `json:"licenses,omitempty"`
			MaxStartDelay  *int32                                           `json:"max_start_delay,omitempty"`
			Name           *string                                          `json:"name,omitempty"`
			NodeCount      *int32                                           `json:"node_count,omitempty"`
			NodeList       *string                                          `json:"node_list,omitempty"`
			Partition      *string                                          `json:"partition,omitempty"`
			PurgeCompleted *struct {
				// Time Integer number with flags
				Time *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time,omitempty"`
			} `json:"purge_completed,omitempty"`
			StartTime *int64  `json:"start_time,omitempty"`
			Tres      *string `json:"tres,omitempty"`
			Users     *string `json:"users,omitempty"`

			// Watts Integer number with flags
			Watts *struct {
				// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
				Infinite *bool `json:"infinite,omitempty"`

				// Number If set is True the number will be set with value. Otherwise ignore number contents.
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set. False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"watts,omitempty"`
		} `json:"reservations,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
	YAMLDefault *struct {
		// Errors Slurm errors
		Errors *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm internal error number
			ErrorNumber *int `json:"error_number,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`
		Meta *struct {
			// Slurm Slurm information
			Slurm *struct {
				// Release version specifier
				Release *string `json:"release,omitempty"`
				Version *struct {
					Major *int `json:"major,omitempty"`
					Micro *int `json:"micro,omitempty"`
					Minor *int `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"Slurm,omitempty"`
			Plugin *struct {
				Name *string `json:"name,omitempty"`
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Slurm warnings
		Warnings *[]struct {
			// Description Explanation of cause of error
			Description *string `json:"description,omitempty"`

			// Source Where error occurred in the source
			Source *string `json:"source,omitempty"`

			// Warning Earning message
			Warning *string `json:"warning,omitempty"`
		} `json:"warnings,omitempty"`
	}
}
type SlurmV0039GetReservations200ReservationsFlags string

// Status returns HTTPResponse.Status
func (r SlurmV0039GetReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0039GetReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetOpenapiWithResponse request returning *GetOpenapiResponse
func (c *ClientWithResponses) GetOpenapiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiResponse, error) {
	rsp, err := c.GetOpenapi(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiResponse(rsp)
}

// GetOpenapiJsonWithResponse request returning *GetOpenapiJsonResponse
func (c *ClientWithResponses) GetOpenapiJsonWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiJsonResponse, error) {
	rsp, err := c.GetOpenapiJson(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiJsonResponse(rsp)
}

// GetOpenapiYamlWithResponse request returning *GetOpenapiYamlResponse
func (c *ClientWithResponses) GetOpenapiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiYamlResponse, error) {
	rsp, err := c.GetOpenapiYaml(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiYamlResponse(rsp)
}

// GetOpenapiV3WithResponse request returning *GetOpenapiV3Response
func (c *ClientWithResponses) GetOpenapiV3WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiV3Response, error) {
	rsp, err := c.GetOpenapiV3(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiV3Response(rsp)
}

// SlurmV0039DiagWithResponse request returning *SlurmV0039DiagResponse
func (c *ClientWithResponses) SlurmV0039DiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0039DiagResponse, error) {
	rsp, err := c.SlurmV0039Diag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039DiagResponse(rsp)
}

// SlurmV0039SubmitJobWithBodyWithResponse request with arbitrary body returning *SlurmV0039SubmitJobResponse
func (c *ClientWithResponses) SlurmV0039SubmitJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0039SubmitJobResponse, error) {
	rsp, err := c.SlurmV0039SubmitJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039SubmitJobResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0039SubmitJobWithResponse(ctx context.Context, body SlurmV0039SubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0039SubmitJobResponse, error) {
	rsp, err := c.SlurmV0039SubmitJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039SubmitJobResponse(rsp)
}

// SlurmV0039CancelJobWithResponse request returning *SlurmV0039CancelJobResponse
func (c *ClientWithResponses) SlurmV0039CancelJobWithResponse(ctx context.Context, jobId string, params *SlurmV0039CancelJobParams, reqEditors ...RequestEditorFn) (*SlurmV0039CancelJobResponse, error) {
	rsp, err := c.SlurmV0039CancelJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039CancelJobResponse(rsp)
}

// SlurmV0039GetJobWithResponse request returning *SlurmV0039GetJobResponse
func (c *ClientWithResponses) SlurmV0039GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmV0039GetJobResponse, error) {
	rsp, err := c.SlurmV0039GetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039GetJobResponse(rsp)
}

// SlurmV0039UpdateJobWithBodyWithResponse request with arbitrary body returning *SlurmV0039UpdateJobResponse
func (c *ClientWithResponses) SlurmV0039UpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0039UpdateJobResponse, error) {
	rsp, err := c.SlurmV0039UpdateJobWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039UpdateJobResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0039UpdateJobWithResponse(ctx context.Context, jobId string, body SlurmV0039UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0039UpdateJobResponse, error) {
	rsp, err := c.SlurmV0039UpdateJob(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039UpdateJobResponse(rsp)
}

// SlurmV0039GetJobsWithResponse request returning *SlurmV0039GetJobsResponse
func (c *ClientWithResponses) SlurmV0039GetJobsWithResponse(ctx context.Context, params *SlurmV0039GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetJobsResponse, error) {
	rsp, err := c.SlurmV0039GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039GetJobsResponse(rsp)
}

// SlurmV0039SlurmctldGetLicensesWithResponse request returning *SlurmV0039SlurmctldGetLicensesResponse
func (c *ClientWithResponses) SlurmV0039SlurmctldGetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0039SlurmctldGetLicensesResponse, error) {
	rsp, err := c.SlurmV0039SlurmctldGetLicenses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039SlurmctldGetLicensesResponse(rsp)
}

// SlurmV0039DeleteNodeWithResponse request returning *SlurmV0039DeleteNodeResponse
func (c *ClientWithResponses) SlurmV0039DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0039DeleteNodeResponse, error) {
	rsp, err := c.SlurmV0039DeleteNode(ctx, nodeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039DeleteNodeResponse(rsp)
}

// SlurmV0039GetNodeWithResponse request returning *SlurmV0039GetNodeResponse
func (c *ClientWithResponses) SlurmV0039GetNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0039GetNodeResponse, error) {
	rsp, err := c.SlurmV0039GetNode(ctx, nodeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039GetNodeResponse(rsp)
}

// SlurmV0039UpdateNodeWithBodyWithResponse request with arbitrary body returning *SlurmV0039UpdateNodeResponse
func (c *ClientWithResponses) SlurmV0039UpdateNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0039UpdateNodeResponse, error) {
	rsp, err := c.SlurmV0039UpdateNodeWithBody(ctx, nodeName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039UpdateNodeResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0039UpdateNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0039UpdateNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0039UpdateNodeResponse, error) {
	rsp, err := c.SlurmV0039UpdateNode(ctx, nodeName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039UpdateNodeResponse(rsp)
}

// SlurmV0039GetNodesWithResponse request returning *SlurmV0039GetNodesResponse
func (c *ClientWithResponses) SlurmV0039GetNodesWithResponse(ctx context.Context, params *SlurmV0039GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetNodesResponse, error) {
	rsp, err := c.SlurmV0039GetNodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039GetNodesResponse(rsp)
}

// SlurmV0039GetPartitionWithResponse request returning *SlurmV0039GetPartitionResponse
func (c *ClientWithResponses) SlurmV0039GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0039GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetPartitionResponse, error) {
	rsp, err := c.SlurmV0039GetPartition(ctx, partitionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039GetPartitionResponse(rsp)
}

// SlurmV0039GetPartitionsWithResponse request returning *SlurmV0039GetPartitionsResponse
func (c *ClientWithResponses) SlurmV0039GetPartitionsWithResponse(ctx context.Context, params *SlurmV0039GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetPartitionsResponse, error) {
	rsp, err := c.SlurmV0039GetPartitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039GetPartitionsResponse(rsp)
}

// SlurmV0039PingWithResponse request returning *SlurmV0039PingResponse
func (c *ClientWithResponses) SlurmV0039PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0039PingResponse, error) {
	rsp, err := c.SlurmV0039Ping(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039PingResponse(rsp)
}

// SlurmV0039GetReservationWithResponse request returning *SlurmV0039GetReservationResponse
func (c *ClientWithResponses) SlurmV0039GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0039GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetReservationResponse, error) {
	rsp, err := c.SlurmV0039GetReservation(ctx, reservationName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039GetReservationResponse(rsp)
}

// SlurmV0039GetReservationsWithResponse request returning *SlurmV0039GetReservationsResponse
func (c *ClientWithResponses) SlurmV0039GetReservationsWithResponse(ctx context.Context, params *SlurmV0039GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0039GetReservationsResponse, error) {
	rsp, err := c.SlurmV0039GetReservations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0039GetReservationsResponse(rsp)
}

// ParseGetOpenapiResponse parses an HTTP response from a GetOpenapiWithResponse call
func ParseGetOpenapiResponse(rsp *http.Response) (*GetOpenapiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOpenapiJsonResponse parses an HTTP response from a GetOpenapiJsonWithResponse call
func ParseGetOpenapiJsonResponse(rsp *http.Response) (*GetOpenapiJsonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiJsonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOpenapiYamlResponse parses an HTTP response from a GetOpenapiYamlWithResponse call
func ParseGetOpenapiYamlResponse(rsp *http.Response) (*GetOpenapiYamlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiYamlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOpenapiV3Response parses an HTTP response from a GetOpenapiV3WithResponse call
func ParseGetOpenapiV3Response(rsp *http.Response) (*GetOpenapiV3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiV3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSlurmV0039DiagResponse parses an HTTP response from a SlurmV0039DiagWithResponse call
func ParseSlurmV0039DiagResponse(rsp *http.Response) (*SlurmV0039DiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039DiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Statistics *struct {
				AgentCount           *int32 `json:"agent_count,omitempty"`
				AgentQueueSize       *int32 `json:"agent_queue_size,omitempty"`
				AgentThreadCount     *int32 `json:"agent_thread_count,omitempty"`
				BfActive             *bool  `json:"bf_active,omitempty"`
				BfBackfilledHetJobs  *int32 `json:"bf_backfilled_het_jobs,omitempty"`
				BfBackfilledJobs     *int32 `json:"bf_backfilled_jobs,omitempty"`
				BfCycleCounter       *int32 `json:"bf_cycle_counter,omitempty"`
				BfCycleLast          *int32 `json:"bf_cycle_last,omitempty"`
				BfCycleMean          *int64 `json:"bf_cycle_mean,omitempty"`
				BfCycleSum           *int64 `json:"bf_cycle_sum,omitempty"`
				BfDepthMean          *int64 `json:"bf_depth_mean,omitempty"`
				BfDepthMeanTry       *int64 `json:"bf_depth_mean_try,omitempty"`
				BfDepthSum           *int32 `json:"bf_depth_sum,omitempty"`
				BfDepthTrySum        *int32 `json:"bf_depth_try_sum,omitempty"`
				BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`
				BfLastDepth          *int32 `json:"bf_last_depth,omitempty"`
				BfLastDepthTry       *int32 `json:"bf_last_depth_try,omitempty"`
				BfQueueLen           *int32 `json:"bf_queue_len,omitempty"`
				BfQueueLenMean       *int64 `json:"bf_queue_len_mean,omitempty"`
				BfQueueLenSum        *int32 `json:"bf_queue_len_sum,omitempty"`
				BfTableSize          *int32 `json:"bf_table_size,omitempty"`
				BfTableSizeMean      *int64 `json:"bf_table_size_mean,omitempty"`
				BfWhenLastCycle      *int64 `json:"bf_when_last_cycle,omitempty"`
				DbdAgentQueueSize    *int32 `json:"dbd_agent_queue_size,omitempty"`
				GettimeofdayLatency  *int32 `json:"gettimeofday_latency,omitempty"`
				JobStatesTs          *int64 `json:"job_states_ts,omitempty"`
				JobsCanceled         *int32 `json:"jobs_canceled,omitempty"`
				JobsCompleted        *int32 `json:"jobs_completed,omitempty"`
				JobsFailed           *int32 `json:"jobs_failed,omitempty"`
				JobsPending          *int32 `json:"jobs_pending,omitempty"`
				JobsRunning          *int32 `json:"jobs_running,omitempty"`
				JobsStarted          *int32 `json:"jobs_started,omitempty"`
				JobsSubmitted        *int32 `json:"jobs_submitted,omitempty"`
				PartsPacked          *int32 `json:"parts_packed,omitempty"`
				ReqTime              *int64 `json:"req_time,omitempty"`
				ReqTimeStart         *int64 `json:"req_time_start,omitempty"`

				// RpcsByMessageType RPCs by message type
				RpcsByMessageType *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime *int64 `json:"average_time,omitempty"`

					// Count Number of RPCs received
					Count *int64 `json:"count,omitempty"`

					// MessageType Message type as string
					MessageType *string `json:"message_type,omitempty"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime *int64 `json:"total_time,omitempty"`

					// TypeId Message type as integer
					TypeId *int32 `json:"type_id,omitempty"`
				} `json:"rpcs_by_message_type,omitempty"`

				// RpcsByUser RPCs by user
				RpcsByUser *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime *int64 `json:"average_time,omitempty"`

					// Count Number of RPCs received
					Count *int64 `json:"count,omitempty"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime *int64 `json:"total_time,omitempty"`

					// User user name
					User *string `json:"user,omitempty"`

					// UserId user id (numeric)
					UserId *int32 `json:"user_id,omitempty"`
				} `json:"rpcs_by_user,omitempty"`
				ScheduleCycleLast      *int32 `json:"schedule_cycle_last,omitempty"`
				ScheduleCycleMax       *int32 `json:"schedule_cycle_max,omitempty"`
				ScheduleCycleMean      *int64 `json:"schedule_cycle_mean,omitempty"`
				ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`
				ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`
				ScheduleCycleTotal     *int32 `json:"schedule_cycle_total,omitempty"`
				ScheduleQueueLength    *int32 `json:"schedule_queue_length,omitempty"`
				ServerThreadCount      *int32 `json:"server_thread_count,omitempty"`
			} `json:"statistics,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Statistics *struct {
				AgentCount           *int32 `json:"agent_count,omitempty"`
				AgentQueueSize       *int32 `json:"agent_queue_size,omitempty"`
				AgentThreadCount     *int32 `json:"agent_thread_count,omitempty"`
				BfActive             *bool  `json:"bf_active,omitempty"`
				BfBackfilledHetJobs  *int32 `json:"bf_backfilled_het_jobs,omitempty"`
				BfBackfilledJobs     *int32 `json:"bf_backfilled_jobs,omitempty"`
				BfCycleCounter       *int32 `json:"bf_cycle_counter,omitempty"`
				BfCycleLast          *int32 `json:"bf_cycle_last,omitempty"`
				BfCycleMean          *int64 `json:"bf_cycle_mean,omitempty"`
				BfCycleSum           *int64 `json:"bf_cycle_sum,omitempty"`
				BfDepthMean          *int64 `json:"bf_depth_mean,omitempty"`
				BfDepthMeanTry       *int64 `json:"bf_depth_mean_try,omitempty"`
				BfDepthSum           *int32 `json:"bf_depth_sum,omitempty"`
				BfDepthTrySum        *int32 `json:"bf_depth_try_sum,omitempty"`
				BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`
				BfLastDepth          *int32 `json:"bf_last_depth,omitempty"`
				BfLastDepthTry       *int32 `json:"bf_last_depth_try,omitempty"`
				BfQueueLen           *int32 `json:"bf_queue_len,omitempty"`
				BfQueueLenMean       *int64 `json:"bf_queue_len_mean,omitempty"`
				BfQueueLenSum        *int32 `json:"bf_queue_len_sum,omitempty"`
				BfTableSize          *int32 `json:"bf_table_size,omitempty"`
				BfTableSizeMean      *int64 `json:"bf_table_size_mean,omitempty"`
				BfWhenLastCycle      *int64 `json:"bf_when_last_cycle,omitempty"`
				DbdAgentQueueSize    *int32 `json:"dbd_agent_queue_size,omitempty"`
				GettimeofdayLatency  *int32 `json:"gettimeofday_latency,omitempty"`
				JobStatesTs          *int64 `json:"job_states_ts,omitempty"`
				JobsCanceled         *int32 `json:"jobs_canceled,omitempty"`
				JobsCompleted        *int32 `json:"jobs_completed,omitempty"`
				JobsFailed           *int32 `json:"jobs_failed,omitempty"`
				JobsPending          *int32 `json:"jobs_pending,omitempty"`
				JobsRunning          *int32 `json:"jobs_running,omitempty"`
				JobsStarted          *int32 `json:"jobs_started,omitempty"`
				JobsSubmitted        *int32 `json:"jobs_submitted,omitempty"`
				PartsPacked          *int32 `json:"parts_packed,omitempty"`
				ReqTime              *int64 `json:"req_time,omitempty"`
				ReqTimeStart         *int64 `json:"req_time_start,omitempty"`

				// RpcsByMessageType RPCs by message type
				RpcsByMessageType *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime *int64 `json:"average_time,omitempty"`

					// Count Number of RPCs received
					Count *int64 `json:"count,omitempty"`

					// MessageType Message type as string
					MessageType *string `json:"message_type,omitempty"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime *int64 `json:"total_time,omitempty"`

					// TypeId Message type as integer
					TypeId *int32 `json:"type_id,omitempty"`
				} `json:"rpcs_by_message_type,omitempty"`

				// RpcsByUser RPCs by user
				RpcsByUser *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime *int64 `json:"average_time,omitempty"`

					// Count Number of RPCs received
					Count *int64 `json:"count,omitempty"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime *int64 `json:"total_time,omitempty"`

					// User user name
					User *string `json:"user,omitempty"`

					// UserId user id (numeric)
					UserId *int32 `json:"user_id,omitempty"`
				} `json:"rpcs_by_user,omitempty"`
				ScheduleCycleLast      *int32 `json:"schedule_cycle_last,omitempty"`
				ScheduleCycleMax       *int32 `json:"schedule_cycle_max,omitempty"`
				ScheduleCycleMean      *int64 `json:"schedule_cycle_mean,omitempty"`
				ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`
				ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`
				ScheduleCycleTotal     *int32 `json:"schedule_cycle_total,omitempty"`
				ScheduleQueueLength    *int32 `json:"schedule_queue_length,omitempty"`
				ServerThreadCount      *int32 `json:"server_thread_count,omitempty"`
			} `json:"statistics,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039SubmitJobResponse parses an HTTP response from a SlurmV0039SubmitJobWithResponse call
func ParseSlurmV0039SubmitJobResponse(rsp *http.Response) (*SlurmV0039SubmitJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039SubmitJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId new job ID
			JobId *int `json:"job_id,omitempty"`

			// JobSubmitUserMsg Message to user from job_submit plugin
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`
			Meta             *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// StepId new job step ID
			StepId *string `json:"step_id,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId new job ID
			JobId *int `json:"job_id,omitempty"`

			// JobSubmitUserMsg Message to user from job_submit plugin
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`
			Meta             *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// StepId new job step ID
			StepId *string `json:"step_id,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039CancelJobResponse parses an HTTP response from a SlurmV0039CancelJobWithResponse call
func ParseSlurmV0039CancelJobResponse(rsp *http.Response) (*SlurmV0039CancelJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039CancelJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039GetJobResponse parses an HTTP response from a SlurmV0039GetJobWithResponse call
func ParseSlurmV0039GetJobResponse(rsp *http.Response) (*SlurmV0039GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Jobs *[]struct {
				Account        *string `json:"account,omitempty"`
				AccrueTime     *int64  `json:"accrue_time,omitempty"`
				AdminComment   *string `json:"admin_comment,omitempty"`
				AllocatingNode *string `json:"allocating_node,omitempty"`

				// ArrayJobId Integer number with flags
				ArrayJobId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_job_id,omitempty"`

				// ArrayMaxTasks Integer number with flags
				ArrayMaxTasks *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_max_tasks,omitempty"`

				// ArrayTaskId Integer number with flags
				ArrayTaskId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_task_id,omitempty"`
				ArrayTaskString *string `json:"array_task_string,omitempty"`
				AssociationId   *int32  `json:"association_id,omitempty"`
				BatchFeatures   *string `json:"batch_features,omitempty"`
				BatchFlag       *bool   `json:"batch_flag,omitempty"`
				BatchHost       *string `json:"batch_host,omitempty"`

				// BillableTres 64 bit floating point number with flags
				BillableTres *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *float64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"billable_tres,omitempty"`
				BurstBuffer      *string `json:"burst_buffer,omitempty"`
				BurstBufferState *string `json:"burst_buffer_state,omitempty"`
				Cluster          *string `json:"cluster,omitempty"`
				ClusterFeatures  *string `json:"cluster_features,omitempty"`
				Command          *string `json:"command,omitempty"`
				Comment          *string `json:"comment,omitempty"`
				Container        *string `json:"container,omitempty"`
				ContainerId      *string `json:"container_id,omitempty"`
				Contiguous       *bool   `json:"contiguous,omitempty"`
				CoreSpec         *int32  `json:"core_spec,omitempty"`

				// CoresPerSocket Integer number with flags
				CoresPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cores_per_socket,omitempty"`

				// CpuFrequencyGovernor Integer number with flags
				CpuFrequencyGovernor *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_governor,omitempty"`

				// CpuFrequencyMaximum Integer number with flags
				CpuFrequencyMaximum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_maximum,omitempty"`

				// CpuFrequencyMinimum Integer number with flags
				CpuFrequencyMinimum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_minimum,omitempty"`

				// Cpus Integer number with flags
				Cpus *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus,omitempty"`

				// CpusPerTask Integer number with flags
				CpusPerTask *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_task,omitempty"`
				CpusPerTres             *string `json:"cpus_per_tres,omitempty"`
				Cron                    *string `json:"cron,omitempty"`
				CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`
				Deadline                *int64  `json:"deadline,omitempty"`

				// DelayBoot Integer number with flags
				DelayBoot *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"delay_boot,omitempty"`
				Dependency *string `json:"dependency,omitempty"`

				// DerivedExitCode Integer number with flags
				DerivedExitCode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"derived_exit_code,omitempty"`
				EligibleTime  *int64                              `json:"eligible_time,omitempty"`
				EndTime       *int64                              `json:"end_time,omitempty"`
				ExcludedNodes *string                             `json:"excluded_nodes,omitempty"`
				Exclusive     *[]SlurmV0039GetJob200JobsExclusive `json:"exclusive,omitempty"`

				// ExitCode Integer number with flags
				ExitCode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"exit_code,omitempty"`
				Extra                    *string                         `json:"extra,omitempty"`
				FailedNode               *string                         `json:"failed_node,omitempty"`
				Features                 *string                         `json:"features,omitempty"`
				FederationOrigin         *string                         `json:"federation_origin,omitempty"`
				FederationSiblingsActive *string                         `json:"federation_siblings_active,omitempty"`
				FederationSiblingsViable *string                         `json:"federation_siblings_viable,omitempty"`
				Flags                    *[]SlurmV0039GetJob200JobsFlags `json:"flags,omitempty"`
				GresDetail               *[]string                       `json:"gres_detail,omitempty"`
				GroupId                  *int32                          `json:"group_id,omitempty"`
				GroupName                *string                         `json:"group_name,omitempty"`

				// HetJobId Integer number with flags
				HetJobId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"het_job_id,omitempty"`
				HetJobIdSet *string `json:"het_job_id_set,omitempty"`

				// HetJobOffset Integer number with flags
				HetJobOffset *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"het_job_offset,omitempty"`

				// Hold Hold (true) or release (false) job
				Hold         *bool  `json:"hold,omitempty"`
				JobId        *int32 `json:"job_id,omitempty"`
				JobResources *struct {
					AllocatedCores *int32 `json:"allocated_cores,omitempty"`
					AllocatedCpus  *int32 `json:"allocated_cpus,omitempty"`
					AllocatedHosts *int32 `json:"allocated_hosts,omitempty"`

					// AllocatedNodes job node resources
					AllocatedNodes *[]interface{} `json:"allocated_nodes,omitempty"`
					Nodes          *string        `json:"nodes,omitempty"`
				} `json:"job_resources,omitempty"`
				JobSizeStr          *[]string                          `json:"job_size_str,omitempty"`
				JobState            *string                            `json:"job_state,omitempty"`
				LastSchedEvaluation *int64                             `json:"last_sched_evaluation,omitempty"`
				Licenses            *string                            `json:"licenses,omitempty"`
				MailType            *[]SlurmV0039GetJob200JobsMailType `json:"mail_type,omitempty"`
				MailUser            *string                            `json:"mail_user,omitempty"`

				// MaxCpus Integer number with flags
				MaxCpus *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"max_cpus,omitempty"`

				// MaxNodes Integer number with flags
				MaxNodes *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"max_nodes,omitempty"`
				MaximumSwitchWaitTime *int32  `json:"maximum_switch_wait_time,omitempty"`
				McsLabel              *string `json:"mcs_label,omitempty"`

				// MemoryPerCpu Integer number with flags
				MemoryPerCpu *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"memory_per_cpu,omitempty"`

				// MemoryPerNode Integer number with flags
				MemoryPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"memory_per_node,omitempty"`
				MemoryPerTres *string `json:"memory_per_tres,omitempty"`

				// MinimumCpusPerNode Integer number with flags
				MinimumCpusPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"minimum_cpus_per_node,omitempty"`
				MinimumSwitches *int32 `json:"minimum_switches,omitempty"`

				// MinimumTmpDiskPerNode Integer number with flags
				MinimumTmpDiskPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"minimum_tmp_disk_per_node,omitempty"`
				Name    *string `json:"name,omitempty"`
				Network *string `json:"network,omitempty"`
				Nice    *int32  `json:"nice,omitempty"`

				// NodeCount Integer number with flags
				NodeCount *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"node_count,omitempty"`
				Nodes         *string `json:"nodes,omitempty"`
				Oversubscribe *bool   `json:"oversubscribe,omitempty"`
				Partition     *string `json:"partition,omitempty"`
				Power         *struct {
					Flags *[]SlurmV0039GetJob200JobsPowerFlags `json:"flags,omitempty"`
				} `json:"power,omitempty"`
				PreSusTime      *int64  `json:"pre_sus_time,omitempty"`
				PreemptTime     *int64  `json:"preempt_time,omitempty"`
				PreemptableTime *int64  `json:"preemptable_time,omitempty"`
				Prefer          *string `json:"prefer,omitempty"`

				// Priority Integer number with flags
				Priority *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"priority,omitempty"`
				Profile         *[]SlurmV0039GetJob200JobsProfile   `json:"profile,omitempty"`
				Qos             *string                             `json:"qos,omitempty"`
				Reboot          *bool                               `json:"reboot,omitempty"`
				Requeue         *bool                               `json:"requeue,omitempty"`
				RequiredNodes   *string                             `json:"required_nodes,omitempty"`
				ResizeTime      *int64                              `json:"resize_time,omitempty"`
				RestartCnt      *int32                              `json:"restart_cnt,omitempty"`
				ResvName        *string                             `json:"resv_name,omitempty"`
				ScheduledNodes  *string                             `json:"scheduled_nodes,omitempty"`
				SelinuxContext  *string                             `json:"selinux_context,omitempty"`
				Shared          *[]SlurmV0039GetJob200JobsShared    `json:"shared,omitempty"`
				ShowFlags       *[]SlurmV0039GetJob200JobsShowFlags `json:"show_flags,omitempty"`
				SocketsPerBoard *int32                              `json:"sockets_per_board,omitempty"`

				// SocketsPerNode Integer number with flags
				SocketsPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"sockets_per_node,omitempty"`
				StandardError    *string `json:"standard_error,omitempty"`
				StandardInput    *string `json:"standard_input,omitempty"`
				StandardOutput   *string `json:"standard_output,omitempty"`
				StartTime        *int64  `json:"start_time,omitempty"`
				StateDescription *string `json:"state_description,omitempty"`
				StateReason      *string `json:"state_reason,omitempty"`
				SubmitTime       *int64  `json:"submit_time,omitempty"`
				SuspendTime      *int64  `json:"suspend_time,omitempty"`
				SystemComment    *string `json:"system_comment,omitempty"`

				// Tasks Integer number with flags
				Tasks *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks,omitempty"`

				// TasksPerBoard Integer number with flags
				TasksPerBoard *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_board,omitempty"`

				// TasksPerCore Integer number with flags
				TasksPerCore *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_core,omitempty"`

				// TasksPerNode Integer number with flags
				TasksPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_node,omitempty"`

				// TasksPerSocket Integer number with flags
				TasksPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_socket,omitempty"`

				// TasksPerTres Integer number with flags
				TasksPerTres *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_tres,omitempty"`
				ThreadSpec *int32 `json:"thread_spec,omitempty"`

				// ThreadsPerCore Integer number with flags
				ThreadsPerCore *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"threads_per_core,omitempty"`

				// TimeLimit Integer number with flags
				TimeLimit *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time_limit,omitempty"`

				// TimeMinimum Integer number with flags
				TimeMinimum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time_minimum,omitempty"`
				TresAllocStr  *string `json:"tres_alloc_str,omitempty"`
				TresBind      *string `json:"tres_bind,omitempty"`
				TresFreq      *string `json:"tres_freq,omitempty"`
				TresPerJob    *string `json:"tres_per_job,omitempty"`
				TresPerNode   *string `json:"tres_per_node,omitempty"`
				TresPerSocket *string `json:"tres_per_socket,omitempty"`
				TresPerTask   *string `json:"tres_per_task,omitempty"`
				TresReqStr    *string `json:"tres_req_str,omitempty"`
				UserId        *int32  `json:"user_id,omitempty"`
				UserName      *string `json:"user_name,omitempty"`
				Wckey         *string `json:"wckey,omitempty"`
			} `json:"jobs,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Jobs *[]struct {
				Account        *string `json:"account,omitempty"`
				AccrueTime     *int64  `json:"accrue_time,omitempty"`
				AdminComment   *string `json:"admin_comment,omitempty"`
				AllocatingNode *string `json:"allocating_node,omitempty"`

				// ArrayJobId Integer number with flags
				ArrayJobId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_job_id,omitempty"`

				// ArrayMaxTasks Integer number with flags
				ArrayMaxTasks *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_max_tasks,omitempty"`

				// ArrayTaskId Integer number with flags
				ArrayTaskId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_task_id,omitempty"`
				ArrayTaskString *string `json:"array_task_string,omitempty"`
				AssociationId   *int32  `json:"association_id,omitempty"`
				BatchFeatures   *string `json:"batch_features,omitempty"`
				BatchFlag       *bool   `json:"batch_flag,omitempty"`
				BatchHost       *string `json:"batch_host,omitempty"`

				// BillableTres 64 bit floating point number with flags
				BillableTres *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *float64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"billable_tres,omitempty"`
				BurstBuffer      *string `json:"burst_buffer,omitempty"`
				BurstBufferState *string `json:"burst_buffer_state,omitempty"`
				Cluster          *string `json:"cluster,omitempty"`
				ClusterFeatures  *string `json:"cluster_features,omitempty"`
				Command          *string `json:"command,omitempty"`
				Comment          *string `json:"comment,omitempty"`
				Container        *string `json:"container,omitempty"`
				ContainerId      *string `json:"container_id,omitempty"`
				Contiguous       *bool   `json:"contiguous,omitempty"`
				CoreSpec         *int32  `json:"core_spec,omitempty"`

				// CoresPerSocket Integer number with flags
				CoresPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cores_per_socket,omitempty"`

				// CpuFrequencyGovernor Integer number with flags
				CpuFrequencyGovernor *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_governor,omitempty"`

				// CpuFrequencyMaximum Integer number with flags
				CpuFrequencyMaximum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_maximum,omitempty"`

				// CpuFrequencyMinimum Integer number with flags
				CpuFrequencyMinimum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_minimum,omitempty"`

				// Cpus Integer number with flags
				Cpus *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus,omitempty"`

				// CpusPerTask Integer number with flags
				CpusPerTask *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_task,omitempty"`
				CpusPerTres             *string `json:"cpus_per_tres,omitempty"`
				Cron                    *string `json:"cron,omitempty"`
				CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`
				Deadline                *int64  `json:"deadline,omitempty"`

				// DelayBoot Integer number with flags
				DelayBoot *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"delay_boot,omitempty"`
				Dependency *string `json:"dependency,omitempty"`

				// DerivedExitCode Integer number with flags
				DerivedExitCode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"derived_exit_code,omitempty"`
				EligibleTime  *int64                              `json:"eligible_time,omitempty"`
				EndTime       *int64                              `json:"end_time,omitempty"`
				ExcludedNodes *string                             `json:"excluded_nodes,omitempty"`
				Exclusive     *[]SlurmV0039GetJob200JobsExclusive `json:"exclusive,omitempty"`

				// ExitCode Integer number with flags
				ExitCode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"exit_code,omitempty"`
				Extra                    *string                         `json:"extra,omitempty"`
				FailedNode               *string                         `json:"failed_node,omitempty"`
				Features                 *string                         `json:"features,omitempty"`
				FederationOrigin         *string                         `json:"federation_origin,omitempty"`
				FederationSiblingsActive *string                         `json:"federation_siblings_active,omitempty"`
				FederationSiblingsViable *string                         `json:"federation_siblings_viable,omitempty"`
				Flags                    *[]SlurmV0039GetJob200JobsFlags `json:"flags,omitempty"`
				GresDetail               *[]string                       `json:"gres_detail,omitempty"`
				GroupId                  *int32                          `json:"group_id,omitempty"`
				GroupName                *string                         `json:"group_name,omitempty"`

				// HetJobId Integer number with flags
				HetJobId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"het_job_id,omitempty"`
				HetJobIdSet *string `json:"het_job_id_set,omitempty"`

				// HetJobOffset Integer number with flags
				HetJobOffset *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"het_job_offset,omitempty"`

				// Hold Hold (true) or release (false) job
				Hold         *bool  `json:"hold,omitempty"`
				JobId        *int32 `json:"job_id,omitempty"`
				JobResources *struct {
					AllocatedCores *int32 `json:"allocated_cores,omitempty"`
					AllocatedCpus  *int32 `json:"allocated_cpus,omitempty"`
					AllocatedHosts *int32 `json:"allocated_hosts,omitempty"`

					// AllocatedNodes job node resources
					AllocatedNodes *[]interface{} `json:"allocated_nodes,omitempty"`
					Nodes          *string        `json:"nodes,omitempty"`
				} `json:"job_resources,omitempty"`
				JobSizeStr          *[]string                          `json:"job_size_str,omitempty"`
				JobState            *string                            `json:"job_state,omitempty"`
				LastSchedEvaluation *int64                             `json:"last_sched_evaluation,omitempty"`
				Licenses            *string                            `json:"licenses,omitempty"`
				MailType            *[]SlurmV0039GetJob200JobsMailType `json:"mail_type,omitempty"`
				MailUser            *string                            `json:"mail_user,omitempty"`

				// MaxCpus Integer number with flags
				MaxCpus *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"max_cpus,omitempty"`

				// MaxNodes Integer number with flags
				MaxNodes *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"max_nodes,omitempty"`
				MaximumSwitchWaitTime *int32  `json:"maximum_switch_wait_time,omitempty"`
				McsLabel              *string `json:"mcs_label,omitempty"`

				// MemoryPerCpu Integer number with flags
				MemoryPerCpu *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"memory_per_cpu,omitempty"`

				// MemoryPerNode Integer number with flags
				MemoryPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"memory_per_node,omitempty"`
				MemoryPerTres *string `json:"memory_per_tres,omitempty"`

				// MinimumCpusPerNode Integer number with flags
				MinimumCpusPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"minimum_cpus_per_node,omitempty"`
				MinimumSwitches *int32 `json:"minimum_switches,omitempty"`

				// MinimumTmpDiskPerNode Integer number with flags
				MinimumTmpDiskPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"minimum_tmp_disk_per_node,omitempty"`
				Name    *string `json:"name,omitempty"`
				Network *string `json:"network,omitempty"`
				Nice    *int32  `json:"nice,omitempty"`

				// NodeCount Integer number with flags
				NodeCount *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"node_count,omitempty"`
				Nodes         *string `json:"nodes,omitempty"`
				Oversubscribe *bool   `json:"oversubscribe,omitempty"`
				Partition     *string `json:"partition,omitempty"`
				Power         *struct {
					Flags *[]SlurmV0039GetJob200JobsPowerFlags `json:"flags,omitempty"`
				} `json:"power,omitempty"`
				PreSusTime      *int64  `json:"pre_sus_time,omitempty"`
				PreemptTime     *int64  `json:"preempt_time,omitempty"`
				PreemptableTime *int64  `json:"preemptable_time,omitempty"`
				Prefer          *string `json:"prefer,omitempty"`

				// Priority Integer number with flags
				Priority *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"priority,omitempty"`
				Profile         *[]SlurmV0039GetJob200JobsProfile   `json:"profile,omitempty"`
				Qos             *string                             `json:"qos,omitempty"`
				Reboot          *bool                               `json:"reboot,omitempty"`
				Requeue         *bool                               `json:"requeue,omitempty"`
				RequiredNodes   *string                             `json:"required_nodes,omitempty"`
				ResizeTime      *int64                              `json:"resize_time,omitempty"`
				RestartCnt      *int32                              `json:"restart_cnt,omitempty"`
				ResvName        *string                             `json:"resv_name,omitempty"`
				ScheduledNodes  *string                             `json:"scheduled_nodes,omitempty"`
				SelinuxContext  *string                             `json:"selinux_context,omitempty"`
				Shared          *[]SlurmV0039GetJob200JobsShared    `json:"shared,omitempty"`
				ShowFlags       *[]SlurmV0039GetJob200JobsShowFlags `json:"show_flags,omitempty"`
				SocketsPerBoard *int32                              `json:"sockets_per_board,omitempty"`

				// SocketsPerNode Integer number with flags
				SocketsPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"sockets_per_node,omitempty"`
				StandardError    *string `json:"standard_error,omitempty"`
				StandardInput    *string `json:"standard_input,omitempty"`
				StandardOutput   *string `json:"standard_output,omitempty"`
				StartTime        *int64  `json:"start_time,omitempty"`
				StateDescription *string `json:"state_description,omitempty"`
				StateReason      *string `json:"state_reason,omitempty"`
				SubmitTime       *int64  `json:"submit_time,omitempty"`
				SuspendTime      *int64  `json:"suspend_time,omitempty"`
				SystemComment    *string `json:"system_comment,omitempty"`

				// Tasks Integer number with flags
				Tasks *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks,omitempty"`

				// TasksPerBoard Integer number with flags
				TasksPerBoard *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_board,omitempty"`

				// TasksPerCore Integer number with flags
				TasksPerCore *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_core,omitempty"`

				// TasksPerNode Integer number with flags
				TasksPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_node,omitempty"`

				// TasksPerSocket Integer number with flags
				TasksPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_socket,omitempty"`

				// TasksPerTres Integer number with flags
				TasksPerTres *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_tres,omitempty"`
				ThreadSpec *int32 `json:"thread_spec,omitempty"`

				// ThreadsPerCore Integer number with flags
				ThreadsPerCore *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"threads_per_core,omitempty"`

				// TimeLimit Integer number with flags
				TimeLimit *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time_limit,omitempty"`

				// TimeMinimum Integer number with flags
				TimeMinimum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time_minimum,omitempty"`
				TresAllocStr  *string `json:"tres_alloc_str,omitempty"`
				TresBind      *string `json:"tres_bind,omitempty"`
				TresFreq      *string `json:"tres_freq,omitempty"`
				TresPerJob    *string `json:"tres_per_job,omitempty"`
				TresPerNode   *string `json:"tres_per_node,omitempty"`
				TresPerSocket *string `json:"tres_per_socket,omitempty"`
				TresPerTask   *string `json:"tres_per_task,omitempty"`
				TresReqStr    *string `json:"tres_req_str,omitempty"`
				UserId        *int32  `json:"user_id,omitempty"`
				UserName      *string `json:"user_name,omitempty"`
				Wckey         *string `json:"wckey,omitempty"`
			} `json:"jobs,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039UpdateJobResponse parses an HTTP response from a SlurmV0039UpdateJobWithResponse call
func ParseSlurmV0039UpdateJobResponse(rsp *http.Response) (*SlurmV0039UpdateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039UpdateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Results Result per ArrayJob
			Results *[]struct {
				// Error error code description
				Error *string `json:"error,omitempty"`

				// ErrorCode numeric error code
				ErrorCode *int32 `json:"error_code,omitempty"`

				// JobId JobId
				JobId *int32 `json:"job_id,omitempty"`

				// Why error message
				Why *string `json:"why,omitempty"`
			} `json:"results,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Results Result per ArrayJob
			Results *[]struct {
				// Error error code description
				Error *string `json:"error,omitempty"`

				// ErrorCode numeric error code
				ErrorCode *int32 `json:"error_code,omitempty"`

				// JobId JobId
				JobId *int32 `json:"job_id,omitempty"`

				// Why error message
				Why *string `json:"why,omitempty"`
			} `json:"results,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039GetJobsResponse parses an HTTP response from a SlurmV0039GetJobsWithResponse call
func ParseSlurmV0039GetJobsResponse(rsp *http.Response) (*SlurmV0039GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Jobs *[]struct {
				Account        *string `json:"account,omitempty"`
				AccrueTime     *int64  `json:"accrue_time,omitempty"`
				AdminComment   *string `json:"admin_comment,omitempty"`
				AllocatingNode *string `json:"allocating_node,omitempty"`

				// ArrayJobId Integer number with flags
				ArrayJobId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_job_id,omitempty"`

				// ArrayMaxTasks Integer number with flags
				ArrayMaxTasks *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_max_tasks,omitempty"`

				// ArrayTaskId Integer number with flags
				ArrayTaskId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_task_id,omitempty"`
				ArrayTaskString *string `json:"array_task_string,omitempty"`
				AssociationId   *int32  `json:"association_id,omitempty"`
				BatchFeatures   *string `json:"batch_features,omitempty"`
				BatchFlag       *bool   `json:"batch_flag,omitempty"`
				BatchHost       *string `json:"batch_host,omitempty"`

				// BillableTres 64 bit floating point number with flags
				BillableTres *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *float64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"billable_tres,omitempty"`
				BurstBuffer      *string `json:"burst_buffer,omitempty"`
				BurstBufferState *string `json:"burst_buffer_state,omitempty"`
				Cluster          *string `json:"cluster,omitempty"`
				ClusterFeatures  *string `json:"cluster_features,omitempty"`
				Command          *string `json:"command,omitempty"`
				Comment          *string `json:"comment,omitempty"`
				Container        *string `json:"container,omitempty"`
				ContainerId      *string `json:"container_id,omitempty"`
				Contiguous       *bool   `json:"contiguous,omitempty"`
				CoreSpec         *int32  `json:"core_spec,omitempty"`

				// CoresPerSocket Integer number with flags
				CoresPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cores_per_socket,omitempty"`

				// CpuFrequencyGovernor Integer number with flags
				CpuFrequencyGovernor *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_governor,omitempty"`

				// CpuFrequencyMaximum Integer number with flags
				CpuFrequencyMaximum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_maximum,omitempty"`

				// CpuFrequencyMinimum Integer number with flags
				CpuFrequencyMinimum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_minimum,omitempty"`

				// Cpus Integer number with flags
				Cpus *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus,omitempty"`

				// CpusPerTask Integer number with flags
				CpusPerTask *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_task,omitempty"`
				CpusPerTres             *string `json:"cpus_per_tres,omitempty"`
				Cron                    *string `json:"cron,omitempty"`
				CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`
				Deadline                *int64  `json:"deadline,omitempty"`

				// DelayBoot Integer number with flags
				DelayBoot *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"delay_boot,omitempty"`
				Dependency *string `json:"dependency,omitempty"`

				// DerivedExitCode Integer number with flags
				DerivedExitCode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"derived_exit_code,omitempty"`
				EligibleTime  *int64                               `json:"eligible_time,omitempty"`
				EndTime       *int64                               `json:"end_time,omitempty"`
				ExcludedNodes *string                              `json:"excluded_nodes,omitempty"`
				Exclusive     *[]SlurmV0039GetJobs200JobsExclusive `json:"exclusive,omitempty"`

				// ExitCode Integer number with flags
				ExitCode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"exit_code,omitempty"`
				Extra                    *string                          `json:"extra,omitempty"`
				FailedNode               *string                          `json:"failed_node,omitempty"`
				Features                 *string                          `json:"features,omitempty"`
				FederationOrigin         *string                          `json:"federation_origin,omitempty"`
				FederationSiblingsActive *string                          `json:"federation_siblings_active,omitempty"`
				FederationSiblingsViable *string                          `json:"federation_siblings_viable,omitempty"`
				Flags                    *[]SlurmV0039GetJobs200JobsFlags `json:"flags,omitempty"`
				GresDetail               *[]string                        `json:"gres_detail,omitempty"`
				GroupId                  *int32                           `json:"group_id,omitempty"`
				GroupName                *string                          `json:"group_name,omitempty"`

				// HetJobId Integer number with flags
				HetJobId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"het_job_id,omitempty"`
				HetJobIdSet *string `json:"het_job_id_set,omitempty"`

				// HetJobOffset Integer number with flags
				HetJobOffset *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"het_job_offset,omitempty"`

				// Hold Hold (true) or release (false) job
				Hold         *bool  `json:"hold,omitempty"`
				JobId        *int32 `json:"job_id,omitempty"`
				JobResources *struct {
					AllocatedCores *int32 `json:"allocated_cores,omitempty"`
					AllocatedCpus  *int32 `json:"allocated_cpus,omitempty"`
					AllocatedHosts *int32 `json:"allocated_hosts,omitempty"`

					// AllocatedNodes job node resources
					AllocatedNodes *[]interface{} `json:"allocated_nodes,omitempty"`
					Nodes          *string        `json:"nodes,omitempty"`
				} `json:"job_resources,omitempty"`
				JobSizeStr          *[]string                           `json:"job_size_str,omitempty"`
				JobState            *string                             `json:"job_state,omitempty"`
				LastSchedEvaluation *int64                              `json:"last_sched_evaluation,omitempty"`
				Licenses            *string                             `json:"licenses,omitempty"`
				MailType            *[]SlurmV0039GetJobs200JobsMailType `json:"mail_type,omitempty"`
				MailUser            *string                             `json:"mail_user,omitempty"`

				// MaxCpus Integer number with flags
				MaxCpus *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"max_cpus,omitempty"`

				// MaxNodes Integer number with flags
				MaxNodes *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"max_nodes,omitempty"`
				MaximumSwitchWaitTime *int32  `json:"maximum_switch_wait_time,omitempty"`
				McsLabel              *string `json:"mcs_label,omitempty"`

				// MemoryPerCpu Integer number with flags
				MemoryPerCpu *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"memory_per_cpu,omitempty"`

				// MemoryPerNode Integer number with flags
				MemoryPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"memory_per_node,omitempty"`
				MemoryPerTres *string `json:"memory_per_tres,omitempty"`

				// MinimumCpusPerNode Integer number with flags
				MinimumCpusPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"minimum_cpus_per_node,omitempty"`
				MinimumSwitches *int32 `json:"minimum_switches,omitempty"`

				// MinimumTmpDiskPerNode Integer number with flags
				MinimumTmpDiskPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"minimum_tmp_disk_per_node,omitempty"`
				Name    *string `json:"name,omitempty"`
				Network *string `json:"network,omitempty"`
				Nice    *int32  `json:"nice,omitempty"`

				// NodeCount Integer number with flags
				NodeCount *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"node_count,omitempty"`
				Nodes         *string `json:"nodes,omitempty"`
				Oversubscribe *bool   `json:"oversubscribe,omitempty"`
				Partition     *string `json:"partition,omitempty"`
				Power         *struct {
					Flags *[]SlurmV0039GetJobs200JobsPowerFlags `json:"flags,omitempty"`
				} `json:"power,omitempty"`
				PreSusTime      *int64  `json:"pre_sus_time,omitempty"`
				PreemptTime     *int64  `json:"preempt_time,omitempty"`
				PreemptableTime *int64  `json:"preemptable_time,omitempty"`
				Prefer          *string `json:"prefer,omitempty"`

				// Priority Integer number with flags
				Priority *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"priority,omitempty"`
				Profile         *[]SlurmV0039GetJobs200JobsProfile   `json:"profile,omitempty"`
				Qos             *string                              `json:"qos,omitempty"`
				Reboot          *bool                                `json:"reboot,omitempty"`
				Requeue         *bool                                `json:"requeue,omitempty"`
				RequiredNodes   *string                              `json:"required_nodes,omitempty"`
				ResizeTime      *int64                               `json:"resize_time,omitempty"`
				RestartCnt      *int32                               `json:"restart_cnt,omitempty"`
				ResvName        *string                              `json:"resv_name,omitempty"`
				ScheduledNodes  *string                              `json:"scheduled_nodes,omitempty"`
				SelinuxContext  *string                              `json:"selinux_context,omitempty"`
				Shared          *[]SlurmV0039GetJobs200JobsShared    `json:"shared,omitempty"`
				ShowFlags       *[]SlurmV0039GetJobs200JobsShowFlags `json:"show_flags,omitempty"`
				SocketsPerBoard *int32                               `json:"sockets_per_board,omitempty"`

				// SocketsPerNode Integer number with flags
				SocketsPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"sockets_per_node,omitempty"`
				StandardError    *string `json:"standard_error,omitempty"`
				StandardInput    *string `json:"standard_input,omitempty"`
				StandardOutput   *string `json:"standard_output,omitempty"`
				StartTime        *int64  `json:"start_time,omitempty"`
				StateDescription *string `json:"state_description,omitempty"`
				StateReason      *string `json:"state_reason,omitempty"`
				SubmitTime       *int64  `json:"submit_time,omitempty"`
				SuspendTime      *int64  `json:"suspend_time,omitempty"`
				SystemComment    *string `json:"system_comment,omitempty"`

				// Tasks Integer number with flags
				Tasks *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks,omitempty"`

				// TasksPerBoard Integer number with flags
				TasksPerBoard *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_board,omitempty"`

				// TasksPerCore Integer number with flags
				TasksPerCore *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_core,omitempty"`

				// TasksPerNode Integer number with flags
				TasksPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_node,omitempty"`

				// TasksPerSocket Integer number with flags
				TasksPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_socket,omitempty"`

				// TasksPerTres Integer number with flags
				TasksPerTres *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_tres,omitempty"`
				ThreadSpec *int32 `json:"thread_spec,omitempty"`

				// ThreadsPerCore Integer number with flags
				ThreadsPerCore *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"threads_per_core,omitempty"`

				// TimeLimit Integer number with flags
				TimeLimit *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time_limit,omitempty"`

				// TimeMinimum Integer number with flags
				TimeMinimum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time_minimum,omitempty"`
				TresAllocStr  *string `json:"tres_alloc_str,omitempty"`
				TresBind      *string `json:"tres_bind,omitempty"`
				TresFreq      *string `json:"tres_freq,omitempty"`
				TresPerJob    *string `json:"tres_per_job,omitempty"`
				TresPerNode   *string `json:"tres_per_node,omitempty"`
				TresPerSocket *string `json:"tres_per_socket,omitempty"`
				TresPerTask   *string `json:"tres_per_task,omitempty"`
				TresReqStr    *string `json:"tres_req_str,omitempty"`
				UserId        *int32  `json:"user_id,omitempty"`
				UserName      *string `json:"user_name,omitempty"`
				Wckey         *string `json:"wckey,omitempty"`
			} `json:"jobs,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Jobs *[]struct {
				Account        *string `json:"account,omitempty"`
				AccrueTime     *int64  `json:"accrue_time,omitempty"`
				AdminComment   *string `json:"admin_comment,omitempty"`
				AllocatingNode *string `json:"allocating_node,omitempty"`

				// ArrayJobId Integer number with flags
				ArrayJobId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_job_id,omitempty"`

				// ArrayMaxTasks Integer number with flags
				ArrayMaxTasks *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_max_tasks,omitempty"`

				// ArrayTaskId Integer number with flags
				ArrayTaskId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"array_task_id,omitempty"`
				ArrayTaskString *string `json:"array_task_string,omitempty"`
				AssociationId   *int32  `json:"association_id,omitempty"`
				BatchFeatures   *string `json:"batch_features,omitempty"`
				BatchFlag       *bool   `json:"batch_flag,omitempty"`
				BatchHost       *string `json:"batch_host,omitempty"`

				// BillableTres 64 bit floating point number with flags
				BillableTres *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *float64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"billable_tres,omitempty"`
				BurstBuffer      *string `json:"burst_buffer,omitempty"`
				BurstBufferState *string `json:"burst_buffer_state,omitempty"`
				Cluster          *string `json:"cluster,omitempty"`
				ClusterFeatures  *string `json:"cluster_features,omitempty"`
				Command          *string `json:"command,omitempty"`
				Comment          *string `json:"comment,omitempty"`
				Container        *string `json:"container,omitempty"`
				ContainerId      *string `json:"container_id,omitempty"`
				Contiguous       *bool   `json:"contiguous,omitempty"`
				CoreSpec         *int32  `json:"core_spec,omitempty"`

				// CoresPerSocket Integer number with flags
				CoresPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cores_per_socket,omitempty"`

				// CpuFrequencyGovernor Integer number with flags
				CpuFrequencyGovernor *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_governor,omitempty"`

				// CpuFrequencyMaximum Integer number with flags
				CpuFrequencyMaximum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_maximum,omitempty"`

				// CpuFrequencyMinimum Integer number with flags
				CpuFrequencyMinimum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_frequency_minimum,omitempty"`

				// Cpus Integer number with flags
				Cpus *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus,omitempty"`

				// CpusPerTask Integer number with flags
				CpusPerTask *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpus_per_task,omitempty"`
				CpusPerTres             *string `json:"cpus_per_tres,omitempty"`
				Cron                    *string `json:"cron,omitempty"`
				CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`
				Deadline                *int64  `json:"deadline,omitempty"`

				// DelayBoot Integer number with flags
				DelayBoot *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"delay_boot,omitempty"`
				Dependency *string `json:"dependency,omitempty"`

				// DerivedExitCode Integer number with flags
				DerivedExitCode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"derived_exit_code,omitempty"`
				EligibleTime  *int64                               `json:"eligible_time,omitempty"`
				EndTime       *int64                               `json:"end_time,omitempty"`
				ExcludedNodes *string                              `json:"excluded_nodes,omitempty"`
				Exclusive     *[]SlurmV0039GetJobs200JobsExclusive `json:"exclusive,omitempty"`

				// ExitCode Integer number with flags
				ExitCode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"exit_code,omitempty"`
				Extra                    *string                          `json:"extra,omitempty"`
				FailedNode               *string                          `json:"failed_node,omitempty"`
				Features                 *string                          `json:"features,omitempty"`
				FederationOrigin         *string                          `json:"federation_origin,omitempty"`
				FederationSiblingsActive *string                          `json:"federation_siblings_active,omitempty"`
				FederationSiblingsViable *string                          `json:"federation_siblings_viable,omitempty"`
				Flags                    *[]SlurmV0039GetJobs200JobsFlags `json:"flags,omitempty"`
				GresDetail               *[]string                        `json:"gres_detail,omitempty"`
				GroupId                  *int32                           `json:"group_id,omitempty"`
				GroupName                *string                          `json:"group_name,omitempty"`

				// HetJobId Integer number with flags
				HetJobId *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"het_job_id,omitempty"`
				HetJobIdSet *string `json:"het_job_id_set,omitempty"`

				// HetJobOffset Integer number with flags
				HetJobOffset *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"het_job_offset,omitempty"`

				// Hold Hold (true) or release (false) job
				Hold         *bool  `json:"hold,omitempty"`
				JobId        *int32 `json:"job_id,omitempty"`
				JobResources *struct {
					AllocatedCores *int32 `json:"allocated_cores,omitempty"`
					AllocatedCpus  *int32 `json:"allocated_cpus,omitempty"`
					AllocatedHosts *int32 `json:"allocated_hosts,omitempty"`

					// AllocatedNodes job node resources
					AllocatedNodes *[]interface{} `json:"allocated_nodes,omitempty"`
					Nodes          *string        `json:"nodes,omitempty"`
				} `json:"job_resources,omitempty"`
				JobSizeStr          *[]string                           `json:"job_size_str,omitempty"`
				JobState            *string                             `json:"job_state,omitempty"`
				LastSchedEvaluation *int64                              `json:"last_sched_evaluation,omitempty"`
				Licenses            *string                             `json:"licenses,omitempty"`
				MailType            *[]SlurmV0039GetJobs200JobsMailType `json:"mail_type,omitempty"`
				MailUser            *string                             `json:"mail_user,omitempty"`

				// MaxCpus Integer number with flags
				MaxCpus *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"max_cpus,omitempty"`

				// MaxNodes Integer number with flags
				MaxNodes *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"max_nodes,omitempty"`
				MaximumSwitchWaitTime *int32  `json:"maximum_switch_wait_time,omitempty"`
				McsLabel              *string `json:"mcs_label,omitempty"`

				// MemoryPerCpu Integer number with flags
				MemoryPerCpu *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"memory_per_cpu,omitempty"`

				// MemoryPerNode Integer number with flags
				MemoryPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"memory_per_node,omitempty"`
				MemoryPerTres *string `json:"memory_per_tres,omitempty"`

				// MinimumCpusPerNode Integer number with flags
				MinimumCpusPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"minimum_cpus_per_node,omitempty"`
				MinimumSwitches *int32 `json:"minimum_switches,omitempty"`

				// MinimumTmpDiskPerNode Integer number with flags
				MinimumTmpDiskPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"minimum_tmp_disk_per_node,omitempty"`
				Name    *string `json:"name,omitempty"`
				Network *string `json:"network,omitempty"`
				Nice    *int32  `json:"nice,omitempty"`

				// NodeCount Integer number with flags
				NodeCount *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"node_count,omitempty"`
				Nodes         *string `json:"nodes,omitempty"`
				Oversubscribe *bool   `json:"oversubscribe,omitempty"`
				Partition     *string `json:"partition,omitempty"`
				Power         *struct {
					Flags *[]SlurmV0039GetJobs200JobsPowerFlags `json:"flags,omitempty"`
				} `json:"power,omitempty"`
				PreSusTime      *int64  `json:"pre_sus_time,omitempty"`
				PreemptTime     *int64  `json:"preempt_time,omitempty"`
				PreemptableTime *int64  `json:"preemptable_time,omitempty"`
				Prefer          *string `json:"prefer,omitempty"`

				// Priority Integer number with flags
				Priority *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"priority,omitempty"`
				Profile         *[]SlurmV0039GetJobs200JobsProfile   `json:"profile,omitempty"`
				Qos             *string                              `json:"qos,omitempty"`
				Reboot          *bool                                `json:"reboot,omitempty"`
				Requeue         *bool                                `json:"requeue,omitempty"`
				RequiredNodes   *string                              `json:"required_nodes,omitempty"`
				ResizeTime      *int64                               `json:"resize_time,omitempty"`
				RestartCnt      *int32                               `json:"restart_cnt,omitempty"`
				ResvName        *string                              `json:"resv_name,omitempty"`
				ScheduledNodes  *string                              `json:"scheduled_nodes,omitempty"`
				SelinuxContext  *string                              `json:"selinux_context,omitempty"`
				Shared          *[]SlurmV0039GetJobs200JobsShared    `json:"shared,omitempty"`
				ShowFlags       *[]SlurmV0039GetJobs200JobsShowFlags `json:"show_flags,omitempty"`
				SocketsPerBoard *int32                               `json:"sockets_per_board,omitempty"`

				// SocketsPerNode Integer number with flags
				SocketsPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"sockets_per_node,omitempty"`
				StandardError    *string `json:"standard_error,omitempty"`
				StandardInput    *string `json:"standard_input,omitempty"`
				StandardOutput   *string `json:"standard_output,omitempty"`
				StartTime        *int64  `json:"start_time,omitempty"`
				StateDescription *string `json:"state_description,omitempty"`
				StateReason      *string `json:"state_reason,omitempty"`
				SubmitTime       *int64  `json:"submit_time,omitempty"`
				SuspendTime      *int64  `json:"suspend_time,omitempty"`
				SystemComment    *string `json:"system_comment,omitempty"`

				// Tasks Integer number with flags
				Tasks *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks,omitempty"`

				// TasksPerBoard Integer number with flags
				TasksPerBoard *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_board,omitempty"`

				// TasksPerCore Integer number with flags
				TasksPerCore *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_core,omitempty"`

				// TasksPerNode Integer number with flags
				TasksPerNode *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_node,omitempty"`

				// TasksPerSocket Integer number with flags
				TasksPerSocket *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_socket,omitempty"`

				// TasksPerTres Integer number with flags
				TasksPerTres *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"tasks_per_tres,omitempty"`
				ThreadSpec *int32 `json:"thread_spec,omitempty"`

				// ThreadsPerCore Integer number with flags
				ThreadsPerCore *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"threads_per_core,omitempty"`

				// TimeLimit Integer number with flags
				TimeLimit *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time_limit,omitempty"`

				// TimeMinimum Integer number with flags
				TimeMinimum *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"time_minimum,omitempty"`
				TresAllocStr  *string `json:"tres_alloc_str,omitempty"`
				TresBind      *string `json:"tres_bind,omitempty"`
				TresFreq      *string `json:"tres_freq,omitempty"`
				TresPerJob    *string `json:"tres_per_job,omitempty"`
				TresPerNode   *string `json:"tres_per_node,omitempty"`
				TresPerSocket *string `json:"tres_per_socket,omitempty"`
				TresPerTask   *string `json:"tres_per_task,omitempty"`
				TresReqStr    *string `json:"tres_req_str,omitempty"`
				UserId        *int32  `json:"user_id,omitempty"`
				UserName      *string `json:"user_name,omitempty"`
				Wckey         *string `json:"wckey,omitempty"`
			} `json:"jobs,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039SlurmctldGetLicensesResponse parses an HTTP response from a SlurmV0039SlurmctldGetLicensesWithResponse call
func ParseSlurmV0039SlurmctldGetLicensesResponse(rsp *http.Response) (*SlurmV0039SlurmctldGetLicensesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039SlurmctldGetLicensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Licenses *[]struct {
				Free         *int32  `json:"Free,omitempty"`
				LastConsumed *int32  `json:"LastConsumed,omitempty"`
				LastDeficit  *int32  `json:"LastDeficit,omitempty"`
				LastUpdate   *int64  `json:"LastUpdate,omitempty"`
				LicenseName  *string `json:"LicenseName,omitempty"`
				Remote       *bool   `json:"Remote,omitempty"`
				Reserved     *int32  `json:"Reserved,omitempty"`
				Total        *int32  `json:"Total,omitempty"`
				Used         *int32  `json:"Used,omitempty"`
			} `json:"licenses,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Licenses *[]struct {
				Free         *int32  `json:"Free,omitempty"`
				LastConsumed *int32  `json:"LastConsumed,omitempty"`
				LastDeficit  *int32  `json:"LastDeficit,omitempty"`
				LastUpdate   *int64  `json:"LastUpdate,omitempty"`
				LicenseName  *string `json:"LicenseName,omitempty"`
				Remote       *bool   `json:"Remote,omitempty"`
				Reserved     *int32  `json:"Reserved,omitempty"`
				Total        *int32  `json:"Total,omitempty"`
				Used         *int32  `json:"Used,omitempty"`
			} `json:"licenses,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039DeleteNodeResponse parses an HTTP response from a SlurmV0039DeleteNodeWithResponse call
func ParseSlurmV0039DeleteNodeResponse(rsp *http.Response) (*SlurmV0039DeleteNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039DeleteNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039GetNodeResponse parses an HTTP response from a SlurmV0039GetNodeWithResponse call
func ParseSlurmV0039GetNodeResponse(rsp *http.Response) (*SlurmV0039GetNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039GetNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Nodes *[]struct {
				ActiveFeatures            *[]string `json:"active_features,omitempty"`
				Address                   *string   `json:"address,omitempty"`
				AllocCpus                 *int32    `json:"alloc_cpus,omitempty"`
				AllocIdleCpus             *int32    `json:"alloc_idle_cpus,omitempty"`
				AllocMemory               *int64    `json:"alloc_memory,omitempty"`
				Architecture              *string   `json:"architecture,omitempty"`
				Boards                    *int32    `json:"boards,omitempty"`
				BootTime                  *int64    `json:"boot_time,omitempty"`
				BurstbufferNetworkAddress *string   `json:"burstbuffer_network_address,omitempty"`
				ClusterName               *string   `json:"cluster_name,omitempty"`
				Comment                   *string   `json:"comment,omitempty"`
				Cores                     *int32    `json:"cores,omitempty"`
				CpuBinding                *int32    `json:"cpu_binding,omitempty"`

				// CpuLoad Integer number with flags
				CpuLoad *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_load,omitempty"`
				Cpus          *int32 `json:"cpus,omitempty"`
				EffectiveCpus *int32 `json:"effective_cpus,omitempty"`
				Energy        *struct {
					AverageWatts       *int32 `json:"average_watts,omitempty"`
					BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`
					ConsumedEnergy     *int64 `json:"consumed_energy,omitempty"`

					// CurrentWatts Integer number with flags
					CurrentWatts *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"current_watts,omitempty"`
					LastCollected          *int64 `json:"last_collected,omitempty"`
					PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
				} `json:"energy,omitempty"`
				ExternalSensors *struct {
					// ConsumedEnergy Integer number with flags
					ConsumedEnergy *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"consumed_energy,omitempty"`
					CurrentWatts     *int32 `json:"current_watts,omitempty"`
					EnergyUpdateTime *int64 `json:"energy_update_time,omitempty"`

					// Temperature Integer number with flags
					Temperature *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"temperature,omitempty"`
				} `json:"external_sensors,omitempty"`
				Extra    *string   `json:"extra,omitempty"`
				Features *[]string `json:"features,omitempty"`

				// FreeMem Integer number with flags
				FreeMem *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"free_mem,omitempty"`
				Gres                 *string                                          `json:"gres,omitempty"`
				GresDrained          *string                                          `json:"gres_drained,omitempty"`
				GresUsed             *string                                          `json:"gres_used,omitempty"`
				Hostname             *string                                          `json:"hostname,omitempty"`
				LastBusy             *int64                                           `json:"last_busy,omitempty"`
				McsLabel             *string                                          `json:"mcs_label,omitempty"`
				Name                 *string                                          `json:"name,omitempty"`
				NextStateAfterReboot *[]SlurmV0039GetNode200NodesNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`
				OperatingSystem      *string                                          `json:"operating_system,omitempty"`
				Owner                *string                                          `json:"owner,omitempty"`
				Partitions           *[]string                                        `json:"partitions,omitempty"`
				Port                 *int32                                           `json:"port,omitempty"`
				Power                *struct {
					CurrentWatts *int32 `json:"current_watts,omitempty"`
					LowestWatts  *int32 `json:"lowest_watts,omitempty"`

					// MaximumWatts Integer number with flags
					MaximumWatts *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"maximum_watts,omitempty"`
					NewJobTime      *int64 `json:"new_job_time,omitempty"`
					NewMaximumWatts *int32 `json:"new_maximum_watts,omitempty"`
					PeakWatts       *int32 `json:"peak_watts,omitempty"`
					State           *int32 `json:"state,omitempty"`
					TimeStartDay    *int64 `json:"time_start_day,omitempty"`
					TotalEnergy     *int64 `json:"total_energy,omitempty"`
				} `json:"power,omitempty"`
				RealMemory      *int64  `json:"real_memory,omitempty"`
				Reason          *string `json:"reason,omitempty"`
				ReasonChangedAt *int64  `json:"reason_changed_at,omitempty"`
				ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`
				Reservation     *string `json:"reservation,omitempty"`

				// ResumeAfter Integer number with flags
				ResumeAfter *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"resume_after,omitempty"`
				SlurmdStartTime   *int64                            `json:"slurmd_start_time,omitempty"`
				Sockets           *int32                            `json:"sockets,omitempty"`
				SpecializedCores  *int32                            `json:"specialized_cores,omitempty"`
				SpecializedCpus   *string                           `json:"specialized_cpus,omitempty"`
				SpecializedMemory *int64                            `json:"specialized_memory,omitempty"`
				State             *[]SlurmV0039GetNode200NodesState `json:"state,omitempty"`
				TemporaryDisk     *int32                            `json:"temporary_disk,omitempty"`
				Threads           *int32                            `json:"threads,omitempty"`
				Tres              *string                           `json:"tres,omitempty"`
				TresUsed          *string                           `json:"tres_used,omitempty"`
				TresWeighted      *float64                          `json:"tres_weighted,omitempty"`
				Version           *string                           `json:"version,omitempty"`
				Weight            *int32                            `json:"weight,omitempty"`
			} `json:"nodes,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Nodes *[]struct {
				ActiveFeatures            *[]string `json:"active_features,omitempty"`
				Address                   *string   `json:"address,omitempty"`
				AllocCpus                 *int32    `json:"alloc_cpus,omitempty"`
				AllocIdleCpus             *int32    `json:"alloc_idle_cpus,omitempty"`
				AllocMemory               *int64    `json:"alloc_memory,omitempty"`
				Architecture              *string   `json:"architecture,omitempty"`
				Boards                    *int32    `json:"boards,omitempty"`
				BootTime                  *int64    `json:"boot_time,omitempty"`
				BurstbufferNetworkAddress *string   `json:"burstbuffer_network_address,omitempty"`
				ClusterName               *string   `json:"cluster_name,omitempty"`
				Comment                   *string   `json:"comment,omitempty"`
				Cores                     *int32    `json:"cores,omitempty"`
				CpuBinding                *int32    `json:"cpu_binding,omitempty"`

				// CpuLoad Integer number with flags
				CpuLoad *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_load,omitempty"`
				Cpus          *int32 `json:"cpus,omitempty"`
				EffectiveCpus *int32 `json:"effective_cpus,omitempty"`
				Energy        *struct {
					AverageWatts       *int32 `json:"average_watts,omitempty"`
					BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`
					ConsumedEnergy     *int64 `json:"consumed_energy,omitempty"`

					// CurrentWatts Integer number with flags
					CurrentWatts *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"current_watts,omitempty"`
					LastCollected          *int64 `json:"last_collected,omitempty"`
					PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
				} `json:"energy,omitempty"`
				ExternalSensors *struct {
					// ConsumedEnergy Integer number with flags
					ConsumedEnergy *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"consumed_energy,omitempty"`
					CurrentWatts     *int32 `json:"current_watts,omitempty"`
					EnergyUpdateTime *int64 `json:"energy_update_time,omitempty"`

					// Temperature Integer number with flags
					Temperature *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"temperature,omitempty"`
				} `json:"external_sensors,omitempty"`
				Extra    *string   `json:"extra,omitempty"`
				Features *[]string `json:"features,omitempty"`

				// FreeMem Integer number with flags
				FreeMem *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"free_mem,omitempty"`
				Gres                 *string                                          `json:"gres,omitempty"`
				GresDrained          *string                                          `json:"gres_drained,omitempty"`
				GresUsed             *string                                          `json:"gres_used,omitempty"`
				Hostname             *string                                          `json:"hostname,omitempty"`
				LastBusy             *int64                                           `json:"last_busy,omitempty"`
				McsLabel             *string                                          `json:"mcs_label,omitempty"`
				Name                 *string                                          `json:"name,omitempty"`
				NextStateAfterReboot *[]SlurmV0039GetNode200NodesNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`
				OperatingSystem      *string                                          `json:"operating_system,omitempty"`
				Owner                *string                                          `json:"owner,omitempty"`
				Partitions           *[]string                                        `json:"partitions,omitempty"`
				Port                 *int32                                           `json:"port,omitempty"`
				Power                *struct {
					CurrentWatts *int32 `json:"current_watts,omitempty"`
					LowestWatts  *int32 `json:"lowest_watts,omitempty"`

					// MaximumWatts Integer number with flags
					MaximumWatts *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"maximum_watts,omitempty"`
					NewJobTime      *int64 `json:"new_job_time,omitempty"`
					NewMaximumWatts *int32 `json:"new_maximum_watts,omitempty"`
					PeakWatts       *int32 `json:"peak_watts,omitempty"`
					State           *int32 `json:"state,omitempty"`
					TimeStartDay    *int64 `json:"time_start_day,omitempty"`
					TotalEnergy     *int64 `json:"total_energy,omitempty"`
				} `json:"power,omitempty"`
				RealMemory      *int64  `json:"real_memory,omitempty"`
				Reason          *string `json:"reason,omitempty"`
				ReasonChangedAt *int64  `json:"reason_changed_at,omitempty"`
				ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`
				Reservation     *string `json:"reservation,omitempty"`

				// ResumeAfter Integer number with flags
				ResumeAfter *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"resume_after,omitempty"`
				SlurmdStartTime   *int64                            `json:"slurmd_start_time,omitempty"`
				Sockets           *int32                            `json:"sockets,omitempty"`
				SpecializedCores  *int32                            `json:"specialized_cores,omitempty"`
				SpecializedCpus   *string                           `json:"specialized_cpus,omitempty"`
				SpecializedMemory *int64                            `json:"specialized_memory,omitempty"`
				State             *[]SlurmV0039GetNode200NodesState `json:"state,omitempty"`
				TemporaryDisk     *int32                            `json:"temporary_disk,omitempty"`
				Threads           *int32                            `json:"threads,omitempty"`
				Tres              *string                           `json:"tres,omitempty"`
				TresUsed          *string                           `json:"tres_used,omitempty"`
				TresWeighted      *float64                          `json:"tres_weighted,omitempty"`
				Version           *string                           `json:"version,omitempty"`
				Weight            *int32                            `json:"weight,omitempty"`
			} `json:"nodes,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039UpdateNodeResponse parses an HTTP response from a SlurmV0039UpdateNodeWithResponse call
func ParseSlurmV0039UpdateNodeResponse(rsp *http.Response) (*SlurmV0039UpdateNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039UpdateNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039GetNodesResponse parses an HTTP response from a SlurmV0039GetNodesWithResponse call
func ParseSlurmV0039GetNodesResponse(rsp *http.Response) (*SlurmV0039GetNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039GetNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Nodes *[]struct {
				ActiveFeatures            *[]string `json:"active_features,omitempty"`
				Address                   *string   `json:"address,omitempty"`
				AllocCpus                 *int32    `json:"alloc_cpus,omitempty"`
				AllocIdleCpus             *int32    `json:"alloc_idle_cpus,omitempty"`
				AllocMemory               *int64    `json:"alloc_memory,omitempty"`
				Architecture              *string   `json:"architecture,omitempty"`
				Boards                    *int32    `json:"boards,omitempty"`
				BootTime                  *int64    `json:"boot_time,omitempty"`
				BurstbufferNetworkAddress *string   `json:"burstbuffer_network_address,omitempty"`
				ClusterName               *string   `json:"cluster_name,omitempty"`
				Comment                   *string   `json:"comment,omitempty"`
				Cores                     *int32    `json:"cores,omitempty"`
				CpuBinding                *int32    `json:"cpu_binding,omitempty"`

				// CpuLoad Integer number with flags
				CpuLoad *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_load,omitempty"`
				Cpus          *int32 `json:"cpus,omitempty"`
				EffectiveCpus *int32 `json:"effective_cpus,omitempty"`
				Energy        *struct {
					AverageWatts       *int32 `json:"average_watts,omitempty"`
					BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`
					ConsumedEnergy     *int64 `json:"consumed_energy,omitempty"`

					// CurrentWatts Integer number with flags
					CurrentWatts *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"current_watts,omitempty"`
					LastCollected          *int64 `json:"last_collected,omitempty"`
					PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
				} `json:"energy,omitempty"`
				ExternalSensors *struct {
					// ConsumedEnergy Integer number with flags
					ConsumedEnergy *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"consumed_energy,omitempty"`
					CurrentWatts     *int32 `json:"current_watts,omitempty"`
					EnergyUpdateTime *int64 `json:"energy_update_time,omitempty"`

					// Temperature Integer number with flags
					Temperature *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"temperature,omitempty"`
				} `json:"external_sensors,omitempty"`
				Extra    *string   `json:"extra,omitempty"`
				Features *[]string `json:"features,omitempty"`

				// FreeMem Integer number with flags
				FreeMem *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"free_mem,omitempty"`
				Gres                 *string                                           `json:"gres,omitempty"`
				GresDrained          *string                                           `json:"gres_drained,omitempty"`
				GresUsed             *string                                           `json:"gres_used,omitempty"`
				Hostname             *string                                           `json:"hostname,omitempty"`
				LastBusy             *int64                                            `json:"last_busy,omitempty"`
				McsLabel             *string                                           `json:"mcs_label,omitempty"`
				Name                 *string                                           `json:"name,omitempty"`
				NextStateAfterReboot *[]SlurmV0039GetNodes200NodesNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`
				OperatingSystem      *string                                           `json:"operating_system,omitempty"`
				Owner                *string                                           `json:"owner,omitempty"`
				Partitions           *[]string                                         `json:"partitions,omitempty"`
				Port                 *int32                                            `json:"port,omitempty"`
				Power                *struct {
					CurrentWatts *int32 `json:"current_watts,omitempty"`
					LowestWatts  *int32 `json:"lowest_watts,omitempty"`

					// MaximumWatts Integer number with flags
					MaximumWatts *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"maximum_watts,omitempty"`
					NewJobTime      *int64 `json:"new_job_time,omitempty"`
					NewMaximumWatts *int32 `json:"new_maximum_watts,omitempty"`
					PeakWatts       *int32 `json:"peak_watts,omitempty"`
					State           *int32 `json:"state,omitempty"`
					TimeStartDay    *int64 `json:"time_start_day,omitempty"`
					TotalEnergy     *int64 `json:"total_energy,omitempty"`
				} `json:"power,omitempty"`
				RealMemory      *int64  `json:"real_memory,omitempty"`
				Reason          *string `json:"reason,omitempty"`
				ReasonChangedAt *int64  `json:"reason_changed_at,omitempty"`
				ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`
				Reservation     *string `json:"reservation,omitempty"`

				// ResumeAfter Integer number with flags
				ResumeAfter *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"resume_after,omitempty"`
				SlurmdStartTime   *int64                             `json:"slurmd_start_time,omitempty"`
				Sockets           *int32                             `json:"sockets,omitempty"`
				SpecializedCores  *int32                             `json:"specialized_cores,omitempty"`
				SpecializedCpus   *string                            `json:"specialized_cpus,omitempty"`
				SpecializedMemory *int64                             `json:"specialized_memory,omitempty"`
				State             *[]SlurmV0039GetNodes200NodesState `json:"state,omitempty"`
				TemporaryDisk     *int32                             `json:"temporary_disk,omitempty"`
				Threads           *int32                             `json:"threads,omitempty"`
				Tres              *string                            `json:"tres,omitempty"`
				TresUsed          *string                            `json:"tres_used,omitempty"`
				TresWeighted      *float64                           `json:"tres_weighted,omitempty"`
				Version           *string                            `json:"version,omitempty"`
				Weight            *int32                             `json:"weight,omitempty"`
			} `json:"nodes,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Nodes *[]struct {
				ActiveFeatures            *[]string `json:"active_features,omitempty"`
				Address                   *string   `json:"address,omitempty"`
				AllocCpus                 *int32    `json:"alloc_cpus,omitempty"`
				AllocIdleCpus             *int32    `json:"alloc_idle_cpus,omitempty"`
				AllocMemory               *int64    `json:"alloc_memory,omitempty"`
				Architecture              *string   `json:"architecture,omitempty"`
				Boards                    *int32    `json:"boards,omitempty"`
				BootTime                  *int64    `json:"boot_time,omitempty"`
				BurstbufferNetworkAddress *string   `json:"burstbuffer_network_address,omitempty"`
				ClusterName               *string   `json:"cluster_name,omitempty"`
				Comment                   *string   `json:"comment,omitempty"`
				Cores                     *int32    `json:"cores,omitempty"`
				CpuBinding                *int32    `json:"cpu_binding,omitempty"`

				// CpuLoad Integer number with flags
				CpuLoad *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"cpu_load,omitempty"`
				Cpus          *int32 `json:"cpus,omitempty"`
				EffectiveCpus *int32 `json:"effective_cpus,omitempty"`
				Energy        *struct {
					AverageWatts       *int32 `json:"average_watts,omitempty"`
					BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`
					ConsumedEnergy     *int64 `json:"consumed_energy,omitempty"`

					// CurrentWatts Integer number with flags
					CurrentWatts *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"current_watts,omitempty"`
					LastCollected          *int64 `json:"last_collected,omitempty"`
					PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
				} `json:"energy,omitempty"`
				ExternalSensors *struct {
					// ConsumedEnergy Integer number with flags
					ConsumedEnergy *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"consumed_energy,omitempty"`
					CurrentWatts     *int32 `json:"current_watts,omitempty"`
					EnergyUpdateTime *int64 `json:"energy_update_time,omitempty"`

					// Temperature Integer number with flags
					Temperature *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"temperature,omitempty"`
				} `json:"external_sensors,omitempty"`
				Extra    *string   `json:"extra,omitempty"`
				Features *[]string `json:"features,omitempty"`

				// FreeMem Integer number with flags
				FreeMem *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"free_mem,omitempty"`
				Gres                 *string                                           `json:"gres,omitempty"`
				GresDrained          *string                                           `json:"gres_drained,omitempty"`
				GresUsed             *string                                           `json:"gres_used,omitempty"`
				Hostname             *string                                           `json:"hostname,omitempty"`
				LastBusy             *int64                                            `json:"last_busy,omitempty"`
				McsLabel             *string                                           `json:"mcs_label,omitempty"`
				Name                 *string                                           `json:"name,omitempty"`
				NextStateAfterReboot *[]SlurmV0039GetNodes200NodesNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`
				OperatingSystem      *string                                           `json:"operating_system,omitempty"`
				Owner                *string                                           `json:"owner,omitempty"`
				Partitions           *[]string                                         `json:"partitions,omitempty"`
				Port                 *int32                                            `json:"port,omitempty"`
				Power                *struct {
					CurrentWatts *int32 `json:"current_watts,omitempty"`
					LowestWatts  *int32 `json:"lowest_watts,omitempty"`

					// MaximumWatts Integer number with flags
					MaximumWatts *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"maximum_watts,omitempty"`
					NewJobTime      *int64 `json:"new_job_time,omitempty"`
					NewMaximumWatts *int32 `json:"new_maximum_watts,omitempty"`
					PeakWatts       *int32 `json:"peak_watts,omitempty"`
					State           *int32 `json:"state,omitempty"`
					TimeStartDay    *int64 `json:"time_start_day,omitempty"`
					TotalEnergy     *int64 `json:"total_energy,omitempty"`
				} `json:"power,omitempty"`
				RealMemory      *int64  `json:"real_memory,omitempty"`
				Reason          *string `json:"reason,omitempty"`
				ReasonChangedAt *int64  `json:"reason_changed_at,omitempty"`
				ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`
				Reservation     *string `json:"reservation,omitempty"`

				// ResumeAfter Integer number with flags
				ResumeAfter *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"resume_after,omitempty"`
				SlurmdStartTime   *int64                             `json:"slurmd_start_time,omitempty"`
				Sockets           *int32                             `json:"sockets,omitempty"`
				SpecializedCores  *int32                             `json:"specialized_cores,omitempty"`
				SpecializedCpus   *string                            `json:"specialized_cpus,omitempty"`
				SpecializedMemory *int64                             `json:"specialized_memory,omitempty"`
				State             *[]SlurmV0039GetNodes200NodesState `json:"state,omitempty"`
				TemporaryDisk     *int32                             `json:"temporary_disk,omitempty"`
				Threads           *int32                             `json:"threads,omitempty"`
				Tres              *string                            `json:"tres,omitempty"`
				TresUsed          *string                            `json:"tres_used,omitempty"`
				TresWeighted      *float64                           `json:"tres_weighted,omitempty"`
				Version           *string                            `json:"version,omitempty"`
				Weight            *int32                             `json:"weight,omitempty"`
			} `json:"nodes,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039GetPartitionResponse parses an HTTP response from a SlurmV0039GetPartitionWithResponse call
func ParseSlurmV0039GetPartitionResponse(rsp *http.Response) (*SlurmV0039GetPartitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039GetPartitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Partitions *[]struct {
				Accounts *struct {
					Allowed *string `json:"allowed,omitempty"`
					Deny    *string `json:"deny,omitempty"`
				} `json:"accounts,omitempty"`
				Alternate *string `json:"alternate,omitempty"`
				Cluster   *string `json:"cluster,omitempty"`
				Cpus      *struct {
					TaskBinding *int32 `json:"task_binding,omitempty"`
					Total       *int32 `json:"total,omitempty"`
				} `json:"cpus,omitempty"`
				Defaults *struct {
					Job          *string `json:"job,omitempty"`
					MemoryPerCpu *int64  `json:"memory_per_cpu,omitempty"`

					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"defaults,omitempty"`
				GraceTime *int32 `json:"grace_time,omitempty"`
				Groups    *struct {
					Allowed *string `json:"allowed,omitempty"`
				} `json:"groups,omitempty"`
				Maximums *struct {
					// CpusPerNode Integer number with flags
					CpusPerNode *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"cpus_per_node,omitempty"`

					// CpusPerSocket Integer number with flags
					CpusPerSocket *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"cpus_per_socket,omitempty"`
					MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

					// Nodes Integer number with flags
					Nodes *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"nodes,omitempty"`

					// OverTimeLimit Integer number with flags
					OverTimeLimit *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"over_time_limit,omitempty"`
					Shares *int32 `json:"shares,omitempty"`

					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"maximums,omitempty"`
				Minimums *struct {
					Nodes *int32 `json:"nodes,omitempty"`
				} `json:"minimums,omitempty"`
				Name     *string `json:"name,omitempty"`
				NodeSets *string `json:"node_sets,omitempty"`
				Nodes    *struct {
					AllowedAllocation *string `json:"allowed_allocation,omitempty"`
					Configured        *string `json:"configured,omitempty"`
					Total             *int32  `json:"total,omitempty"`
				} `json:"nodes,omitempty"`
				Priority *struct {
					JobFactor *int32 `json:"job_factor,omitempty"`
					Tier      *int32 `json:"tier,omitempty"`
				} `json:"priority,omitempty"`
				Qos *struct {
					Allowed  *string `json:"allowed,omitempty"`
					Assigned *string `json:"assigned,omitempty"`
					Deny     *string `json:"deny,omitempty"`
				} `json:"qos,omitempty"`

				// SuspendTime Integer number with flags
				SuspendTime *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"suspend_time,omitempty"`
				Timeouts *struct {
					// Resume Integer number with flags
					Resume *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"resume,omitempty"`

					// Suspend Integer number with flags
					Suspend *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"suspend,omitempty"`
				} `json:"timeouts,omitempty"`
				Tres *struct {
					BillingWeights *string `json:"billing_weights,omitempty"`
					Configured     *string `json:"configured,omitempty"`
				} `json:"tres,omitempty"`
			} `json:"partitions,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Partitions *[]struct {
				Accounts *struct {
					Allowed *string `json:"allowed,omitempty"`
					Deny    *string `json:"deny,omitempty"`
				} `json:"accounts,omitempty"`
				Alternate *string `json:"alternate,omitempty"`
				Cluster   *string `json:"cluster,omitempty"`
				Cpus      *struct {
					TaskBinding *int32 `json:"task_binding,omitempty"`
					Total       *int32 `json:"total,omitempty"`
				} `json:"cpus,omitempty"`
				Defaults *struct {
					Job          *string `json:"job,omitempty"`
					MemoryPerCpu *int64  `json:"memory_per_cpu,omitempty"`

					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"defaults,omitempty"`
				GraceTime *int32 `json:"grace_time,omitempty"`
				Groups    *struct {
					Allowed *string `json:"allowed,omitempty"`
				} `json:"groups,omitempty"`
				Maximums *struct {
					// CpusPerNode Integer number with flags
					CpusPerNode *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"cpus_per_node,omitempty"`

					// CpusPerSocket Integer number with flags
					CpusPerSocket *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"cpus_per_socket,omitempty"`
					MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

					// Nodes Integer number with flags
					Nodes *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"nodes,omitempty"`

					// OverTimeLimit Integer number with flags
					OverTimeLimit *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"over_time_limit,omitempty"`
					Shares *int32 `json:"shares,omitempty"`

					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"maximums,omitempty"`
				Minimums *struct {
					Nodes *int32 `json:"nodes,omitempty"`
				} `json:"minimums,omitempty"`
				Name     *string `json:"name,omitempty"`
				NodeSets *string `json:"node_sets,omitempty"`
				Nodes    *struct {
					AllowedAllocation *string `json:"allowed_allocation,omitempty"`
					Configured        *string `json:"configured,omitempty"`
					Total             *int32  `json:"total,omitempty"`
				} `json:"nodes,omitempty"`
				Priority *struct {
					JobFactor *int32 `json:"job_factor,omitempty"`
					Tier      *int32 `json:"tier,omitempty"`
				} `json:"priority,omitempty"`
				Qos *struct {
					Allowed  *string `json:"allowed,omitempty"`
					Assigned *string `json:"assigned,omitempty"`
					Deny     *string `json:"deny,omitempty"`
				} `json:"qos,omitempty"`

				// SuspendTime Integer number with flags
				SuspendTime *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"suspend_time,omitempty"`
				Timeouts *struct {
					// Resume Integer number with flags
					Resume *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"resume,omitempty"`

					// Suspend Integer number with flags
					Suspend *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"suspend,omitempty"`
				} `json:"timeouts,omitempty"`
				Tres *struct {
					BillingWeights *string `json:"billing_weights,omitempty"`
					Configured     *string `json:"configured,omitempty"`
				} `json:"tres,omitempty"`
			} `json:"partitions,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039GetPartitionsResponse parses an HTTP response from a SlurmV0039GetPartitionsWithResponse call
func ParseSlurmV0039GetPartitionsResponse(rsp *http.Response) (*SlurmV0039GetPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039GetPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Partitions *[]struct {
				Accounts *struct {
					Allowed *string `json:"allowed,omitempty"`
					Deny    *string `json:"deny,omitempty"`
				} `json:"accounts,omitempty"`
				Alternate *string `json:"alternate,omitempty"`
				Cluster   *string `json:"cluster,omitempty"`
				Cpus      *struct {
					TaskBinding *int32 `json:"task_binding,omitempty"`
					Total       *int32 `json:"total,omitempty"`
				} `json:"cpus,omitempty"`
				Defaults *struct {
					Job          *string `json:"job,omitempty"`
					MemoryPerCpu *int64  `json:"memory_per_cpu,omitempty"`

					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"defaults,omitempty"`
				GraceTime *int32 `json:"grace_time,omitempty"`
				Groups    *struct {
					Allowed *string `json:"allowed,omitempty"`
				} `json:"groups,omitempty"`
				Maximums *struct {
					// CpusPerNode Integer number with flags
					CpusPerNode *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"cpus_per_node,omitempty"`

					// CpusPerSocket Integer number with flags
					CpusPerSocket *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"cpus_per_socket,omitempty"`
					MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

					// Nodes Integer number with flags
					Nodes *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"nodes,omitempty"`

					// OverTimeLimit Integer number with flags
					OverTimeLimit *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"over_time_limit,omitempty"`
					Shares *int32 `json:"shares,omitempty"`

					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"maximums,omitempty"`
				Minimums *struct {
					Nodes *int32 `json:"nodes,omitempty"`
				} `json:"minimums,omitempty"`
				Name     *string `json:"name,omitempty"`
				NodeSets *string `json:"node_sets,omitempty"`
				Nodes    *struct {
					AllowedAllocation *string `json:"allowed_allocation,omitempty"`
					Configured        *string `json:"configured,omitempty"`
					Total             *int32  `json:"total,omitempty"`
				} `json:"nodes,omitempty"`
				Priority *struct {
					JobFactor *int32 `json:"job_factor,omitempty"`
					Tier      *int32 `json:"tier,omitempty"`
				} `json:"priority,omitempty"`
				Qos *struct {
					Allowed  *string `json:"allowed,omitempty"`
					Assigned *string `json:"assigned,omitempty"`
					Deny     *string `json:"deny,omitempty"`
				} `json:"qos,omitempty"`

				// SuspendTime Integer number with flags
				SuspendTime *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"suspend_time,omitempty"`
				Timeouts *struct {
					// Resume Integer number with flags
					Resume *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"resume,omitempty"`

					// Suspend Integer number with flags
					Suspend *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"suspend,omitempty"`
				} `json:"timeouts,omitempty"`
				Tres *struct {
					BillingWeights *string `json:"billing_weights,omitempty"`
					Configured     *string `json:"configured,omitempty"`
				} `json:"tres,omitempty"`
			} `json:"partitions,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Partitions *[]struct {
				Accounts *struct {
					Allowed *string `json:"allowed,omitempty"`
					Deny    *string `json:"deny,omitempty"`
				} `json:"accounts,omitempty"`
				Alternate *string `json:"alternate,omitempty"`
				Cluster   *string `json:"cluster,omitempty"`
				Cpus      *struct {
					TaskBinding *int32 `json:"task_binding,omitempty"`
					Total       *int32 `json:"total,omitempty"`
				} `json:"cpus,omitempty"`
				Defaults *struct {
					Job          *string `json:"job,omitempty"`
					MemoryPerCpu *int64  `json:"memory_per_cpu,omitempty"`

					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"defaults,omitempty"`
				GraceTime *int32 `json:"grace_time,omitempty"`
				Groups    *struct {
					Allowed *string `json:"allowed,omitempty"`
				} `json:"groups,omitempty"`
				Maximums *struct {
					// CpusPerNode Integer number with flags
					CpusPerNode *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"cpus_per_node,omitempty"`

					// CpusPerSocket Integer number with flags
					CpusPerSocket *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"cpus_per_socket,omitempty"`
					MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

					// Nodes Integer number with flags
					Nodes *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"nodes,omitempty"`

					// OverTimeLimit Integer number with flags
					OverTimeLimit *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"over_time_limit,omitempty"`
					Shares *int32 `json:"shares,omitempty"`

					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"maximums,omitempty"`
				Minimums *struct {
					Nodes *int32 `json:"nodes,omitempty"`
				} `json:"minimums,omitempty"`
				Name     *string `json:"name,omitempty"`
				NodeSets *string `json:"node_sets,omitempty"`
				Nodes    *struct {
					AllowedAllocation *string `json:"allowed_allocation,omitempty"`
					Configured        *string `json:"configured,omitempty"`
					Total             *int32  `json:"total,omitempty"`
				} `json:"nodes,omitempty"`
				Priority *struct {
					JobFactor *int32 `json:"job_factor,omitempty"`
					Tier      *int32 `json:"tier,omitempty"`
				} `json:"priority,omitempty"`
				Qos *struct {
					Allowed  *string `json:"allowed,omitempty"`
					Assigned *string `json:"assigned,omitempty"`
					Deny     *string `json:"deny,omitempty"`
				} `json:"qos,omitempty"`

				// SuspendTime Integer number with flags
				SuspendTime *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"suspend_time,omitempty"`
				Timeouts *struct {
					// Resume Integer number with flags
					Resume *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"resume,omitempty"`

					// Suspend Integer number with flags
					Suspend *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"suspend,omitempty"`
				} `json:"timeouts,omitempty"`
				Tres *struct {
					BillingWeights *string `json:"billing_weights,omitempty"`
					Configured     *string `json:"configured,omitempty"`
				} `json:"tres,omitempty"`
			} `json:"partitions,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039PingResponse parses an HTTP response from a SlurmV0039PingWithResponse call
func ParseSlurmV0039PingResponse(rsp *http.Response) (*SlurmV0039PingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039PingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Pings *[]struct {
				Hostname *string `json:"hostname,omitempty"`
				Latency  *int64  `json:"latency,omitempty"`
				Mode     *string `json:"mode,omitempty"`
				Pinged   *string `json:"pinged,omitempty"`
			} `json:"pings,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Pings *[]struct {
				Hostname *string `json:"hostname,omitempty"`
				Latency  *int64  `json:"latency,omitempty"`
				Mode     *string `json:"mode,omitempty"`
				Pinged   *string `json:"pinged,omitempty"`
			} `json:"pings,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039GetReservationResponse parses an HTTP response from a SlurmV0039GetReservationWithResponse call
func ParseSlurmV0039GetReservationResponse(rsp *http.Response) (*SlurmV0039GetReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039GetReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Reservations *[]struct {
				Accounts            *string `json:"accounts,omitempty"`
				BurstBuffer         *string `json:"burst_buffer,omitempty"`
				CoreCount           *int32  `json:"core_count,omitempty"`
				CoreSpecializations *[]struct {
					Core *string `json:"core,omitempty"`
					Node *string `json:"node,omitempty"`
				} `json:"core_specializations,omitempty"`
				EndTime        *int64                                          `json:"end_time,omitempty"`
				Features       *string                                         `json:"features,omitempty"`
				Flags          *[]SlurmV0039GetReservation200ReservationsFlags `json:"flags,omitempty"`
				Groups         *string                                         `json:"groups,omitempty"`
				Licenses       *string                                         `json:"licenses,omitempty"`
				MaxStartDelay  *int32                                          `json:"max_start_delay,omitempty"`
				Name           *string                                         `json:"name,omitempty"`
				NodeCount      *int32                                          `json:"node_count,omitempty"`
				NodeList       *string                                         `json:"node_list,omitempty"`
				Partition      *string                                         `json:"partition,omitempty"`
				PurgeCompleted *struct {
					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"purge_completed,omitempty"`
				StartTime *int64  `json:"start_time,omitempty"`
				Tres      *string `json:"tres,omitempty"`
				Users     *string `json:"users,omitempty"`

				// Watts Integer number with flags
				Watts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"watts,omitempty"`
			} `json:"reservations,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Reservations *[]struct {
				Accounts            *string `json:"accounts,omitempty"`
				BurstBuffer         *string `json:"burst_buffer,omitempty"`
				CoreCount           *int32  `json:"core_count,omitempty"`
				CoreSpecializations *[]struct {
					Core *string `json:"core,omitempty"`
					Node *string `json:"node,omitempty"`
				} `json:"core_specializations,omitempty"`
				EndTime        *int64                                          `json:"end_time,omitempty"`
				Features       *string                                         `json:"features,omitempty"`
				Flags          *[]SlurmV0039GetReservation200ReservationsFlags `json:"flags,omitempty"`
				Groups         *string                                         `json:"groups,omitempty"`
				Licenses       *string                                         `json:"licenses,omitempty"`
				MaxStartDelay  *int32                                          `json:"max_start_delay,omitempty"`
				Name           *string                                         `json:"name,omitempty"`
				NodeCount      *int32                                          `json:"node_count,omitempty"`
				NodeList       *string                                         `json:"node_list,omitempty"`
				Partition      *string                                         `json:"partition,omitempty"`
				PurgeCompleted *struct {
					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"purge_completed,omitempty"`
				StartTime *int64  `json:"start_time,omitempty"`
				Tres      *string `json:"tres,omitempty"`
				Users     *string `json:"users,omitempty"`

				// Watts Integer number with flags
				Watts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"watts,omitempty"`
			} `json:"reservations,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0039GetReservationsResponse parses an HTTP response from a SlurmV0039GetReservationsWithResponse call
func ParseSlurmV0039GetReservationsResponse(rsp *http.Response) (*SlurmV0039GetReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0039GetReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Reservations *[]struct {
				Accounts            *string `json:"accounts,omitempty"`
				BurstBuffer         *string `json:"burst_buffer,omitempty"`
				CoreCount           *int32  `json:"core_count,omitempty"`
				CoreSpecializations *[]struct {
					Core *string `json:"core,omitempty"`
					Node *string `json:"node,omitempty"`
				} `json:"core_specializations,omitempty"`
				EndTime        *int64                                           `json:"end_time,omitempty"`
				Features       *string                                          `json:"features,omitempty"`
				Flags          *[]SlurmV0039GetReservations200ReservationsFlags `json:"flags,omitempty"`
				Groups         *string                                          `json:"groups,omitempty"`
				Licenses       *string                                          `json:"licenses,omitempty"`
				MaxStartDelay  *int32                                           `json:"max_start_delay,omitempty"`
				Name           *string                                          `json:"name,omitempty"`
				NodeCount      *int32                                           `json:"node_count,omitempty"`
				NodeList       *string                                          `json:"node_list,omitempty"`
				Partition      *string                                          `json:"partition,omitempty"`
				PurgeCompleted *struct {
					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"purge_completed,omitempty"`
				StartTime *int64  `json:"start_time,omitempty"`
				Tres      *string `json:"tres,omitempty"`
				Users     *string `json:"users,omitempty"`

				// Watts Integer number with flags
				Watts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"watts,omitempty"`
			} `json:"reservations,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`
			Reservations *[]struct {
				Accounts            *string `json:"accounts,omitempty"`
				BurstBuffer         *string `json:"burst_buffer,omitempty"`
				CoreCount           *int32  `json:"core_count,omitempty"`
				CoreSpecializations *[]struct {
					Core *string `json:"core,omitempty"`
					Node *string `json:"node,omitempty"`
				} `json:"core_specializations,omitempty"`
				EndTime        *int64                                           `json:"end_time,omitempty"`
				Features       *string                                          `json:"features,omitempty"`
				Flags          *[]SlurmV0039GetReservations200ReservationsFlags `json:"flags,omitempty"`
				Groups         *string                                          `json:"groups,omitempty"`
				Licenses       *string                                          `json:"licenses,omitempty"`
				MaxStartDelay  *int32                                           `json:"max_start_delay,omitempty"`
				Name           *string                                          `json:"name,omitempty"`
				NodeCount      *int32                                           `json:"node_count,omitempty"`
				NodeList       *string                                          `json:"node_list,omitempty"`
				Partition      *string                                          `json:"partition,omitempty"`
				PurgeCompleted *struct {
					// Time Integer number with flags
					Time *struct {
						// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
						Infinite *bool `json:"infinite,omitempty"`

						// Number If set is True the number will be set with value. Otherwise ignore number contents.
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set. False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"time,omitempty"`
				} `json:"purge_completed,omitempty"`
				StartTime *int64  `json:"start_time,omitempty"`
				Tres      *string `json:"tres,omitempty"`
				Users     *string `json:"users,omitempty"`

				// Watts Integer number with flags
				Watts *struct {
					// Infinite True if number has been set to infinite. "set" and "number" will be ignored.
					Infinite *bool `json:"infinite,omitempty"`

					// Number If set is True the number will be set with value. Otherwise ignore number contents.
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set. False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"watts,omitempty"`
			} `json:"reservations,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest struct {
			// Errors Slurm errors
			Errors *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm internal error number
				ErrorNumber *int `json:"error_number,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`
			Meta *struct {
				// Slurm Slurm information
				Slurm *struct {
					// Release version specifier
					Release *string `json:"release,omitempty"`
					Version *struct {
						Major *int `json:"major,omitempty"`
						Micro *int `json:"micro,omitempty"`
						Minor *int `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"Slurm,omitempty"`
				Plugin *struct {
					Name *string `json:"name,omitempty"`
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Slurm warnings
			Warnings *[]struct {
				// Description Explanation of cause of error
				Description *string `json:"description,omitempty"`

				// Source Where error occurred in the source
				Source *string `json:"source,omitempty"`

				// Warning Earning message
				Warning *string `json:"warning,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9bY/bONI2+lcEnfMAM4A33ZnZZ3FPgBs4jq3uOHFbXtlOz2A2IGiJtpXobUiqOz2D",
	"/PcDvkiWLMlNuTPZxKkviVsiKYpFFYtVF6/6y/bTOEsTknBmv/jLZv6OxFj95Jjn8ldG04xQHhL5F6E0",
	"pfLX/0vJxn5h/z8X+zYudAMXd5fPLp/9/AvSpT8N7JhwbFpLlv00sO8xTcJka/y0svynTwObP2TEfmGn",
	"6/fE56K1ohT2fY62mO8IRSQhdPvQfEt8RyjeEnSPuRqZTUpjzO0Xdpjwn3+yy+bDhJMtoaL9NWYE+WnC",
	"8pgElZarVf/1z9aqJ9bKKSUJ33fSZIxy+QIoSdEdjkQrEWYc+WkUEZ+TwPDRGSV3YZqzk963n3BQxikI",
	"6KsRkJ8mnIrOUJSFybYpmV3KeIJjIn7rVhinoqh8F04S33T84jRob0Y8WQ3Fwa0ePUeYUix7EnISG4vn",
	"8P33T1TtVR9I0wSRhNMWBeOncYyToPXtAvyA0g2K04TvjhW4J+RD6/1NhJXSLN8sIMynYcbDNLFf6PsD",
	"myR5bL/43b6dTMfoZjJbLR17oP565a684vd4+Btyr9CNO1u+Kq7V/tAFbh3njf1u0OzP4QDt0py2T48w",
	"IS1LThIYfuGMY8qNyrZNlDhMct4+4bplwTLih5vQx2ps+83IcoK0KzmYJDBJkM/ukC5XFdaj41fUD0K8",
	"/e+accKUDBkPfePniRoMxWz791mB8pWa41L7Bg4/CedjFuFECtFKN5aPc0bED9VWy5wuH3LQjrhsxYQx",
	"vCWd9VCSx2vSUn0R5TS2xCylCY7U0y1duHXCpzn1SbOd2x2hRFdPfWmsBFaYWHxHLF1n0Gem7udUW3/1",
	"3UG/5VaN4JHpTT5yxEjCUspQgNXkPNSiDQvI1A771z8rdljDmjPQNdqEzbMAc4J4qMwiA9OHkzgjFPOc",
	"khMNx6OSOhi0ruUHBu5g4DZRiisv15jq//qntQ65JYuFydbK0jDh+tu07kO+s4pltT7UYbIJk5Drj3SD",
	"84jbLy4HB60vaU6scFO0t8PMWhOSWIxwi6dW0cgz6z82I/w/toWTwPqPrYr/x7buwyiy1sQKt0lKSfBs",
	"P4DrNI0ITsSrdmmdyUY+J2SW7IZQEuV7qWbFbfmOdzjKyTPLFbu4+5AVDyzKCxNaCEI8v5RokObrqKJw",
	"dDeE+iK8NiwbHDHSY2ieWVeiRuVuyKw8Ec023/+Y8MXOJgoZf9Jy/D5dq50HooRlacKIXOcaw+0Rlkfc",
	"ygi1hqL463Rd1Z31wpUSLct8s7zS+X4aEKt6o3Ml8vVGrN5KkseEhr61b60q0O5vWwxBGDTbe52uJ4FZ",
	"E/e7h6636lxW20TbT0qFmgRJfV2SEo0XX9GBm8j30zzhrV+ovld4mzaU/JEXzolm4SAOEyQ2ZKSruShK",
	"lYGPkjQgSGgKo4JZargdGdiYbu9MV7XqwCBZUTagfR6NXq0x93doQ+TK2a7S1mQbJn3W4nVOGUfrfLMh",
	"7Vs5P8oZJ1Q6qTjFYcfQ6mLtvTomk327XXUTjsOkq3fFXf0NtBYIt3maV1uvLKV+Sglq7P0M5OxnOVqH",
	"SaBXmeaD9/dR3338aL5CLyezMVq6aPnKc4bjhT2oXR25nnN4beGO3jjLw6vTsXtTXBuulm5Hw7Vb1dZr",
	"N1oeMXNnTvVvbzh7U/37Zjiv/7mo3Z6ODytMxwdVxAVZ6a3jvXQXtae5M0e/CJo7nuy4PbAX05V3M0bu",
	"1RVazJ1RrcLVlZFrQ4jvuLrxs5yhjFDEMftgPml0na4P2KdiRq+NXZ1191TVkk/pBzH3gpASn6e0/SUC",
	"goPCWWOgLQIS4Qe0TlNTbRiQjCRB5xgGofi9zjt8LvUCSOzsCWLhn8R4hxL00YUkuQtpmhSqqrcGJ4lU",
	"4OSjH+UBCeTSYe603vuQijZYeEf6dGRfSbbAKf4sXsU3k+kUTWZvh9PJGI2duTMbO7PRb/bAnrmo++ar",
	"4QItlsOlg8YTzxktXU9cXTqL5WR2jV4OR2+uJtOpPbCvPWchP05x3Zldud7IGeuiaObeInc2FVUXzmyM",
	"XrsvkTN7O/Hc2Y0zW4rLc/n5v3Zf2gN77jlXjoduJrPJzeoGzdyxg0buShYUVWV3X6082ZfFm8kcLcXT",
	"F0tPPHw4kmUns2txd/JyKi6OpqvF0vHQaj4WL6M788pZOp577cwcd7XQD3d+HY6WaDlcvFHPRJ7z75Wz",
	"WMq3UTeFHmreKwbl9pU7dVSnK+OzdOdo7k1cb7L8TT9pOBp5K/1maDR1hp5s59pzxuVIjieL4cupvC7e",
	"/Ha4QN5qNlMvJ67oRpaTGwd5zsIRYzTy3FntbW6cG9f7rdbb1UI271wNV9NlMWaN6/Oht5wsJ+6sceff",
	"7qJx7Xb0xhHDWswg0d7N8HrmLCdCfZeNoeFiMbmeyX4UQ4SGy6VzM1edW4xeOeOVFFzt8vCtGNPl6BVa",
	"jLzJfGm0CGxpmmddlsWOcPHRyTKG+miXRi2W+qs0CqwfOM3Jj1ZKLUoighmxfpCb6B+t93In0rRcwjgm",
	"QYhrju7K7f2+wKBjH8IoQoWxu8Fh1N6mLKZ9t0iuBX38N8//VXE41Zrqq5GUIPWn4HnD3+RHZw/sq9V0",
	"ihZLZ74ovlN5RZW8csaON5SzSE7nlTAVCl3grpYyNiKnu1JthQJ47b4UE1Z8It5bVV81eDv0xOeEFmK+",
	"msyn2kuzcJvgqCN84pOEdVgIMQ4jpK6aD5hzPREfojMTH8PVcDKVL1QMglAB//v88vL/FL9/2f/8n/3P",
	"/yt/LpbDawe5q2Vt8MUItSwDJqMiXyhnHRZ+jD+GcR4jYToZzuaiSrn+mtTxGYrwmrQLJCZxSh+O2vv1",
	"In0FpK1obQsrA1hbvVN3NJzWrN+F6y3Ltc5siFXnhOXpZ7l5cCguqrCDVhLtw+jTjKxTb6bTDI7DRIpw",
	"nWIasNojTYSpa/eZM5Uqpz6u13zTdVjqfyBcPVK+rGH9TvhGQrgw/dvvhb7pO5Xv0mxE7HfquxiD9tKM",
	"JKgAixh+FMP5XCmspbeajYZLx2iup3eE+mkch7x9ERP3Wb4WD153rJ0Zpjzs3JNk6T2hvdcs59+r4RTN",
	"3VvDTzajpMslk9EwpSF/OBmulNF0E0b99NMSKQtRaypn5njXYqEU1rHcdM+c5a3rCY0lF2OTd/wjbZ9i",
	"lBRbzKZs5J48J903Q/q0rVfZBrsPub8jp6PCKGGE3uHOiaTuK++i6XekhNSOYCBRmOQfJfyJfOwos8NU",
	"obIMBZ+kCbEPP5qBLZdruWoaCZqFXNiVPlf+c5P3rOjFHqqYZTj5gJ66kS9b0dCIJMA02MMRmqNaFAmT",
	"LOfHi6Q57yojFavhi+6VcJ9VY1/LTynpXamHIPaVlCRNq5E4SymmDygI2YfeD91RgoOT3Lmqav+xCWOC",
	"olAvNidpCdmENgdOb4QSJm3P9okl7m4o+aP7rnhvsdM8WiDpAnuWJfbC7i5T+EsbJYRS6dpt3+OQIxxF",
	"6NAwqWh/WWaTUq25DUV4738g7d7Jj8+f99CUV653O/TGaDidShfOQrooxEZV/CW2XRNPOrTkH9Nh8dtE",
	"f358/hzFeBv6yE/TDyHp6i7imG4Jl2Hwx8oYx7Qqa6J4z6pyfXckFN8Mbp0cjK95WJ/eShH264VyqgUx",
	"TZ+0X0hO7nXNE2w4FTnNZfQYR+yExbr69DDZpL1DtjTvBQcyj9sm224VpKAAe6/XSWpUNRLjj6hci5/Q",
	"jmjj6b2RrezhLM0XZyz1QxWsNnb4mYSSVZEIb9u1rbrfqWnWYRThdUTKTaLJEBxgt0zi09UCEpRKjsWn",
	"j4a4jw7HMaD3I/HtLxK/No1Aps2l+iQHbi1AirZig5Ao8/ikuV5vTnvwPldrTzSuCjfSyZVrZs+po20Q",
	"OG6/8eUCwicN0GMhYkLDOxIg8jHkJXTqpAeRKNyGUiP1CQn3iyA3Qr9NDNhniOw+eSS6Y8M4jHT32+8f",
	"U5EbEhCqFqKUhtsweawUC9dRmGwZwj7XI2JU/C4UKwsEtyG4DcHtJwS3CUMB4Traa6qKxI4AVesexMkN",
	"bBBVvDOCsSP8qXb8vgnEOtwRRZF0s2Hk9NXrs4b0e8XsRWFK1CGgXrtYaQDysg0W/knE/uI0b7lsodPq",
	"lueiRQMBInc4yls9ch1rKQTBa0Fw9CQrVDTQKybS1oIKWErfGpK+tjbL6Cnx9W8vPt0IF59k3ZfB4ErE",
	"qUcMmcdZ011+kpC/RFQZlb6j07rYaVl/nsBu09v190Z62w5SZGJPn7M+O4+MEhJn/IQquOeWCALTnyUw",
	"3RYNFitxD0lQIs/JIz8xDa9Rwu66DS+5UOfR0V5+zUHmXXrfG5YxlLuQsbNU5sDN5FdpUhegK71PqqEH",
	"JapwufLMQjenAnzaAuAnLS5fLn6tZmOPCSwNR3Rwnr+tWU4QJZh1FcjXcdjvwTnLerp22APjJD4apnha",
	"zKAlon+SvJsx/ic286TZ14YDeGJDfQIKzWb2EIEnIANOe/TXhBWQIbVi29ceq//W4QSyBCV/dL5lBW9g",
	"MA9k6c61swtF8OmRCHnDnXJyoFi2pE/Y9o5syzjvIw/Qn91BKFiFZkkgvw3TnUulljlEd19plzLev1av",
	"/W/hKFGVjuw7HhPwvpGGLfI+XVvilrV34+wPpT8ujA7WPRDIcYFIa4ExbW3UB0+rrFPwIO/T9UlYEoVG",
	"qSE7DxmNiJ/LXZqlLls/bPIoKik6frR4atE8scLEkjF5i3GSWZuUWjiKLDHJKgyizYP8ncNT8ip8Pmqq",
	"LrKChNzLjk7Gna5ObeRJLdzKxnGjqArEaIhC1oamsbWvaWVRvg1baRlOI8wi2dFXkUKovk8Vy/Z3sGWJ",
	"V9VcPJ9fcKcMEZWkG70+ig4+j79zzNjfM817r76FHvl6SHi1A745LFeUmDr8ppjxkeao6lFlTDahH/Ie",
	"NVZy5hvu5abqzWZdxpxH4rTrXKWnQPumb7NMuTrkZ1B2xQybNZAa620GFuI+YngUbXfAAk/9XKpd7tHT",
	"r4yzuhaNaFJzKdkBz5gBz9gRJ8zXwjNWixmBsM9d2G2clZIys5v5U72gIgKrV9RogGbVO0KF3W3p8yuk",
	"la9UF2r2J8bva+7dWqDQp2nXraS9VnNAWiNVyqhudKbTT1LE7B/dtB0TSPHVHaLSeXhHaije/ngGHASU",
	"MNYNQ++9QUZhEJH+tVQU2hRCT/1dyIlfUGo2UdLyHLUpODxNeW8OMY3A1oFidGwcC7x15yQ5jqc292oc",
	"cHQZ1ohSHDwZK2zCTrTZEDVl+1TqxfPakapBQUAlNXHBMWtstbXR0h6HlD7pe9xQQsS3cDKz7bYLwqGc",
	"rhSHCQm6C+Ss4+4jORTkmQRmnEXhKDrmCCpDSEOGx/BGfFH7+LRh+FOjleyBvZq9mbm3M3tgj9V/k/HU",
	"sQf2cDp1R0MN8/Q816tESXUYdGDPHe9qtPT2NCkKSzkbe0MJuRpN3dVY3VzdiArlDfdmPnU0KHXmLpHn",
	"LOauxHiKZt1bx3PGSPdIQ7bk1cnsGq0US8ZktnRmw9lIEmg4L123jj/Vl0aihEKMlg3odse/zYY3kxEq",
	"X0dXmSwWK1VhOpwpWGaB7vKcsn9FK+oP2Sd9Xb9j0fzM9W7MGAwkO7LkiJFBx3a0y33XmZIS5HLiJ9eD",
	"7LJEzJg8RfEmxNuY1zQHJTjqt9odCQWrW8jf4WRLAoR5ryYRIxytH7pxeAYn+vNYf4wnaywmLMgA9Y+m",
	"K8SA8Ul54oc4Cv/sGSmo1cty1p1MQRfqJdoSSgr669vVX/VD/P3C7Kalu1Z1fnTRlnfvSbjdHaZp6uY2",
	"r2y4mp582dSTfXZlKKuXw67Aq3Z562SrX0ksoFeorwzx/T2OunJ9PH66uSPYfd8xtQKSmMb/cSRt71NO",
	"qmZt+f7kCeF++xxu7JZuewHtkmGdAVQDgLdJngi99n2mBBFbin3SB7Muz6n0mgat2YgUcL6lnZPB4+0H",
	"TPsDrOoA/1NE9LQzBekdoeg0WFQd4rjD5gbMZ55VGo3VIl5zOri2drs3fWlAhKHKOu92T1m0J7bvOm2+",
	"Cbc57Vo+n6Q1qujwhtboxw7FQ0JP7ocGd5urdsxYuE2ervcPUacnQwDTvE33qs3H6R+R6t2J9VvzQbQi",
	"xtZhFIm9rbKdWP952M9XXF/tT8woeWAyHDG69pvvr8Ty6u8NaB2xv88aK5r8Lw5Rn7dqT1H69w1P3WnS",
	"YkSckLlLqDrWr0px/O9peXITci8BLz28GqJK4+EmrimCP/SqULoeTGnflIMmwKa+Dbl6fq4cv23ONJgb",
	"MDfE0Fa8lKjGD3SYO5B2W5g9gbXVRz6+qz5K4tQZ9dsfHDXkOUKlGxL3WgAPX6YyiP0pYY4zpvQ8rSad",
	"hYqbpPg5Hk6mmq6k+HnrOG+Ka+XvyfXM9ZyCzH7movqF4ey3krVwsRwqZoqZi8rf86G3LEvMXFT7233r",
	"eFNJWr6YO6PysmTfuJq6w6V0Ss6nw5F2yZZF5ivv2kEj92auOz4eVnqu/hC/1KF9fVmf4J86v6pr+td4",
	"pen959PVovr3zWS20t1+5U4lncoCDa+WjofKdmsdqbBzLN5MxJVX7sorxrT87TnuaLTyvMns2jyfBDuF",
	"8v9joVGKpAtPogivncI2PbbdmSztkUPVOd2Kp8VZRLTT9cB79Xn3473DJp2u5Jx15TN7ykLXR4ueuFtp",
	"KOMj+5Ujuu4pj61pTINns68Hs1526eTl4m/eEuwzbzcX2a0w9/p82qqGPLneJ7OWqqYPU/Z53nrTJPuq",
	"kkpu0Br7HzZhFJEAaY4eZt52pXK/iv6DH2mlSGjfahFmvG+dWLyxIb6qqMPUqU+zKgHJ+K7nY/Z1EDeO",
	"2Zb1WrrXPQqqCqcP/aopZM2pUpa15ZNPqdM2Jt311DcVkeSEKj3Ftq/XaywV9UePr75Wp2cf73ckUWMp",
	"57Ipv+Q6QCeqqC3h0le6CfADijAvGCYNqbXklo+h5haxo6fyKJGPE59EpAeFF6ubRqaVFE9jnxoZ6RMf",
	"VAej8iTpWUVaX/06po7nmVcS5iZDGfY/GFeh5I9+vCqquHob00qZz9D6AemMySU5mcm6X67oqGhF1q60",
	"WiCSTmtN1q4QvPRftg5qxvjjiRXNdUZLzXbVbVY/IxTFYZIbHxI7qM97HOQqq5aKeWu84sjTZbS/aWVk",
	"MdbnVzNN+nzErPVDkfXbkqU686R781HjbAO+I1TOfv21HWRWV3ctcddiGUm4ldHUJ4yFydby5iMrTCxG",
	"/DQJmNkZkXJ86g+aqfMe6caSr0SJT8I7Epi1efgFdxwzfsiIhZmld4WDjmhpx0jIY4GfcRzEldbjyIfd",
	"LeoMTptRXVu5Dp3TOcM0tVPHzNJ3z29qfckp0S4AeTReeoYGRwlRWmqFgfVDkseEhv6Pn3/+0H0w7SQK",
	"lHo8Go7knfeRvLpTDaR9/tLeQ+RB2mcubUViIoMO7V7O/dlCk/3QLmU8ChlHrQcM6++H6TrkFNMHqygy",
	"aEXhluRo9ep68KzRfGVpQG5hRJuc7SvO0HX1qdvWfOIhO10bYZ+f1kJxyq7JhbMlibAY9hxXkplIhpgH",
	"x0/VnSjbJ1bfHy6qv4u6XnbeWhMh3LF7O7NSasmzEurQR9eZpLzTsJqMhTnJlIPG+iEhJCCB+I7kXZqm",
	"Uh0U9/X25Mf2R512/qgGxCjBDgfTUKIgLSFTOQCq2ABO6nzDJ3X251c+cyRTR7KauvuA7PWQ6iyLcCIj",
	"aeKL8HHOiPihmGtb3keplGZDtztCiapmpb6EQQViAyVWU12nm5erpV/qRvHptZCoPT4UrIsqorw/6Bdu",
	"LXrbxijOiJ/TkD8sRB0NuyWYEjrMlSNK/XVVrEmvb5f24VL/UhaxRA2S8CKbqnJuxXIxlwX2g7HjPFOb",
	"3A+kRbgrocywL7a0lioysENxY0dwINtRmtv+9R+L6cq7+cdq4Xj/WLpvnNn+GTgL35CH7u3tqrK9fbzx",
	"2VCqiIO2xQAWGCaZn00tiiSW9Jw2wxFh/5908cXBMz+N942L4Q5uxtZ0OrIHdk4jPSrsxcXF/f39s0ql",
	"C4Udr7kw5hNhXuohEjalxppacqIIM65CyaUfOcywvyPWT88uW5+I5e1nKd1eFAiTi+lk5MwWzj9+enb5",
	"bMdjhSonNGbuZkHonWTzLxvZhnyXr2WP9dtdyPOpF+soXV/EmHFCL8aTxWg6nNw4QmXzkEeknN0eYdwa",
	"zid25SCduvWPn35+9vz5s3/+J7+8/OlfaUYSnIXF7C5SxuMstF/YPz+7fCZMpgzznZzMF+W9v+ytslv1",
	"oek0mQT2C/uacFcXkauihBbIqj9dXjanjSgrhn9Ryxz8qXTHMvvF73/p4b2wP70b2CyPY0wf7Be2RzgN",
	"yR2x2hsZ2FxivH4v3+ddZ7OfBuWbPXuvrZBHXu81k8/4Jl/xAceRwSv+Jop9m694cfezwQu+/flbez2l",
	"AvS3ehGEKkdo62vKb/3t5eXPv4xFsfYX1VtVubnLskh366L4BtTSdwwZ1Law6ruVZfXvNEVKdv2DdqQN",
	"0mk46HqoyxtQsEkpshZt0ejC7RwAn88gMvHfAjXWV0KNJXZjIeOhzwAVBqgwQIUBKgxQYYAKA1TYV4oK",
	"A9wN4G6egpsAlA2gbMxnC+A+vy/c5ykhh+81TPNYNlaxra24pD7+o/BaglMKnFLglAKnFDilwCkFTilw",
	"SoFTCpxS4JQCpxQ4pcApBU4pcEqBUwqcUn+bU6oBHg1CvE1Ssde2iry7e6J2gFiBNwu8WU/1ZoECA686",
	"6CHQQ6CHztmQyhO8jojFU4uSP3LCuJXJU7yEKXHsMfVbwq292cUqIHoJj7fffWpC5d+n6wvlRZJSSdlR",
	"xPxClnydriVsXvbmZRo8PMGc0/l5WqmZ23NfqHtFEtGN7IZ2TzYLB3GYoGPZW/f5R9BxUtnDgj2SEmK6",
	"vevHIVLSjjSJqTH3d+goh/OabMOkd7rco2TXOj+unyaMUxx2ZcJVxdgJKXSLdjuzb3AcJp1U3Pqudhe0",
	"Fgi3eVrLDVgJnO2pucvzJyel8+08lx8mW9SXWXs0X6GXk9kYLV20fOU5w/HCHtSujlzPOby2cEdvnOXh",
	"1enYvSmuDVdLt6Ph2q1q67UbLY+YuTOn+rc3nL2p/n0jmbgrfy5qt6fjwwrT8UEVcUFWeut4L91F7Wnu",
	"zNEvguaOJztuD2x5qnKM3KsrtJg7o1qFqyujw8hCfMf1S5nqimPjvIL7Ol0fsE/FjF63EeTHMU460v7g",
	"B5RuUJwmypnSVeCekA+fhfr9djIdSyLzpRhu+dcrd+UVv8fD35B7hW7c2fJVca32hy5w6zhvjKSxS3Pa",
	"wVSetJE0J4F5LgV6uhdp7zVrsqR3yqKhbAwshzJ3Rko/CIUShJT4XGcybckChYNiYExihSTCD6jI1Www",
	"aAHJSBJ0fhhBKH6v804W9moBJOy7XvHJnikPSHIX0jQp1h/zdZh89KM8IEFLQkyzukyjNQy/KU5zSc2C",
	"Iyb+17GH2GdGX8iRlOc9v+03k+kUFYQPY2fuzMbObKSzDXTffDVcyPwMDhpPPGe0dD1xdekslpPZNXo5",
	"HL25mkyn9sC+9pyF1MXiujO7cr2R5JgQRdHMvUXuTOYzWDgzmRwBObO3E8+d3TgyxcRiLrX9a/elPbDn",
	"nnPleEITTW5WNzKPAxq5K1lQVJXdfbXyZF8WbyZztBRPXywlD8ZwJMsq0o3F5OVUXBxNV4ulZLQYi5fR",
	"nXnlLB3PvXZmjrta6Ic7vw5HS7QcLt6oZ9boN9RNsew07xWDcvvKnTqq05XxWbpzNPcmrjdZ/qafNByN",
	"vJV+MzSaOkNPtnPtOeNyJMeTxfClIvoQb347XCBvNdM0MOKKbkSmwfCchSPGaOS5s9rb3Dg3rvdbrber",
	"hWzeuRqupstizBrX50NvOVlO3Fnjzr/dRePa7eiNI4a1mEHLepqLsjE0XCwm14qDpBgiNFwunZu56txi",
	"9MoZr6TgapeHb8WYLkev0GLkTeZL84wYXYbkjvD36RrJMoaaapdGLTGsV2kUWD+Ir/1HK6WWdj1YP8gP",
	"/0frvdxgNQ3VMI5JENbztFZui76FpqvehzCKULGZ2UgmibY2ZTG9Bd4n+wC6szOkO6uJuu+KoT40rao8",
	"b/ibVIqSKGk6RYulM18UelReUSWvnLGjU+JIdbMSpmShq93VUlqQUh3p5D9aQescQYpwSdVXDd4OPaHu",
	"0ELoE5PvvfbSLNwmODolHU4YlYAM0wFzriVFkk4dpPid9oMgVPT/Pr+8/D/F71/2P/9n//P/yp+L5fDa",
	"Qe5qWRv8RYW0qbJMm4yKfKEiaN+W/UdmOCuSP/fIyGaeglaaPSjCaxIdS+B8bPtdL9JXQHpTq7emaj+q",
	"N6FTdzSc1jajC9dblraI2RA3shuDUj1DpVoRc5HFDuR83nLu9OvozNxonWIa1BOtm6hDXbuP1q1UOfVx",
	"vTS2rqMSv6tHypd9coI4wu9T2u63SkKf9Egb15GlnGP2oe6WM2gvzUiCYj2mhsvKcD5XS/7SW81Gw6Vj",
	"tFqkd4T6aazDNM0PUtxn+Vo8eN2xO3gkK55M39rX6nP+vRpOkeR8NHqNjJKuGEM1GTtoyDPUkBlNN2HU",
	"zwJbIuWj0LaYM3O8a7EVmK4WS+nlnznLW9cTNpncbpjMQZ1tv4WqtnB/NqUpgwA56b4Z0tOchGVddh9y",
	"f9fGWQzT/yymfyUpY8f0k9hWGVc2zgIt+94eYSBRmOQfZXZ48rGjzA5TdQ7E8INM0oTYh4tNbzc1CzlB",
	"G+zz1PSwYNWe6GHCsAwnH9DJzn/GcRJgGqASXtUcwaJImGQ5P14kzXlXGWl8mGbzLg2VPpbVvlaRZLtX",
	"pR6Dvq+kpGZajcRZSjF9QEHIPvR+qMKDnxLDV1X7j00YExSF2iADjX2GGluKWG9pQMjnKmRKWJk7o6mY",
	"xd0NJX903xV6Q4PYugsUqqy7xF5ZdpcpQCbHzkq1wBdDjnAUocPNb2VayDKblGor1FAF3vsfSHv0/+Pz",
	"5z2siivXux16Y1TNwq/CCeIve2BfTbzFsvhjOix+m9gaH58/RzHehj7y0/RDSLq6izimW8Jl/o3Hyhgj",
	"/yr2vXjPqiHyrmUqFsfxOzCyAIoEUCSAIgEUCaBIAEUCKBJAkQCKBFAkgCIBFAmgSABFgn8IQJEAigRQ",
	"JIAiQakCKBLkDKBIAEUCKBJAkaAhARQJoEiY/gCKBFAkgCIBFAmgSNDYAIoEIQMoEkCR3wYosknSX1h3",
	"hyShxM9lgh1LXbZ+2ORRVH56P0oCzTyxwsSScEGLcZJZm5RaOIqs9+na8tM4SxNRuIXKsz9BMDBbAogT",
	"QJwA4gQQJ4A4AcQJIE4AcQKIE0CcAOIEECeAOMGfBSBOAHECiBNAnKBUAcQJcgYQJ4A4AcQJIE7QkADi",
	"BBAnTH8AcQKIE0CcAOIEECdobABxgpABxAkgTmC2BFAkgCIBFAmgSABFAigSQJEAigRQJIAiARQJoEgA",
	"RQIoEvxDAIoEUCSAIgEUCUoVQJEgZwBFAigSQJEAigQNCaBIAEXC9AdQJIAiARQJoEgARYLGBlAkgCIB",
	"FAmgSGC2VMyWnw6/QJav45BbCbnXscn9e3GaE2W+ZmkRIPnp8lLBlWSHJKKzwpT5nqnFuYsnU5pbLfNm",
	"EeU0tvTdQRd2tFanOXRZhBPZDSvdWD7OGRE/lIXXMp9K0++gHXHZigljeEs666EudaveRMwTmuBIPV3r",
	"rw77N6d+i+/4dkco0dVTXwKEAiF1ob91nYEJtOhw5u0DyfXnaflbk3FrN0U1NVNk7AjFbNts40YNmpij",
	"opC1oWls7WtaWZRvw6RtTGPCW2aLHMvuIVYfqbh2uCzroHuzqtjdiAmirUnSOjF0oWZ/Yvy+tlmouUd9",
	"mnbdStprNcXV6ltRg9boTKdDtYiFPTo52p4m1MnR+SH1TXWSVJcjGWrt/LzL+1/oA/+cn1b5di39Uje6",
	"Vcbjn2WrbPoxEINmBc0KmhU0K2jWxzRrwwKWgy+/I04CBYDWW1awc79ZbQx67yvRe6C7wCoEPQR6CPTQ",
	"udtQlIi7woQSr5fHMaYPbQ5GLoFIv9tMfgTvROkL+fvi7vLZ5bOff7l4n64v/lL7qU/qlSKigixCHnKQ",
	"J0EhubeXlz//MsKJT6LXsv0MUxwTdVr593Zhvy72Y+RjFkkHvo5OiPloZ5jv7AKyVuzrDh2jg4rSbYkM",
	"P0TyShhnEbE/DQ67oeDoYj/HSBKI/9XYlP1Rj5Dd+SMn9GHfH41krz6/3vbcXUx+tfQTZKW9Q/7Vai6h",
	"40t7YP97NZGo8pcS3/xGHU8aTr0beYZJ/rdaeM/Vfz+J/7xre2CPXHVQa+mKppaLpfxvKRHvy6W7anXe",
	"FwMiNJv96R04lWGRg0UOFjkwtkEPgR4CPQR6qK+x7UuDNyKBlVJhQ3Jt8IH/ElQZqDJQZWBSgR4CPQR6",
	"CPSQkUn1ujSpLHkgjHFrg8Oo4czUZYTNpfxr7S7Ngb1ViN8uf+U14X2clV/SVwnOubPDJT2BkJXmpA8d",
	"mzkra7Lths7LvqMuQBUczziL4xlKyDH+iMozciDns5WzkDF8zd+FlLUeb1XsjKV+qKi2jensTHixVZEI",
	"b9tPQan7nSeA1mEU4XVESoKQ+rj965/WOuTWJkrlumVlaZhwmLAGEzZI83VUsVt0N76GCfsoM3q1AGIc",
	"dzABa2b0o+TqR+fuMebnR5jVvwhzuin3ddo87wia/gw1fY06HW3TO0KTtm0ViPsMxa3JHkHa34e0gSHh",
	"3KUN++5zFm6NWwKkfNZSPpZypv3Gl8s6AlPvDKfeY3liCA3vSIDIx5AjHwiSz3cikCjchtJ91idvT780",
	"P41sPc0o3X8hKQ/M7DOf2d1plyQ6oDuEedTltyGBhgWglIYaRHKsFAvXUZhsGcI+1zPcqPhdiNcRgbxR",
	"kDcK8kY9IW8UYSggXCdSMmeZrSacMvCgq+Kd6LEd4QCJOO/lZi9ixDoYI4si6WbDIMhyvjPhc+aW65U8",
	"ThSmRAHO2uBiCr5FAsmobMpsXallnuJkX2mXMt6/VrlVaJ6eEbes/Vvu8YctWrxrx/GpPfm5zHWKGKf9",
	"1gpZszPIHGHGEfN3YjstZnorC3bHXIb0ZrX0Zgic3uecqwl/7PruQcLnImGViEryWSPJb93mSHpK5kHI",
	"3AeZ+0DO31fmvkYiPZgR5zgjijSGlZxcPbIf8jhrJrGBiXKGE+VL5KtE5ckrmELnOIU6Q5WfJ6Vn0znz",
	"9+b4bM/8SBDLWZ9QbkYJiTN+QhXcM8YMKUkhJel3kJK0Ld9k+GevL4USxjHlyE9Mk/pRwu66Y1XSVZlH",
	"R3v5Naex3KX3vRMmD2WYduwslUP0ZvKrjDlO3dFwug8k2wP7yhk73lAHRa9Wy5VnlvDq1NTbbSk2Qeed",
	"oc77cllNlbbooWBkaAMd0Dm0NcsJogSzrgIqUUqfB+cs64k1Yw+Mk/goiQGcWD/rxJHNPLwg57OWc5Ed",
	"GMR81mIG6+e7EDMcQP9OBN1O1wFiPg8x7xP/PyHfP0yNc03fH4VxCEr+rEUM/ANnLmRKGJKA3QIw2/S0",
	"iCLrsIMfSd7dUPJH912xGLxP18cLdB7j4k1So+4yxUH79hKU/NH5ljLzrzFEW5bu9L3f+x/IgyFeGdie",
	"ge0ZWOeBsxg4i4GzGAwW4CwGOQNnMXAWA2cxcBYDZzFwFoOmB85iEDdwFoO0gbMYpA2cxSBc4CwGKQNn",
	"MUw94CyGiQCcxcBZDDMbOIuBsxg4i4GzGDiLgbMYOIuBsxg4i4GzGDiLgbMYOItBbwJnMUgYOIthDgFn",
	"McgZOIthRgBnMUwU4CyGKQScxcBZDJzF8PEBZzFwFgNnMXAWA2cxcBYDZzF8R8BZDHIGzmIQM3AWA2cx",
	"CBo4i0HMwFkMUwM4i0HEwFkMQgbOYuAsBs5i4Cz+PjiLPw2aRwB+YD/Wpq4so/XgX7ZWpPLAQ4Xu+L32",
	"SwPZ8ddKdgwKDBQYkK6DHgI9BHoI9NCXMKSsGHN/J571Ol1PAitJubVJ8ySQLbA8jjF9sF/YW8ItUVxM",
	"c9EdCa753Wbyk3gnMY2KnVmMvRzQSVBI6e3l5c+/rLIAc/JannHNMMUx4UQoud/bBfs6XVuTsT2wyccs",
	"kts7vb0Vc8/OMN/ZBcq3OCC7B1fZLzjNyaCiYFuwCg+RvBLGWUTsT+80bovxl2nw8AQj8pGEDOIe2mK+",
	"I3TP1Nhe2DgXQ5rIHTCKQmZWMEupKVAM0+1dv6Ow6scRmu+jTOBkGyZ90B6P8kAXJM5+mjBOcdhFx6yK",
	"sVN4nHW77L/K8xxu9Aw1JXzOcumY6eJ6r9zvjaUbzVeSwQQtXbR85TnD8cIe1K6OXM85vLZwR2+c5eHV",
	"6di9Ka4NV0u3o+HarWrrtRstj9Bo0fJvbzh7U/37Zjiv/7mo3Z6ODytMxwdVxAVZ6a3jvXQXtae5M0e/",
	"CJo7nuy4PbAX05V3M0bu1RVazJ1RrcLVlRHasMYE2yXgut/LbNIY0BVyvG7qxWM86QF+QOkGxWnCd8cK",
	"3BPy4bOwId1OpmN0M5mtlmK45V+v3JVX/B4Pf0PuFbpxZ8tXxbXaH7rAreOYwYh3ad7+/ReUjAcbgMQY",
	"HMqxoSrvOE6Vd1AWdMuioWwMTJMvyFVpMGiPMR+G4vc678Q5VgsgYUASyRph+PS+1HnJXUjTpFh/zNfh",
	"Judez7pfmIyvk6oNmM6A6QyYzgb9CMvamKfEPkmWMdRUn5XFKIxjEoR1hpxTSY4+hFGEis3MRhO7NduU",
	"xfQeG8lVAkLRZxqKrom674qhPjStqkoWI3m6ZzpFi6UzXxR6VF5RJffngNCePanQ1e5qKS1IqY7U0lMo",
	"6Nfuy4VkXFo43ltVXzV4O/SEukMLoU9MvvfaS7Nwm+Cow8gECqkKhVTJF2HKHqCrlHbU5+KpObb9rhfp",
	"KyC9qdVbU7Uf1ZvQ4kDbfjO6cL1laYuYDTHw7ADPDsj5e+TZkUeq6qirHgQsfbRuF7FPj7q9NHZBLXPi",
	"Md0vwTjSLpqkiag3aC/NSIJiPaamZ6Tnc7XkL73VbDRcmh18Tu8I9dNYw32bH+TnodNAfy97BtBRAB3F",
	"d0FHYe4kLOtW2bhg+p/h9KeEEXqHOxWwuq/iyqbrj+r7N0ctEnKCNtjnCkJzIn2HSbUMJx/Qyc7/L8cl",
	"UXIpmJzwap7M71WrOBXWq1KPQW87g2pSjcRZSjF9aJILGh97OymG33ZizqQanL+C81cg5PM4f/WtH66q",
	"nJ1qwUeGHOEoatCQVaaFLLNJqbZCDVVg1ymrgf3x+fMeVsWV690OvTEaTqcyELqQgb7l6JX8yx7YVxNP",
	"hoXlH9Nh8dvE1vj4/DmK8Tb0kZ+mH0LS1V3EMd0SLtNsPFbGGPn3qYqm/L2GQnj3dIQ7gCQBJAkgSQBJ",
	"AkgSQJIAkgSQJIAkASQJIEkASQJIEkCS4C8CkCSAJAEkCSBJUKoAkgQ5A0gSQJIAkgSQJGhIAEkCSBKm",
	"P4AkASQJIEkASQJIEjQ2gCRByACSBJDkNwGSbNBv5pISUwcD69yVyl7M0iIi8dPlJRCbA6EwEAo/lVCY",
	"EpZHvOVb8OQNKyPUGgqpKabaDg1XKdHypTXLqwnlpwGxqjc6p7nfGklI8pjQ0Lf2rR2swR16fA8bqLcn",
	"GX/NmrjfPXS91RM4ioHfGXjmYVmAZQGWBVgWYFn4orT/au8RQOIkWEhgIYGEJWDQgh4CPQR6CPRQTwvK",
	"2uAwIofZkmqe3cNcSZ8G9oX8fXF3+ezy2c+/XLxP13LIt+RoCqVrwl+Lko8kULoKI06oFW4sf4eTLQks",
	"FiY+0R2Wx+qeWSslL74LmVW2Zvk4sdRWSMhgg5m4SEkWhUQGfFqTMf2RE/qwz8ZUeYxdTcFkEizSSZlE",
	"UZ2SCXzgZ7M2FLO8Y4gf4YSgOelzItScGCLZdkfvZN9R10YZIsRnESFWQo7xR1TCdEDOZytnIWP4mr8L",
	"KWs93qrYGUv9ULH9GJ+oNaHmUUUivG0HYqj7nSCEdRhFeB2R8oxCfdz+9U9rHXJrE6Vy3bKyNEw4TFiD",
	"CRuk+Tqq2C26G1/DhH2UnKlaADGOO8hINDnTUX6no3P3GPnMI+ROX4S8yZR+J21CrkDTn6Gmr7E3oW16",
	"R2jStq0CcZ+huPV5c5D29yFtAGmfu7Rh333Owq3B20HKZy3lY6yX7Te+HPEhTL0znHqPUVUSGt6RAJGP",
	"Ie+A0MFEOIuJQKJwG0r3WR/q0H5Mow3C0GaU7r/ACwoz+8xndjfzq8QfdIcwj7r8NiTQUAOU0lDDU46V",
	"YuE6CpMtQ9jneoYbFb8L8ToiQF0L1LVAXfsE6lrCUEC45nI1J7qoct4aeNBV8U5c2o5wgESc93KzFzFi",
	"HYfWiyLpZsMgyHK+M+Fz0lv34q8WhSlRgLM2uJiCb5FAkrqYkutUapmzLO4r7VLG+9cqtwpNEKm4Ze3f",
	"co8/bNHiXTuONrGJwWPhnwQxTvutFbJmZ5A5wowj5u/EdlrM9FYino65DAzLNYZlBE7vc6aLxR+7vnuQ",
	"8LlIWHHhSkodJCl22hxJTyE/B/JwIA8HOX9f5OENLm+YEec4Iwom9QotcA8Cdh5nTR5NmChnOFG+BGU+",
	"Kk9ewRQ6xynUGar8PFkFms6ZvzfNQDv5PEEsZ31CuRklJM74CVVwzxgzZEWArAjfQVaENsr78M9eXwol",
	"Mlkv8hNTXnFK2F13rEq6KvPoaC+/Zib9XXrfO2fLUIZpx85SOURvJr/KmGOR00wHkmvJ+WTSvuXKM+Pc",
	"PTX7TxvLP+i8M9R5Xy6xgtIWPRSMDG2gAzqHtmY5QZRg1lUgX8dhvwfnLOuJNWMPjJP4KIkBnFg/a+76",
	"ZioQkPNZy7lIUAJiPmsxg/XzXYgZDqB/J4Jup+sAMZ+HmPe5x56QcgymxrlmEIMkcZAkDoT87SeJk4Dd",
	"AjDbnqTtW88jJ0tQ8kfnW1YSzRmsc7J0p++9K30c8EgDjzTw2QOfPXAWA2cxGCzAWQxyBs5ikDJwFsOE",
	"Bc5i4CyGkBFwFoO4gbMYpA2cxSBt4CwG4QJnMUgZOIth6gFnMUwE4CwGzmKY2cBZDJzFwFkMnMXAWQyc",
	"xbDcAGcxzATgLAbOYuAsBs5i0JvAWQwSBs5imEPAWQxyBs5imBHAWQwTBTiLYQoBZzFwFgNnMXx8wFkM",
	"nMXAWQycxaDzgLMYOIvhOwLOYpAzcBaDmIGzGMQMB9CBsxjEDJzFsKIDZzGIGDiLQcjAWQycxcBZDJzF",
	"3y9n8adB8wjAD+zH2tSVZbQe/MvWilQeeKjQHb/XfmkgO/5ayY5BgYECA9J10EOgh0APgR76EoaUlaTc",
	"2qR5EsgqLI9jTB/sF/aWcCsKGRfDIXMQDGwuETW/20x+B+9E+Qv5++Lu8tnls59/uageVtyq/ZaQhRzg",
	"SVBI7e3l5c+/yF8+j4JrwqdFNQlMytKiiZ8uL8Gc+4bVaHU6dAzzFSWmmOspZnyUJiyPSdCjyphsQj/k",
	"PWqsskCf5DXwwui5O+tSfx6JU94BBvQII/TO+G2WKceRYdkVM2wWlkNYDsEsB7Mc1hNYT2A9gfUE1pPP",
	"tr2ihOURZ+KNxW4KR5FVajBwWIOjCDQZaDKwjEEPgR4CPQR6yMSiyhO8jojFU0sesmW8YlA1vNfC3lKD",
	"zin2P5CgKCynvpE/O0kDcvGXJHsQ0+WTevGIqA1Yl2t7LEvM0kCMQ4YpjgknQj/+3j4nRElLbvgGNvmY",
	"RRLNpNFcYubaGeY7uyC1sMvu2PvjxPYLTnMyqGjoltN5D5G8EsZZROxP78DZDksALAGwBIApCnoI9BDo",
	"IdBDfUxRyUGtbMEAvHmgukB1geoCEwr0EOgh0EOgh/qaUKU/TyVmO/Dm6TKJ8qgduu0Gj0FNrwkHZxxo",
	"cNDg36EGLwksOya7ysiIqvkezbP+4CCghLWXVeei++ZLQmEQkf61FFO+IcIMU38XcuKLF27tuqRNM+3A",
	"Ok17Mfqtc8r4Ot9sCEWajBsdG0c/yhk/dmD6GNFfnyRXfpbLk+p6RTSsEaUYGObOOTu74Vwgmw1RqqRP",
	"pYTQ7UOLUrojFG8JusfcOHHaGjOCfA1nRfuWDcb5xFpF/vmik/AJnOEnIFPX+WkUEZ83EcDdzO13YZqz",
	"k+ZjRyJnaeghRhKmTdv6JGp5EszHc1TJh1rHWM2iXMLw+9gqnMRyS5kDGdmZTqieWeNP2iVsKCHCQocp",
	"dKY6aduVnEylHqc4TEjQXSBnHXd3KeOd2x65MK9zZmquHc+ceCRf0keuMtsivBH7sH3mC8PECjoTrD2w",
	"V7M3M/d2Zg/ssfpvMp469sAeTqfuaKgz7Hue61XyL+gECwN77nhXo6W3kMlqF473VqWxn429oUxnO5q6",
	"q7G6uboRFcob7s186ixV8oaZu0Ses5i7Mr2+aNa9dTxnjHSPdDpceXUyu0arucxhP5ktndlwNnLkA166",
	"bj31v740EiVUsv6yAd3u+LfZ8GYyQuXr6CqTxWKlKkyHM5URv8ic6zll/4pW1B+yT/q6fsei+Znr3Rgl",
	"o9Cu0mSLFF1+e56j+6Qr/06R3qinKsxSanpwriNH0inrf5TeE9avSpGmFDY3Z53ii9zLbPw9TEJRpTE5",
	"TKYzwR96VSiziZsw54YxQSqpR4BNFwSechw9dWNGCY76eR+PpAdRt5C/w8mWBAjzXk0iRjhaP3RnD6fy",
	"dCzuTF9CidhBqmUOPvlzTbIT5TQOUP8MOCoLk+nHmxE/xFH4JwlQHx90rZ72IzZjh5VCvT69UqWA5fbt",
	"Wm6cxFlKMX2QmWz7Uaublu7az/Cj2xV5956E292hpzBI83VUiaRqtVQPTTbhCbKpz0Y6AFgOwJQBIgEQ",
	"CYBIAEQCIBJg+wKIBEAkwCcAiARAJMB8BEQCTChAJMAUAkQCIBLArw2IBEAkgOIGRAIgEgCRAJ88IBIA",
	"kQCWGyASAJHwDbJLQI5YADIAkAHIcQBQBXoI9BDoIdBDJ5lRx5LElnZWKzVXlrKj3FwqN9o3Qc8lCcpe",
	"psHDE8zHCq7M3EddwZPVhwTTdcjFzssqirRMoAJF1qyurWFrNF9ZGmdmyeoDoxh2EZTs6pPuwuCzRS11",
	"LYR93q9mEQ47mNnk3tqShNDQtyhRXyCzNmKV0URzx8Jf5k/vX2PvkTxMKCaul1201kSITGzorZRacgOv",
	"PBFdjsw8bJkGOSPUmoyFTmNEzYIfEkICoZ02lrxL01T65or7Wuf82P4ocFqev9OycNwdfPyMhdvEEl+W",
	"nKCq2ADce9+we2/v9IIv+TtAG/XeiYJJAyYNmDSgCMGkAZMGTBr4kr9Ck6aZR1J6nYpFse4Y+gRU7OCn",
	"Bz89+OkhXgh6CPQQ6CHQQwC7AvUF6gvUF5hRoIdAD4EeAj30Zcwo7aZqzYlYcWFZlWFtYrA+DewL+fvi",
	"7vLZ5bOff7koGcjM8iayx5BZV2HECbXCjaUPylksTPyi+/JM0zNrpcTHdyGzytYsHycWJSyPuBDJBjNx",
	"kZIsCol0N7ZCvP7ICX3YY7yqLBpVVJfR+SOF8xJFIQkjLBWwVADlIVAeAuUhRPOA8hAoD+ETAMpDoDyE",
	"+QiUhzChgPIQphBQHgLlIcBQgfIQKA9BcQPlIVAeAuUhfPJAeQiUh0B5CJSHQHkI4DVAJAAiARAJgEgA",
	"RAIgEgCRAIgEcNoBIgEQCTAfAZEAEwoQCYBIAEQCIBLArw2IBEAkgOIGRAIgEgCRAJ88IBIAkQCWGyAS",
	"AJEAbGBArQBABgAyAAsPAKpAD4EeAj0EZtTejJJEX0z0VCOfWjIx4ig6mo2xyQRWOmwv/ip/SkjVJzN6",
	"sHlRySx5Y1m8RwbHer+elsZx0M1cxuW8uBf/JKlVPlQzmjHrhyTlVhTGISeBxaslwsRaeVOLJEGWhgn/",
	"sYX8DIjMYJWDVe4MVrmOANchdthP84S33Ymi9L7DTRKQ5MGoXwMbR3KicnIMGdt+TzsP693imH3oiXGV",
	"UYKTfTDaA9DSlffpurXjyqGJMkKRn+WmoQztxwWP/XcB0NlS7LfjuDom8ZamedbrM217rA77tYEPs5zJ",
	"KSvzDMFEPF80uJSyigWBnM9UzictQeU5I5gSZzgl0jtC5YKD5M4Q5Hyu6IAdNg/Wg9X5XVmdcZh0mH+l",
	"7j9pj9QNvU0DgpgGnbTe7TZpkTwX2o118tNkE25z2hXKf9KuL6NhSkP+0LrrQxvsc+UIMPrGCD25H3+k",
	"PbfmKgXw0/ftLGcZSQIEGuKM1woh3DRv820oICEI/lyNBPV1g3y/m6W/AMTVhbgOoyhMthryxvqvs4YP",
	"BxwbAEEgRAYhMgiRQYgMQmRgsUCIDCYihMhAzhAigykBITKQM4TIYCZAiAxCZBAiAw0BITIQPITIQL4Q",
	"IoMQ2d91RrF6Ig74HiC8BuE1OGcNYX7QQ6CHQA+BHurN97DHUVibNE+CFr6HusXVj/CB9SR4YI8xPOyp",
	"FDRRZwsPgrVSUuS7kFlla5aPE0vs/CMuJLPBTFykJItCwoA7AVYMWDEAGAbAMACGgZ8OgGEwEQEYBnIG",
	"YBhMCQCGgZwBGAYzAYBhAAwDYBhoCACGgeABGAbyBWAYAMMAVAEhMgiRQYgMQmQQIgOLBUJkMBEhRAZy",
	"hhAZTAkIkYGcIUQGMwFCZBAigxAZaAgIkYHgIUQG8oUQGYTIgDsBwmsQXoMzy6DDIMwPegj0EOih8+VO",
	"wFF0En+CfrNHmBPmohgQCYD6BPX5N6CkCt3ZMdl3KeOdT44wJ4n/YBhfjTWyotGM6IMxhAP20mCHgiIF",
	"RQqKFBTpN2RIK0ouJt5YSMnihHHwSYIOBh0MvgCwBUEPgR4CPQR6yMiUyhO8jojFU4uSP3LCeNWiqvkm",
	"99dN3JGUMELvlLr7q/IHEpPkkxnFq7ev9hjHq5oKlQrWDEu+1VaG1gzz3Z6g9bB30j36Rx5KkAKnOamy",
	"tjang+ZoZWGcRcT+NOimn03EIO97+EOSckvip0mgBLC/FybWypv+eISxFthnYX2D9e0M1rfKZ296uLbR",
	"gXVOGUfrfLPpOv+aUoJkA4ZAY1lBygxH4Z+P9k4U74Rln+hDqSKGDdTVhmCea2BaoxsKdljtf32WFrBE",
	"kuSxWNhuhpPZ0h7YMxcVP8fDyfQ3dan4ees4b4pr5e/J9cz1HPTafblQd+oXhrPf0MwdO+L3YjlcTkaq",
	"VPl7PvSWZYmZi2p/u28dbzqci7pzZ1ReXk5uHHQ1dYeio54znw5HjnjWdFoWma+8aweN3Ju57vh4WOm5",
	"+kP8cmbj/WX1x9XU+VVd07/GK2+4nLgzNJ+uFtW/byazle72K3c6lu+MhldLx0Nlu7WO3AyvZ45678Wb",
	"ibjyyl15xZiWvz3HHY1WnjeZXdvvBl0f4H7q7A+4Nr2DoU+KNax52hp/RIxjylFAIvxg+K0cP7HQ56uT",
	"FaKQ8XaPZBEVbr+b0614mjBDuHJcHpx2B/T99wTSVfO4hwLlXcozZ4S237nHnMMpz+8I+A1hDvARwh4K",
	"9lCwh4I9FOyhYA8Feyiwd2EPBXsomFOwh/paoWKVoBqcYIUdGOzAAKUBniDQQ6CHQA+BHup9grXqaus8",
	"w3podfWFjLHeADHIAg4WLKwcsHJADAFiCBBDgBgCxBDA3wsxBJhTEEOAXS9432APBXso2EPBHgr2ULCH",
	"gj0U2Luwh4I9FOyhYA8FOCzYgcEODPAPoMXAEwR6CPQQ6KHzwmHhKDLCYkkL3c9Vksrf/7J5+oEk9ovf",
	"36kNk/j1afCXvSaYEjrM+U5eeSdq0bsCb5XTyH5hX0iIkn7C4fDEhO/SgFl8h7klEVKW7IPPo2CPlVLd",
	"ajJptdTepNRyM5IM55PiW/RLPJhuLs1IgrPQ/vTu0/8fAAD//5DnSp2pVAUA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
